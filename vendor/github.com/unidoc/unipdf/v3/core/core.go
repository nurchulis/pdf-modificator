//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_beb "bufio";_db "bytes";_be "compress/lzw";_dg "compress/zlib";_ff "crypto/md5";_ed "crypto/rand";_fb "encoding/hex";_e "errors";_bb "fmt";_dba "github.com/unidoc/unipdf/v3/common";_ef "github.com/unidoc/unipdf/v3/core/security";
_ge "github.com/unidoc/unipdf/v3/core/security/crypt";_gaf "github.com/unidoc/unipdf/v3/internal/ccittfax";_gdf "github.com/unidoc/unipdf/v3/internal/imageutil";_gf "github.com/unidoc/unipdf/v3/internal/jbig2";_dc "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";
_dce "github.com/unidoc/unipdf/v3/internal/jbig2/decoder";_df "github.com/unidoc/unipdf/v3/internal/jbig2/document";_fc "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_dgc "github.com/unidoc/unipdf/v3/internal/strutils";_bed "golang.org/x/image/tiff/lzw";
_cf "golang.org/x/xerrors";_ea "image";_c "image/color";_fg "image/jpeg";_gd "io";_de "io/ioutil";_g "reflect";_b "regexp";_a "sort";_ecd "strconv";_ga "strings";_ec "sync";_ac "time";_d "unicode";);

// UpdateParams updates the parameter values of the encoder.
func (_dbfbg *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_ebga ,_bdaf :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _bdaf ==nil {_dbfbg .ColorComponents =int (_ebga );
};_edage ,_bdaf :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _bdaf ==nil {_dbfbg .BitsPerComponent =int (_edage );};_ccg ,_bdaf :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));
if _bdaf ==nil {_dbfbg .Width =int (_ccg );};_gga ,_bdaf :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _bdaf ==nil {_dbfbg .Height =int (_gga );};_ccbf ,_bdaf :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));
if _bdaf ==nil {_dbfbg .Quality =int (_ccbf );};_bcfba ,_bega :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));if _bega {_dbfbg .Decode ,_bdaf =_bcfba .ToFloat64Array ();if _bdaf !=nil {_dba .Log .Error ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u006f\u006ev\u0065\u0072\u0074\u0069\u006e\u0067\u0020de\u0063\u006f\u0064\u0065 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006eto\u0020\u0061r\u0072\u0061\u0079\u0073\u003a\u0020\u0025\u0076",_bdaf );
};};};

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_fdee *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _efcc ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _fdee .ColorComponents !=1||_fdee .BitsPerComponent !=1{return nil ,_fc .Errorf (_efcc ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");
};var (_fggfc *_dc .Bitmap ;_fbfba error ;);_bffa :=(_fdee .Width *_fdee .Height )==len (data );if _bffa {_fggfc ,_fbfba =_dc .NewWithUnpaddedData (_fdee .Width ,_fdee .Height ,data );}else {_fggfc ,_fbfba =_dc .NewWithData (_fdee .Width ,_fdee .Height ,data );
};if _fbfba !=nil {return nil ,_fbfba ;};_fbab :=_fdee .DefaultPageSettings ;if _fbfba =_fbab .Validate ();_fbfba !=nil {return nil ,_fc .Wrap (_fbfba ,_efcc ,"");};if _fdee ._ecge ==nil {_fdee ._ecge =_df .InitEncodeDocument (_fbab .FileMode );};switch _fbab .Compression {case JB2Generic :if _fbfba =_fdee ._ecge .AddGenericPage (_fggfc ,_fbab .DuplicatedLinesRemoval );
_fbfba !=nil {return nil ,_fc .Wrap (_fbfba ,_efcc ,"");};case JB2SymbolCorrelation :return nil ,_fc .Error (_efcc ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
case JB2SymbolRankHaus :return nil ,_fc .Error (_efcc ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
default:return nil ,_fc .Error (_efcc ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _fdee .Encode ();};

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_fggf :=&PdfCrypt {_cgb :false ,_gbf :make (map[PdfObject ]bool ),_acc :make (map[PdfObject ]bool ),_dfga :make (map[int ]struct{}),_afd :parser };_dde ,_aagf :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );
if !_aagf {_dba .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");
return _fggf ,_e .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_dde !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_dba .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_dde );
return _fggf ,_e .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_fggf ._bgc .Filter =string (*_dde );if _aea ,_cbdg :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_cbdg {_fggf ._bgc .SubFilter =_aea .Str ();
_dba .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_aea );};if L ,_eaee :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_eaee {if (*L %8)!=0{_dba .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");
return _fggf ,_e .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_fggf ._bgc .Length =int (*L );}else {_fggf ._bgc .Length =40;};_fggf ._bgc .V =0;if _aec ,_fcc :=ed .Get ("\u0056").(*PdfObjectInteger );
_fcc {V :=int (*_aec );_fggf ._bgc .V =V ;if V >=1&&V <=2{_fggf ._da =_cgg (_fggf ._bgc .Length );}else if V >=4&&V <=5{if _eac :=_fggf .loadCryptFilters (ed );_eac !=nil {return _fggf ,_eac ;};}else {_dba .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );
return _fggf ,_e .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _aecb :=_gdc (&_fggf ._fbbg ,ed );_aecb !=nil {return _fggf ,_aecb ;};_cfa :="";if _bdd ,_dad :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );
_dad &&_bdd .Len ()>=1{_dgg ,_fgea :=GetString (_bdd .Get (0));if !_fgea {return _fggf ,_e .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_cfa =_dgg .Str ();}else {_dba .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");
};_fggf ._gfd =_cfa ;return _fggf ,nil ;};

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_bddf *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_dba .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_dba .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_bddf .Predictor );
_ecaa ,_cffgd :=_bddf .DecodeBytes (streamObj .Stream );if _cffgd !=nil {return nil ,_cffgd ;};_dba .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_dba .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_ecaa ),_ecaa );
if _bddf .Predictor > 1{if _bddf .Predictor ==2{_dba .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_bdag :=_bddf .Columns *_bddf .Colors ;if _bdag < 1{return []byte {},nil ;};_fcb :=len (_ecaa )/_bdag ;if len (_ecaa )%_bdag !=0{_dba .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");
return nil ,_bb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_ecaa ),_bdag );};if _bdag %_bddf .Colors !=0{return nil ,_bb .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_bdag ,_bddf .Colors );
};if _bdag > len (_ecaa ){_dba .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_bdag ,len (_ecaa ));
return nil ,_e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_dba .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_ecaa ),_ecaa );
_cedb :=_db .NewBuffer (nil );for _dcdf :=0;_dcdf < _fcb ;_dcdf ++{_efge :=_ecaa [_bdag *_dcdf :_bdag *(_dcdf +1)];for _bff :=_bddf .Colors ;_bff < _bdag ;_bff ++{_efge [_bff ]=byte (int (_efge [_bff ]+_efge [_bff -_bddf .Colors ])%256);};_cedb .Write (_efge );
};_egca :=_cedb .Bytes ();_dba .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_egca ),_egca );return _egca ,nil ;}else if _bddf .Predictor >=10&&_bddf .Predictor <=15{_dba .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_aeg :=_bddf .Columns *_bddf .Colors +1;if _aeg < 1{return []byte {},nil ;};_dff :=len (_ecaa )/_aeg ;if len (_ecaa )%_aeg !=0{return nil ,_bb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_ecaa ),_aeg );
};if _aeg > len (_ecaa ){_dba .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_aeg ,len (_ecaa ));
return nil ,_e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_bcda :=_db .NewBuffer (nil );_dba .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_bddf .Columns );
_dba .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_ecaa ),_aeg ,_dff );_gdfgb :=make ([]byte ,_aeg );for _ebgg :=0;_ebgg < _aeg ;_ebgg ++{_gdfgb [_ebgg ]=0;
};for _egdag :=0;_egdag < _dff ;_egdag ++{_ccbg :=_ecaa [_aeg *_egdag :_aeg *(_egdag +1)];_ecfc :=_ccbg [0];switch _ecfc {case 0:case 1:for _fefg :=2;_fefg < _aeg ;_fefg ++{_ccbg [_fefg ]=byte (int (_ccbg [_fefg ]+_ccbg [_fefg -1])%256);};case 2:for _gef :=1;
_gef < _aeg ;_gef ++{_ccbg [_gef ]=byte (int (_ccbg [_gef ]+_gdfgb [_gef ])%256);};default:_dba .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_ecfc );
return nil ,_bb .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_ecfc );};for _gfbe :=0;_gfbe < _aeg ;_gfbe ++{_gdfgb [_gfbe ]=_ccbg [_gfbe ];};_bcda .Write (_ccbg [1:]);
};_bddfa :=_bcda .Bytes ();return _bddfa ,nil ;}else {_dba .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_bddf .Predictor );
return nil ,_bb .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_bddf .Predictor );};};return _ecaa ,nil ;};var _gabb =_b .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");


// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_acd *JBIG2Encoder )DecodeImages (encoded []byte )([]_ea .Image ,error ){const _edad ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_eddd ,_fdaf :=_dce .Decode (encoded ,_dce .Parameters {},_acd .Globals .ToDocumentGlobals ());
if _fdaf !=nil {return nil ,_fc .Wrap (_fdaf ,_edad ,"");};_gffg ,_fdaf :=_eddd .PageNumber ();if _fdaf !=nil {return nil ,_fc .Wrap (_fdaf ,_edad ,"");};_bdbc :=[]_ea .Image {};var _ddgc _ea .Image ;for _aaggg :=1;_aaggg <=_gffg ;_aaggg ++{_ddgc ,_fdaf =_eddd .DecodePageImage (_aaggg );
if _fdaf !=nil {return nil ,_fc .Wrapf (_fdaf ,_edad ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_aaggg );};_bdbc =append (_bdbc ,_ddgc );};return _bdbc ,nil ;};

// HasInvalidHexRunes implements core.ParserMetadata interface.
func (_fggb ParserMetadata )HasInvalidHexRunes ()bool {return _fggb ._fccc };func (_afbe *PdfParser )getNumbersOfUpdatedObjects (_acaf *PdfParser )([]int ,error ){if _acaf ==nil {return nil ,_e .New ("\u0070\u0072e\u0076\u0069\u006f\u0075\u0073\u0020\u0070\u0061\u0072\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020nu\u006c\u006c");
};_aacf :=_acaf ._bcaf ;_feagg :=make ([]int ,0);_ccac :=make (map[int ]interface{});_egdfe :=make (map[int ]int64 );for _dbfbb ,_ffce :=range _afbe ._bbbaa .ObjectMap {if _ffce .Offset ==0{if _ffce .OsObjNumber !=0{if _gabcc ,_gffac :=_afbe ._bbbaa .ObjectMap [_ffce .OsObjNumber ];
_gffac {_ccac [_ffce .OsObjNumber ]=struct{}{};_egdfe [_dbfbb ]=_gabcc .Offset ;}else {return nil ,_e .New ("u\u006ed\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0078r\u0065\u0066\u0020\u0074ab\u006c\u0065");};};}else {_egdfe [_dbfbb ]=_ffce .Offset ;};
};for _ddbdf ,_deff :=range _egdfe {if _ ,_dcfa :=_ccac [_ddbdf ];_dcfa {continue ;};if _deff > _aacf {_feagg =append (_feagg ,_ddbdf );};};return _feagg ,nil ;};

// Elements returns a slice of the PdfObject elements in the array.
func (_cgac *PdfObjectArray )Elements ()[]PdfObject {if _cgac ==nil {return nil ;};return _cgac ._ebb ;};

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};

// GetFilterName returns the name of the encoding filter.
func (_ebd *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };

// WriteString outputs the object as it is to be written to file.
func (_agbfe *PdfObjectNull )WriteString ()string {return "\u006e\u0075\u006c\u006c"};

// GetFilterName returns the name of the encoding filter.
func (_deed *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };func (_eafg *PdfParser )parseObject ()(PdfObject ,error ){_dba .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");
_eafg .skipSpaces ();for {_cacc ,_dccb :=_eafg ._cega .Peek (2);if _dccb !=nil {if _dccb !=_gd .EOF ||len (_cacc )==0{return nil ,_dccb ;};if len (_cacc )==1{_cacc =append (_cacc ,' ');};};_dba .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_cacc ));
if _cacc [0]=='/'{_gdbf ,_aade :=_eafg .parseName ();_dba .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_gdbf );return &_gdbf ,_aade ;}else if _cacc [0]=='('{_dba .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");
_bggg ,_aefga :=_eafg .parseString ();return _bggg ,_aefga ;}else if _cacc [0]=='['{_dba .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");_adcf ,_bbdfa :=_eafg .parseArray ();return _adcf ,_bbdfa ;}else if (_cacc [0]=='<')&&(_cacc [1]=='<'){_dba .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");
_gaddc ,_gecf :=_eafg .ParseDict ();return _gaddc ,_gecf ;}else if _cacc [0]=='<'{_dba .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");_edae ,_cfbf :=_eafg .parseHexString ();return _edae ,_cfbf ;}else if _cacc [0]=='%'{_eafg .readComment ();
_eafg .skipSpaces ();}else {_dba .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_cacc ,_ =_eafg ._cega .Peek (15);_gfdd :=string (_cacc );_dba .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_gfdd );
if (len (_gfdd )> 3)&&(_gfdd [:4]=="\u006e\u0075\u006c\u006c"){_cdea ,_edbce :=_eafg .parseNull ();return &_cdea ,_edbce ;}else if (len (_gfdd )> 4)&&(_gfdd [:5]=="\u0066\u0061\u006cs\u0065"){_abgc ,_abbda :=_eafg .parseBool ();return &_abgc ,_abbda ;}else if (len (_gfdd )> 3)&&(_gfdd [:4]=="\u0074\u0072\u0075\u0065"){_eefa ,_gcd :=_eafg .parseBool ();
return &_eefa ,_gcd ;};_gbdbd :=_efeg .FindStringSubmatch (_gfdd );if len (_gbdbd )> 1{_cacc ,_ =_eafg ._cega .ReadBytes ('R');_dba .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_cacc [:]));_bcfa ,_cbdf :=_acage (string (_cacc ));
_bcfa ._dcab =_eafg ;return &_bcfa ,_cbdf ;};_ggda :=_gabb .FindStringSubmatch (_gfdd );if len (_ggda )> 1{_dba .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");_gdce ,_egcae :=_eafg .parseNumber ();return _gdce ,_egcae ;};_ggda =_fdccg .FindStringSubmatch (_gfdd );
if len (_ggda )> 1{_dba .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");_dba .Log .Trace ("\u0025\u0020\u0073",_ggda );_gecc ,_bffaa :=_eafg .parseNumber ();return _gecc ,_bffaa ;
};_dba .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_gfdd );return nil ,_e .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");
};};};

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_bbae :=_db .NewReader ([]byte (txt ));_ggec :=&PdfParser {ObjCache :objectCache {},_eege :_bbae ,_cega :_beb .NewReader (_bbae ),_bcaf :int64 (len (txt )),_egef :map[int64 ]bool {},_dbbg :make (map[*PdfParser ]*PdfParser )};
_ggec ._bbbaa .ObjectMap =make (map[int ]XrefObject );return _ggec ;};

// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_acbdg *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _gf .DecodeBytes (encoded ,_dce .Parameters {},_acbdg .Globals );};

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};func (_efcea *PdfParser )rebuildXrefTable ()error {_dgbb :=XrefTable {};_dgbb .ObjectMap =map[int ]XrefObject {};_dabd :=make ([]int ,0,len (_efcea ._bbbaa .ObjectMap ));for _effff :=range _efcea ._bbbaa .ObjectMap {_dabd =append (_dabd ,_effff );
};_a .Ints (_dabd );for _ ,_ggcaf :=range _dabd {_cfcea :=_efcea ._bbbaa .ObjectMap [_ggcaf ];_becgc ,_ ,_abcd :=_efcea .lookupByNumberWrapper (_ggcaf ,false );if _abcd !=nil {_dba .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_abcd );
_dba .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");
_gcced ,_eeecbd :=_efcea .repairRebuildXrefsTopDown ();if _eeecbd !=nil {_dba .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_eeecbd );
return _eeecbd ;};_efcea ._bbbaa =*_gcced ;_dba .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_fgdcb ,_ebgc ,_abcd :=_cdf (_becgc );if _abcd !=nil {return _abcd ;
};_cfcea .ObjectNumber =int (_fgdcb );_cfcea .Generation =int (_ebgc );_dgbb .ObjectMap [int (_fgdcb )]=_cfcea ;};_efcea ._bbbaa =_dgbb ;_dba .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");
_cc (_efcea ._bbbaa );return nil ;};

// Bytes returns the PdfObjectString content as a []byte array.
func (_gbdcc *PdfObjectString )Bytes ()[]byte {return []byte (_gbdcc ._gffd )};func _ebdd (_ffeee ,_abcgc ,_efagf int )error {if _abcgc < 0||_abcgc > _ffeee {return _e .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");
};if _efagf < _abcgc {return _e .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");};if _efagf > _ffeee {return _e .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");
};return nil ;};

// String returns a string describing `stream`.
func (_abegff *PdfObjectStream )String ()string {return _bb .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_abegff .ObjectNumber ,_abegff .PdfObjectDictionary );};func (_bbab *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){const _dcdcd =20;
_bead ,_ :=_bbab ._cega .Peek (_dcdcd );for _dgec :=0;_dgec < 2;_dgec ++{if _bbab ._cgfb ==0{_bbab ._cgfb =_bbab .GetFileOffset ();};if _aafc .Match (_bead ){_dba .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
_dba .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_bead ));return _bbab .parseXrefStream (nil );};if _ageb .Match (_bead ){_dba .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");
return _bbab .parseXrefTable ();};_eeef :=_bbab .GetFileOffset ();if _bbab ._cgfb ==0{_bbab ._cgfb =_eeef ;};_bbab .SetFileOffset (_eeef -_dcdcd );defer _bbab .SetFileOffset (_eeef );_geac ,_ :=_bbab ._cega .Peek (_dcdcd );_bead =append (_geac ,_bead ...);
};_dba .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");
if _eaad :=_bbab .repairSeekXrefMarker ();_eaad !=nil {_dba .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_eaad );return nil ,_eaad ;};return _bbab .parseXrefTable ();};

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_ggeb *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _afe _db .Buffer ;for _ ,_eecb :=range data {_afe .WriteString (_bb .Sprintf ("\u0025\u002e\u0032X\u0020",_eecb ));};_afe .WriteByte ('>');return _afe .Bytes (),nil ;};

// SetFileOffset sets the file to an offset position and resets buffer.
func (_ceac *PdfParser )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_ceac ._eege .Seek (offset ,_gd .SeekStart );_ceac ._cega =_beb .NewReader (_ceac ._eege );};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_aecc *RawEncoder )MakeDecodeParams ()PdfObject {return nil };func (_dda *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_cge :=MakeDict ();_cge .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));
_cge .Set ("\u0056",MakeInteger (int64 (_dda ._bgc .V )));_cge .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_dda ._bgc .Length )));return _cge ;};func (_gagcb *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_gagcb ._bbbaa .ObjectMap =make (map[int ]XrefObject );
_gagcb ._cbbf =make (objectStreams );_gfbec ,_bedgf :=_gagcb ._eege .Seek (0,_gd .SeekEnd );if _bedgf !=nil {return nil ,_bedgf ;};_dba .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_gfbec );_gagcb ._bcaf =_gfbec ;_bedgf =_gagcb .seekToEOFMarker (_gfbec );
if _bedgf !=nil {_dba .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_bedgf );return nil ,_bedgf ;};_baefc ,_bedgf :=_gagcb ._eege .Seek (0,_gd .SeekCurrent );
if _bedgf !=nil {return nil ,_bedgf ;};var _aaga int64 =64;_dddaf :=_baefc -_aaga ;if _dddaf < 0{_dddaf =0;};_ ,_bedgf =_gagcb ._eege .Seek (_dddaf ,_gd .SeekStart );if _bedgf !=nil {return nil ,_bedgf ;};_accbg :=make ([]byte ,_aaga );_ ,_bedgf =_gagcb ._eege .Read (_accbg );
if _bedgf !=nil {_dba .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_bedgf );
return nil ,_bedgf ;};_ggce :=_abda .FindStringSubmatch (string (_accbg ));if len (_ggce )< 2{_dba .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");
return nil ,_e .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};if len (_ggce )> 2{_dba .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_accbg );
return nil ,_e .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");};_cffd ,_ :=_ecd .ParseInt (_ggce [1],10,64);_dba .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_cffd );
if _cffd > _gfbec {_dba .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");_dba .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");
_cffd ,_bedgf =_gagcb .repairLocateXref ();if _bedgf !=nil {_dba .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");
return nil ,_bedgf ;};};_gagcb ._eege .Seek (_cffd ,_gd .SeekStart );_gagcb ._cega =_beb .NewReader (_gagcb ._eege );_bgeeb ,_bedgf :=_gagcb .parseXref ();if _bedgf !=nil {return nil ,_bedgf ;};_bedgc :=_bgeeb .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");
if _bedgc !=nil {_dfbfc ,_bffc :=_bedgc .(*PdfObjectInteger );if !_bffc {return nil ,_e .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_bedgf =_gagcb .parseXrefStream (_dfbfc );if _bedgf !=nil {return nil ,_bedgf ;
};};var _efce []int64 ;_bafb :=func (_ffbf int64 ,_bgfa []int64 )bool {for _ ,_ddfa :=range _bgfa {if _ddfa ==_ffbf {return true ;};};return false ;};_bedgc =_bgeeb .Get ("\u0050\u0072\u0065\u0076");for _bedgc !=nil {_ebcbg ,_deea :=_bedgc .(*PdfObjectInteger );
if !_deea {_dba .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_bedgc );
return _bgeeb ,nil ;};_efbb :=*_ebcbg ;_dba .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_efbb );_gagcb ._eege .Seek (int64 (_efbb ),_gd .SeekStart );
_gagcb ._cega =_beb .NewReader (_gagcb ._eege );_bfgd ,_cfcd :=_gagcb .parseXref ();if _cfcd !=nil {_dba .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");
_dba .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_gagcb ._adbb =append (_gagcb ._adbb ,int64 (_efbb ));
_bedgc =_bfgd .Get ("\u0050\u0072\u0065\u0076");if _bedgc !=nil {_cfegd :=*(_bedgc .(*PdfObjectInteger ));if _bafb (int64 (_cfegd ),_efce ){_dba .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");
break ;};_efce =append (_efce ,int64 (_cfegd ));};};return _bgeeb ,nil ;};func (_ffd *PdfCrypt )isDecrypted (_dgf PdfObject )bool {_ ,_dacb :=_ffd ._gbf [_dgf ];if _dacb {_dba .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");
return true ;};switch _fbc :=_dgf .(type ){case *PdfObjectStream :if _ffd ._fbbg .R !=5{if _bcbd ,_fdc :=_fbc .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_fdc &&*_bcbd =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_dacb =_ffd ._dfga [int (_fbc .ObjectNumber )];
_dacb {return true ;};switch _ffge :=_fbc .PdfObject .(type ){case *PdfObjectDictionary :_fccg :=true ;for _ ,_fbe :=range _ceag {if _ffge .Get (_fbe )==nil {_fccg =false ;break ;};};if _fccg {return true ;};};};_dba .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");
return false ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_bebf *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_cdaee *PdfObjectFloat ,_fbfd bool ){_cdaee ,_fbfd =TraceToDirectObject (obj ).(*PdfObjectFloat );return _cdaee ,_fbfd ;};

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_ebgaa *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_dba .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_ebgaa .GetFilterName ());
return data ,ErrNoJPXDecode ;};func (_cffc *PdfParser )parseString ()(*PdfObjectString ,error ){_cffc ._cega .ReadByte ();var _eeac _db .Buffer ;_egcf :=1;for {_dgfaa ,_acagc :=_cffc ._cega .Peek (1);if _acagc !=nil {return MakeString (_eeac .String ()),_acagc ;
};if _dgfaa [0]=='\\'{_cffc ._cega .ReadByte ();_ccga ,_fdecd :=_cffc ._cega .ReadByte ();if _fdecd !=nil {return MakeString (_eeac .String ()),_fdecd ;};if IsOctalDigit (_ccga ){_feed ,_gaca :=_cffc ._cega .Peek (2);if _gaca !=nil {return MakeString (_eeac .String ()),_gaca ;
};var _decgg []byte ;_decgg =append (_decgg ,_ccga );for _ ,_acge :=range _feed {if IsOctalDigit (_acge ){_decgg =append (_decgg ,_acge );}else {break ;};};_cffc ._cega .Discard (len (_decgg )-1);_dba .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_decgg );
_aeba ,_gaca :=_ecd .ParseUint (string (_decgg ),8,32);if _gaca !=nil {return MakeString (_eeac .String ()),_gaca ;};_eeac .WriteByte (byte (_aeba ));continue ;};switch _ccga {case 'n':_eeac .WriteRune ('\n');case 'r':_eeac .WriteRune ('\r');case 't':_eeac .WriteRune ('\t');
case 'b':_eeac .WriteRune ('\b');case 'f':_eeac .WriteRune ('\f');case '(':_eeac .WriteRune ('(');case ')':_eeac .WriteRune (')');case '\\':_eeac .WriteRune ('\\');};continue ;}else if _dgfaa [0]=='('{_egcf ++;}else if _dgfaa [0]==')'{_egcf --;if _egcf ==0{_cffc ._cega .ReadByte ();
break ;};};_defcf ,_ :=_cffc ._cega .ReadByte ();_eeac .WriteByte (_defcf );};return MakeString (_eeac .String ()),nil ;};

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _eggd :=obj .(type ){case *PdfObjectFloat :return float64 (*_eggd ),nil ;case *PdfObjectInteger :return float64 (*_eggd ),nil ;case *PdfObjectReference :_fecaa :=TraceToDirectObject (obj );
return GetNumberAsFloat (_fecaa );case *PdfIndirectObject :return GetNumberAsFloat (_eggd .PdfObject );};return 0,ErrNotANumber ;};const (_bdf =0;_gfdf =1;_dfd =2;_cgbb =3;_decf =4;);

// WriteString outputs the object as it is to be written to file.
func (_aaec *PdfObjectDictionary )WriteString ()string {var _ggfa _ga .Builder ;_ggfa .WriteString ("\u003c\u003c");for _ ,_gffad :=range _aaec ._ebce {_agcc :=_aaec ._bbfc [_gffad ];_ggfa .WriteString (_gffad .WriteString ());_ggfa .WriteString ("\u0020");
_ggfa .WriteString (_agcc .WriteString ());};_ggfa .WriteString ("\u003e\u003e");return _ggfa .String ();};func (_eec *PdfCrypt )makeKey (_dga string ,_dfb ,_ecfe uint32 ,_dbd []byte )([]byte ,error ){_ceee ,_bedg :=_eec ._da [_dga ];if !_bedg {return nil ,_bb .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_dga );
};return _ceee .MakeKey (_dfb ,_ecfe ,_dbd );};

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_cbgc *PdfParser )Decrypt (password []byte )(bool ,error ){if _cbgc ._bfa ==nil {return false ,_e .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_acda ,_eace :=_cbgc ._bfa .authenticate (password );
if _eace !=nil {return false ,_eace ;};if !_acda {_acda ,_eace =_cbgc ._bfa .authenticate ([]byte (""));};return _acda ,_eace ;};type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;StrF string ;EFF string ;CF map[string ]_ge .FilterDict ;
};

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_cfff :=&ASCIIHexEncoder {};return _cfff };

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_efgd *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };

// Append appends PdfObject(s) to the array.
func (_bdab *PdfObjectArray )Append (objects ...PdfObject ){if _bdab ==nil {_dba .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");
return ;};_bdab ._ebb =append (_bdab ._ebb ,objects ...);};

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_abfe Version ;_eege _gd .ReadSeeker ;_cega *_beb .Reader ;_bcaf int64 ;_bbbaa XrefTable ;_cgfb int64 ;_bebag *xrefType ;_cbbf objectStreams ;_ddgd *PdfObjectDictionary ;_bfa *PdfCrypt ;_gfcc *PdfIndirectObject ;_bfb bool ;ObjCache objectCache ;
_dged map[int ]bool ;_egef map[int64 ]bool ;_gbgef ParserMetadata ;_cdbda bool ;_adbb []int64 ;_aaggc int ;_feag bool ;_gbeb int64 ;_dbbg map[*PdfParser ]*PdfParser ;_ddaa []*PdfParser ;};

// UpdateParams updates the parameter values of the encoder.
func (_gedd *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};var _fegb =_e .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");

// WriteString outputs the object as it is to be written to file.
func (_cggd *PdfObjectBool )WriteString ()string {if *_cggd {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};func (_daf *PdfCrypt )loadCryptFilters (_eff *PdfObjectDictionary )error {_daf ._da =cryptFilters {};_bda :=_eff .Get ("\u0043\u0046");
_bda =TraceToDirectObject (_bda );if _bcb ,_baf :=_bda .(*PdfObjectReference );_baf {_gbb ,_ffgg :=_daf ._afd .LookupByReference (*_bcb );if _ffgg !=nil {_dba .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");
return _ffgg ;};_bda =TraceToDirectObject (_gbb );};_fge ,_fefc :=_bda .(*PdfObjectDictionary );if !_fefc {_dba .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_bda );return _e .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");
};for _ ,_fegc :=range _fge .Keys (){_faf :=_fge .Get (_fegc );if _aed ,_bca :=_faf .(*PdfObjectReference );_bca {_ggbe ,_edb :=_daf ._afd .LookupByReference (*_aed );if _edb !=nil {_dba .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");
return _edb ;};_faf =TraceToDirectObject (_ggbe );};_egc ,_ceb :=_faf .(*PdfObjectDictionary );if !_ceb {return _bb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_fegc ,_faf );
};if _fegc =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_dba .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");
continue ;};var _gcc _ge .FilterDict ;if _dac :=_gad (&_gcc ,_egc );_dac !=nil {return _dac ;};_acg ,_eaed :=_ge .NewFilter (_gcc );if _eaed !=nil {return _eaed ;};_daf ._da [string (_fegc )]=_acg ;};_daf ._da ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_ge .NewIdentity ();
_daf ._gcag ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _bge ,_bbed :=_eff .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_bbed {if _ ,_dbf :=_daf ._da [string (*_bge )];!_dbf {return _bb .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_bge );
};_daf ._gcag =string (*_bge );};_daf ._fdgg ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _dea ,_gdbb :=_eff .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_gdbb {if _ ,_egad :=_daf ._da [string (*_dea )];!_egad {return _bb .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_dea );
};_daf ._fdgg =string (*_dea );};return nil ;};

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_gabg string ,_gbfb bool ){_bafbf ,_gbfb :=TraceToDirectObject (obj ).(*PdfObjectString );if _gbfb {return _bafbf .Str (),true ;};return ;};

// String returns a string representation of `name`.
func (_gfcfb *PdfObjectName )String ()string {return string (*_gfcfb )};func (_eedd *JBIG2Image )toBitmap ()(_ffgeb *_dc .Bitmap ,_gbdb error ){const _gfdgb ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";
if _eedd .Data ==nil {return nil ,_fc .Error (_gfdgb ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _eedd .Width ==0||_eedd .Height ==0{return nil ,_fc .Error (_gfdgb ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");
};if _eedd .HasPadding {_ffgeb ,_gbdb =_dc .NewWithData (_eedd .Width ,_eedd .Height ,_eedd .Data );}else {_ffgeb ,_gbdb =_dc .NewWithUnpaddedData (_eedd .Width ,_eedd .Height ,_eedd .Data );};if _gbdb !=nil {return nil ,_fc .Wrap (_gbdb ,_gfdgb ,"");};
return _ffgeb ,nil ;};

// IsHexadecimal checks if the PdfObjectString contains Hexadecimal data.
func (_acadc *PdfObjectString )IsHexadecimal ()bool {return _acadc ._fecf };

// GetPreviousRevisionParser returns PdfParser for the previous version of the Pdf document.
func (_bcba *PdfParser )GetPreviousRevisionParser ()(*PdfParser ,error ){if _bcba ._aaggc ==0{return nil ,_e .New ("\u0074\u0068\u0069\u0073 i\u0073\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u0072\u0065\u0076\u0069\u0073\u0069o\u006e");};if _dgfbb ,_bgcae :=_bcba ._dbbg [_bcba ];
_bgcae {return _dgfbb ,nil ;};_baac ,_dbae :=_bcba .GetPreviousRevisionReadSeeker ();if _dbae !=nil {return nil ,_dbae ;};_geea ,_dbae :=NewParser (_baac );_geea ._dbbg =_bcba ._dbbg ;if _dbae !=nil {return nil ,_dbae ;};_bcba ._dbbg [_bcba ]=_geea ;return _geea ,nil ;
};

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_faega :=&PdfIndirectObject {};_faega .PdfObject =obj ;return _faega ;};

// GetFilterName returns the name of the encoding filter.
func (_bfdb *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };

// UpdateParams updates the parameter values of the encoder.
func (_agdcb *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_ceae ,_adg :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _adg ==nil {_agdcb .Predictor =int (_ceae );};_cagd ,_adg :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));
if _adg ==nil {_agdcb .BitsPerComponent =int (_cagd );};_baef ,_adg :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _adg ==nil {_agdcb .Columns =int (_baef );};_efcb ,_adg :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));
if _adg ==nil {_agdcb .Colors =int (_efcb );};};

// DecodeBytes decodes the CCITTFax encoded image data.
func (_fdgfe *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_eccb ,_dgce :=_gaf .NewDecoder (encoded ,_gaf .DecodeOptions {Columns :_fdgfe .Columns ,Rows :_fdgfe .Rows ,K :_fdgfe .K ,EncodedByteAligned :_fdgfe .EncodedByteAlign ,BlackIsOne :_fdgfe .BlackIs1 ,EndOfBlock :_fdgfe .EndOfBlock ,EndOfLine :_fdgfe .EndOfLine ,DamagedRowsBeforeError :_fdgfe .DamagedRowsBeforeError });
if _dgce !=nil {return nil ,_dgce ;};_adbd ,_dgce :=_de .ReadAll (_eccb );if _dgce !=nil {return nil ,_dgce ;};return _adbd ,nil ;};

// String returns a string describing `d`.
func (_feabd *PdfObjectDictionary )String ()string {var _bdeb _ga .Builder ;_bdeb .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_fbacg :=range _feabd ._ebce {_debd :=_feabd ._bbfc [_fbacg ];_bdeb .WriteString ("\u0022"+_fbacg .String ()+"\u0022\u003a\u0020");
_bdeb .WriteString (_debd .String ());_bdeb .WriteString ("\u002c\u0020");};_bdeb .WriteString ("\u0029");return _bdeb .String ();};var _dfed =_b .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");
var _fgac =_b .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_egadg :=&ASCII85Encoder {};return _egadg };

// ParserMetadata gets the pdf parser metadata.
func (_bgcc *PdfParser )ParserMetadata ()(ParserMetadata ,error ){if !_bgcc ._cdbda {return ParserMetadata {},_bb .Errorf ("\u0070\u0061\u0072\u0073\u0065r\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u006d\u0061\u0072\u006be\u0064\u0020\u0066\u006f\u0072\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0064\u0065\u0074\u0061\u0069\u006c\u0065\u0064\u0020\u006d\u0065\u0074\u0061\u0064\u0061\u0074a");
};return _bgcc ._gbgef ,nil ;};func (_dced *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _agcgf *PdfObjectDictionary ;_ecdeb ,_faabd :=_dced .readTextLine ();if _faabd !=nil {return nil ,_faabd ;};if _dced ._cdbda &&_ga .Count (_ga .TrimPrefix (_ecdeb ,"\u0078\u0072\u0065\u0066"),"\u0020")> 0{_dced ._gbgef ._edd =true ;
};_dba .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_ecdeb );_ggaa :=-1;_bef :=0;_gdccf :=false ;_addf :="";for {_dced .skipSpaces ();_ ,_fbggc :=_dced ._cega .Peek (1);if _fbggc !=nil {return nil ,_fbggc ;
};_ecdeb ,_fbggc =_dced .readTextLine ();if _fbggc !=nil {return nil ,_fbggc ;};_fffe :=_dfed .FindStringSubmatch (_ecdeb );if len (_fffe )==0{_cdfbg :=len (_addf )> 0;_addf +=_ecdeb +"\u000a";if _cdfbg {_fffe =_dfed .FindStringSubmatch (_addf );};};if len (_fffe )==3{if _dced ._cdbda &&!_dced ._gbgef ._fda {var (_adee bool ;
_agaa int ;);for _ ,_bgbd :=range _ecdeb {if _d .IsDigit (_bgbd ){if _adee {break ;};continue ;};if !_adee {_adee =true ;};_agaa ++;};if _agaa > 1{_dced ._gbgef ._fda =true ;};};_afde ,_ :=_ecd .Atoi (_fffe [1]);_gaed ,_ :=_ecd .Atoi (_fffe [2]);_ggaa =_afde ;
_bef =_gaed ;_gdccf =true ;_addf ="";_dba .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_ggaa ,_bef );
continue ;};_caag :=_gbbg .FindStringSubmatch (_ecdeb );if len (_caag )==4{if !_gdccf {_dba .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_e .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");
};_degd ,_ :=_ecd .ParseInt (_caag [1],10,64);_dcdc ,_ :=_ecd .Atoi (_caag [2]);_afad :=_caag [3];_addf ="";if _ga .ToLower (_afad )=="\u006e"&&_degd > 1{_eafb ,_gdcfg :=_dced ._bbbaa .ObjectMap [_ggaa ];if !_gdcfg ||_dcdc > _eafb .Generation {_gba :=XrefObject {ObjectNumber :_ggaa ,XType :XrefTypeTableEntry ,Offset :_degd ,Generation :_dcdc };
_dced ._bbbaa .ObjectMap [_ggaa ]=_gba ;};};_ggaa ++;continue ;};if (len (_ecdeb )> 6)&&(_ecdeb [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_dba .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_ecdeb );
if len (_ecdeb )> 9{_fega :=_dced .GetFileOffset ();_dced .SetFileOffset (_fega -int64 (len (_ecdeb ))+7);};_dced .skipSpaces ();_dced .skipComments ();_dba .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");
_dba .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_ecdeb );_agcgf ,_fbggc =_dced .ParseDict ();_dba .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");
if _fbggc !=nil {_dba .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_fbggc );return nil ,_fbggc ;};break ;};if _ecdeb =="\u0025\u0025\u0045O\u0046"{_dba .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");
return nil ,_e .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_dba .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_ecdeb );
};_dba .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _dced ._bebag ==nil {_fdef :=XrefTypeTableEntry ;_dced ._bebag =&_fdef ;};return _agcgf ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_gbcg *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_bbfa bool ,_affc bool ){_dbadg ,_affc :=TraceToDirectObject (obj ).(*PdfObjectBool );if _affc {return bool (*_dbadg ),true ;};return false ,false ;};

// HasInvalidSeparationAfterXRef implements core.ParserMetadata interface.
func (_acgf ParserMetadata )HasInvalidSeparationAfterXRef ()bool {return _acgf ._edd };

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};const _dgbe =6;

// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_ggcd :=MakeArray ();for _ ,_gdffg :=range vals {_ggcd .Append (MakeInteger (_gdffg ));};return _ggcd ;};var _ccdf =_b .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");


// SetImage sets the image base for given flate encoder.
func (_fdfb *FlateEncoder )SetImage (img *_gdf .ImageBase ){_fdfb ._fcfc =img };

// UpdateParams updates the parameter values of the encoder.
func (_fcfd *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};func _afgg (_gcbcf *PdfObjectStream ,_gadf *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_gaeef :=NewCCITTFaxEncoder ();_efff :=_gcbcf .PdfObjectDictionary ;if _efff ==nil {return _gaeef ,nil ;
};if _gadf ==nil {_fbfb :=TraceToDirectObject (_efff .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _fbfb !=nil {switch _dbeg :=_fbfb .(type ){case *PdfObjectDictionary :_gadf =_dbeg ;case *PdfObjectArray :if _dbeg .Len ()==1{if _dcba ,_geebf :=GetDict (_dbeg .Get (0));
_geebf {_gadf =_dcba ;};};default:_dba .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_fbfb );return nil ,_e .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");
};};if _gadf ==nil {_dba .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_fbfb );return nil ,_e .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");
};};if _fga ,_cceb :=GetNumberAsInt64 (_gadf .Get ("\u004b"));_cceb ==nil {_gaeef .K =int (_fga );};if _eecd ,_afggb :=GetNumberAsInt64 (_gadf .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_afggb ==nil {_gaeef .Columns =int (_eecd );}else {_gaeef .Columns =1728;
};if _cbe ,_gdag :=GetNumberAsInt64 (_gadf .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_gdag ==nil {_gaeef .BlackIs1 =_cbe > 0;}else {if _ebgge ,_cefag :=GetBoolVal (_gadf .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_cefag {_gaeef .BlackIs1 =_ebgge ;
}else {if _ccdb ,_bddfg :=GetArray (_gadf .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_bddfg {_bade ,_adge :=_ccdb .ToIntegerArray ();if _adge ==nil {_gaeef .BlackIs1 =_bade [0]==1&&_bade [1]==0;};};};};if _gdcb ,_egab :=GetNumberAsInt64 (_gadf .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));
_egab ==nil {_gaeef .EncodedByteAlign =_gdcb > 0;}else {if _aceg ,_aaee :=GetBoolVal (_gadf .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_aaee {_gaeef .EncodedByteAlign =_aceg ;};};if _cdbd ,_dbfbd :=GetNumberAsInt64 (_gadf .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));
_dbfbd ==nil {_gaeef .EndOfLine =_cdbd > 0;}else {if _gbgd ,_dbbe :=GetBoolVal (_gadf .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_dbbe {_gaeef .EndOfLine =_gbgd ;};};if _beag ,_gadfb :=GetNumberAsInt64 (_gadf .Get ("\u0052\u006f\u0077\u0073"));
_gadfb ==nil {_gaeef .Rows =int (_beag );};_gaeef .EndOfBlock =true ;if _bbfd ,_fddg :=GetNumberAsInt64 (_gadf .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_fddg ==nil {_gaeef .EndOfBlock =_bbfd > 0;}else {if _ecfg ,_eefb :=GetBoolVal (_gadf .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));
_eefb {_gaeef .EndOfBlock =_ecfg ;};};if _gcfd ,_fgbd :=GetNumberAsInt64 (_gadf .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_fgbd !=nil {_gaeef .DamagedRowsBeforeError =int (_gcfd );
};_dba .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_gadf .String ());return _gaeef ,nil ;};

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_cb *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_fgg ,_ ,_dgb :=_cb .lookupByNumberWrapper (objNumber ,true );return _fgg ,_dgb ;};

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_gbde *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_gbde ._addd .Lock ();defer _gbde ._addd .Unlock ();_cfbe ,_gdbac :=_gbde ._bbfc [key ];if !_gdbac {return nil ;};return _cfbe ;};

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_gbbf *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _gbbf .DecodeBytes (streamObj .Stream );};

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_dae :=&FlateEncoder {};_dae .Predictor =1;_dae .BitsPerComponent =8;_dae .Colors =1;_dae .Columns =1;return _dae ;};

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_adga *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };

// GetPreviousRevisionReadSeeker returns ReadSeeker for the previous version of the Pdf document.
func (_gdcgb *PdfParser )GetPreviousRevisionReadSeeker ()(_gd .ReadSeeker ,error ){if _ebdf :=_gdcgb .seekToEOFMarker (_gdcgb ._bcaf -_dgbe );_ebdf !=nil {return nil ,_ebdf ;};_dggef ,_baaf :=_gdcgb ._eege .Seek (0,_gd .SeekCurrent );if _baaf !=nil {return nil ,_baaf ;
};_dggef +=_dgbe ;return _afbfg (_gdcgb ._eege ,_dggef );};

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_aeff *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_dba .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_eeag :=MakeDict ();_eeag ._acgae =_aeff ;_fgd ,_ :=_aeff ._cega .ReadByte ();
if _fgd !='<'{return nil ,_e .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_fgd ,_ =_aeff ._cega .ReadByte ();if _fgd !='<'{return nil ,_e .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};for {_aeff .skipSpaces ();
_aeff .skipComments ();_feac ,_ffef :=_aeff ._cega .Peek (2);if _ffef !=nil {return nil ,_ffef ;};_dba .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_feac ),string (_feac ));if (_feac [0]=='>')&&(_feac [1]=='>'){_dba .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");
_aeff ._cega .ReadByte ();_aeff ._cega .ReadByte ();break ;};_dba .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");_babc ,_ffef :=_aeff .parseName ();_dba .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_babc );
if _ffef !=nil {_dba .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_ffef );return nil ,_ffef ;};if len (_babc )> 4&&_babc [len (_babc )-4:]=="\u006e\u0075\u006c\u006c"{_gcagb :=_babc [0:len (_babc )-4];
_dba .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_babc );_dba .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_gcagb );
_aeff .skipSpaces ();_ecga ,_ :=_aeff ._cega .Peek (1);if _ecga [0]=='/'{_eeag .Set (_gcagb ,MakeNull ());continue ;};};_aeff .skipSpaces ();_degea ,_ffef :=_aeff .parseObject ();if _ffef !=nil {return nil ,_ffef ;};_eeag .Set (_babc ,_degea );if _dba .Log .IsLogLevel (_dba .LogLevelTrace ){_dba .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_babc ,_degea .String ());
};};_dba .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _eeag ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gaaf *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_gaaf ._gfbdc )==0{return nil ;};if len (_gaaf ._gfbdc )==1{return _gaaf ._gfbdc [0].MakeDecodeParams ();};_dece :=MakeArray ();_gabc :=true ;for _ ,_fbac :=range _gaaf ._gfbdc {_adfd :=_fbac .MakeDecodeParams ();
if _adfd ==nil {_dece .Append (MakeNull ());}else {_gabc =false ;_dece .Append (_adfd );};};if _gabc {return nil ;};return _dece ;};

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_cebae :=PdfObjectInteger (val );return &_cebae };

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_ecge :_df .InitEncodeDocument (false )}};

// HasOddLengthHexStrings checks if the document has odd length hexadecimal strings.
func (_cefg ParserMetadata )HasOddLengthHexStrings ()bool {return _cefg ._eaeg };

// WriteString outputs the object as it is to be written to file.
func (_ebed *PdfObjectArray )WriteString ()string {var _fcee _ga .Builder ;_fcee .WriteString ("\u005b");for _bgfg ,_fdgb :=range _ebed .Elements (){_fcee .WriteString (_fdgb .WriteString ());if _bgfg < (_ebed .Len ()-1){_fcee .WriteString ("\u0020");};
};_fcee .WriteString ("\u005d");return _fcee .String ();};

// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_cbdd *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_bdff :=MakeDict ();_bdff .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cbdd .GetFilterName ()));return _bdff ;};

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_fbde :=&DCTEncoder {};_fbde .ColorComponents =3;_fbde .BitsPerComponent =8;_fbde .Quality =DefaultJPEGQuality ;_fbde .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0};return _fbde ;};func _agfd (_eacde uint ,_ddde ,_bfc float64 )float64 {return (_ddde +(float64 (_eacde )*(_bfc -_ddde )/255))*255;
};

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_fgcb *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _feeb []float64 ;for _ ,_gecaa :=range _fgcb .Elements (){_aeed ,_fbeaf :=GetNumberAsFloat (TraceToDirectObject (_gecaa ));if _fbeaf !=nil {return nil ,_bb .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");
};_feeb =append (_feeb ,_aeed );};return _feeb ,nil ;};

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_acga *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};func _gccee (_cbacg PdfObject ,_fbbga int )PdfObject {if _fbbga > _abfa {_dba .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_abfa );
return MakeNull ();};switch _afegg :=_cbacg .(type ){case *PdfIndirectObject :_cbacg =_gccee ((*_afegg ).PdfObject ,_fbbga +1);case *PdfObjectArray :for _efegee ,_dfff :=range (*_afegg )._ebb {(*_afegg )._ebb [_efegee ]=_gccee (_dfff ,_fbbga +1);};case *PdfObjectDictionary :for _aebaa ,_fcde :=range (*_afegg )._bbfc {(*_afegg )._bbfc [_aebaa ]=_gccee (_fcde ,_fbbga +1);
};_a .Slice ((*_afegg )._ebce ,func (_bacf ,_gacg int )bool {return (*_afegg )._ebce [_bacf ]< (*_afegg )._ebce [_gacg ]});};return _cbacg ;};func _bdge (_egcaf *PdfObjectStream ,_fafc *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;
};

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_aac *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _aac .isDecrypted (obj ){return nil ;};switch _fbd :=obj .(type ){case *PdfIndirectObject :_aac ._gbf [_fbd ]=true ;_dba .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_fbd .ObjectNumber ,_fbd .GenerationNumber );
_dcde :=_fbd .ObjectNumber ;_eba :=_fbd .GenerationNumber ;_gfdg :=_aac .Decrypt (_fbd .PdfObject ,_dcde ,_eba );if _gfdg !=nil {return _gfdg ;};return nil ;case *PdfObjectStream :_aac ._gbf [_fbd ]=true ;_cbgf :=_fbd .PdfObjectDictionary ;if _aac ._fbbg .R !=5{if _ebef ,_abaf :=_cbgf .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_abaf &&*_ebef =="\u0058\u0052\u0065\u0066"{return nil ;};};_afc :=_fbd .ObjectNumber ;_bdcd :=_fbd .GenerationNumber ;_dba .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_afc ,_bdcd );
_bae :=_ada ;if _aac ._bgc .V >=4{_bae =_aac ._fdgg ;_dba .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_aac ._fdgg );if _fac ,_bce :=_cbgf .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );
_bce {if _fec ,_edee :=GetName (_fac .Get (0));_edee {if *_fec =="\u0043\u0072\u0079p\u0074"{_bae ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _eag ,_fbea :=_cbgf .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );
_fbea {if _gbfd ,_gce :=_eag .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_gce {if _ ,_ggdc :=_aac ._da [string (*_gbfd )];_ggdc {_dba .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_gbfd );
_bae =string (*_gbfd );};};};};};};_dba .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_bae );if _bae =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_adc :=_aac .Decrypt (_cbgf ,_afc ,_bdcd );
if _adc !=nil {return _adc ;};_gfed ,_adc :=_aac .makeKey (_bae ,uint32 (_afc ),uint32 (_bdcd ),_aac ._ead );if _adc !=nil {return _adc ;};_fbd .Stream ,_adc =_aac .decryptBytes (_fbd .Stream ,_bae ,_gfed );if _adc !=nil {return _adc ;};_cbgf .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_fbd .Stream ))));
return nil ;case *PdfObjectString :_dba .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_egg :=_ada ;if _aac ._bgc .V >=4{_dba .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_aac ._gcag );
if _aac ._gcag =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_egg =_aac ._gcag ;};_cff ,_bgcg :=_aac .makeKey (_egg ,uint32 (parentObjNum ),uint32 (parentGenNum ),_aac ._ead );if _bgcg !=nil {return _bgcg ;};_ebag :=_fbd .Str ();_agd :=make ([]byte ,len (_ebag ));
for _gffb :=0;_gffb < len (_ebag );_gffb ++{_agd [_gffb ]=_ebag [_gffb ];};if len (_agd )> 0{_dba .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_agd ,_agd );
_agd ,_bgcg =_aac .decryptBytes (_agd ,_egg ,_cff );if _bgcg !=nil {return _bgcg ;};};_fbd ._gffd =string (_agd );return nil ;case *PdfObjectArray :for _ ,_eee :=range _fbd .Elements (){_cddb :=_aac .Decrypt (_eee ,parentObjNum ,parentGenNum );if _cddb !=nil {return _cddb ;
};};return nil ;case *PdfObjectDictionary :_abg :=false ;if _ecff :=_fbd .Get ("\u0054\u0079\u0070\u0065");_ecff !=nil {_dee ,_cef :=_ecff .(*PdfObjectName );if _cef &&*_dee =="\u0053\u0069\u0067"{_abg =true ;};};for _ ,_cec :=range _fbd .Keys (){_abeg :=_fbd .Get (_cec );
if _abg &&string (_cec )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_cec )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_cec )!="\u0050\u0072\u0065\u0076"&&string (_cec )!="\u004c\u0061\u0073\u0074"{_ecc :=_aac .Decrypt (_abeg ,parentObjNum ,parentGenNum );
if _ecc !=nil {return _ecc ;};};};return nil ;};return nil ;};

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_cdfc *PdfObjectName ,_feeea bool ){_cdfc ,_feeea =TraceToDirectObject (obj ).(*PdfObjectName );return _cdfc ,_feeea ;};

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_bgfgb *PdfObjectStreams ,_fgfc bool ){_bgfgb ,_fgfc =obj .(*PdfObjectStreams );return _bgfgb ,_fgfc ;};

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_efege :=MakeArray ();for _ ,_fgag :=range vals {_efege .Append (MakeInteger (int64 (_fgag )));};return _efege ;};func (_gcgf *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_gd .SeekStart {offset +=_gcgf ._afef ;
};_dbda ,_ceda :=_gcgf ._fcfb .Seek (offset ,whence );if _ceda !=nil {return _dbda ,_ceda ;};if whence ==_gd .SeekCurrent {_dbda -=_gcgf ._afef ;};if _dbda < 0{return 0,_e .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");
};return _dbda ,nil ;};

// HasEOLAfterHeader gets information if there is a EOL after the version header.
func (_faba ParserMetadata )HasEOLAfterHeader ()bool {return _faba ._bcgg };func (_cebd *PdfParser )parseDetailedHeader ()(_eeca error ){_cebd ._eege .Seek (0,_gd .SeekStart );_cebd ._cega =_beb .NewReader (_cebd ._eege );_fbbf :=20;_ceg :=make ([]byte ,_fbbf );
var (_efgb bool ;_cfag int ;);for {_add ,_effe :=_cebd ._cega .ReadByte ();if _effe !=nil {if _effe ==_gd .EOF {break ;}else {return _effe ;};};if IsDecimalDigit (_add )&&_ceg [_fbbf -1]=='.'&&IsDecimalDigit (_ceg [_fbbf -2])&&_ceg [_fbbf -3]=='-'&&_ceg [_fbbf -4]=='F'&&_ceg [_fbbf -5]=='D'&&_ceg [_fbbf -6]=='P'&&_ceg [_fbbf -7]=='%'{_cebd ._abfe =Version {Major :int (_ceg [_fbbf -2]-'0'),Minor :int (_add -'0')};
_cebd ._gbgef ._feb =_cfag -7;_efgb =true ;break ;};_cfag ++;_ceg =append (_ceg [1:_fbbf ],_add );};if !_efgb {return _bb .Errorf ("n\u006f \u0066\u0069\u006c\u0065\u0020\u0068\u0065\u0061d\u0065\u0072\u0020\u0066ou\u006e\u0064");};_bdcg ,_eeca :=_cebd ._cega .ReadByte ();
if _eeca ==_gd .EOF {return _bb .Errorf ("\u006eo\u0074\u0020\u0061\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0050d\u0066\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074");};if _eeca !=nil {return _eeca ;};_cebd ._gbgef ._bcgg =_bdcg =='\n';_bdcg ,_eeca =_cebd ._cega .ReadByte ();
if _eeca !=nil {return _bb .Errorf ("\u006e\u006f\u0074\u0020a\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0064\u0066 \u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u003a \u0025\u0077",_eeca );};if _bdcg !='%'{return nil ;};_dgd :=make ([]byte ,4);_ ,_eeca =_cebd ._cega .Read (_dgd );
if _eeca !=nil {return _bb .Errorf ("\u006e\u006f\u0074\u0020a\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0064\u0066 \u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u003a \u0025\u0077",_eeca );};_cebd ._gbgef ._ded =[4]byte {_dgd [0],_dgd [1],_dgd [2],_dgd [3]};
return nil ;};

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_adfa *PdfParser )GetCrypter ()*PdfCrypt {return _adfa ._bfa };var _aafc =_b .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// WriteString outputs the PDF primitive as written to file as expected by the standard.
// TODO(dennwc): it should return a byte slice, or accept a writer
WriteString ()string ;};

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_egbda *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _bdfa []int ;for _ ,_defge :=range _egbda .Elements (){if _fcga ,_ebbe :=_defge .(*PdfObjectInteger );_ebbe {_bdfa =append (_bdfa ,int (*_fcga ));}else {return nil ,ErrTypeError ;};};return _bdfa ,nil ;
};

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;

// GetFilterName returns the name of the encoding filter.
func (_cccd *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;

// WriteString outputs the object as it is to be written to file.
func (_ggcb *PdfIndirectObject )WriteString ()string {var _defgee _ga .Builder ;_defgee .WriteString (_ecd .FormatInt (_ggcb .ObjectNumber ,10));_defgee .WriteString ("\u0020\u0030\u0020\u0052");return _defgee .String ();};

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_ddcb *JBIG2Encoder )EncodeImage (img _ea .Image )([]byte ,error ){return _ddcb .encodeImage (img )};func (_geeg *PdfCrypt )isEncrypted (_geg PdfObject )bool {_ ,_gece :=_geeg ._acc [_geg ];if _gece {_dba .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");
return true ;};_dba .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_adbe int ,_fbba bool ){_begge ,_fbba :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _fbba &&_begge !=nil {return int (*_begge ),true ;};return 0,false ;};func _cc (_defd XrefTable ){_dba .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");
_dba .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_dfc :=0;for _ ,_eaa :=range _defd .ObjectMap {_dba .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_dfc +1,_eaa .ObjectNumber ,_eaa .Generation ,_eaa .Offset );
_dfc ++;};};

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};func (_deb *PdfParser )parseXrefStream (_egdf *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _egdf !=nil {_dba .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_egdf );
_deb ._eege .Seek (int64 (*_egdf ),_gd .SeekStart );_deb ._cega =_beb .NewReader (_deb ._eege );};_aacb :=_deb .GetFileOffset ();_deba ,_cegd :=_deb .ParseIndirectObject ();if _cegd !=nil {_dba .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");
return nil ,_e .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_dba .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_deba );
_agea ,_becg :=_deba .(*PdfObjectStream );if !_becg {_dba .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");
return nil ,_e .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_gebf :=_agea .PdfObjectDictionary ;
_bebc ,_becg :=_agea .PdfObjectDictionary .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_becg {_dba .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");
return nil ,_e .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_bebc )> 8388607{_dba .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_bebc );
return nil ,_e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_bfcg :=_agea .PdfObjectDictionary .Get ("\u0057");_fedc ,_becg :=_bfcg .(*PdfObjectArray );if !_becg {return nil ,_e .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");
};_efab :=_fedc .Len ();if _efab !=3{_dba .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_efab );
return nil ,_e .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _dbad []int64 ;for _bgee :=0;_bgee < 3;
_bgee ++{_bcebf ,_fdadd :=GetInt (_fedc .Get (_bgee ));if !_fdadd {return nil ,_e .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_dbad =append (_dbad ,int64 (*_bcebf ));};_ffdf ,_cegd :=DecodeStream (_agea );
if _cegd !=nil {_dba .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_cegd );return nil ,_cegd ;};_dage :=int (_dbad [0]);
_bgcbc :=int (_dbad [0]+_dbad [1]);_gfga :=int (_dbad [0]+_dbad [1]+_dbad [2]);_eacfa :=int (_dbad [0]+_dbad [1]+_dbad [2]);if _dage < 0||_bgcbc < 0||_gfga < 0{_dba .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_dage ,_bgcbc ,_gfga );
return nil ,_e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _eacfa ==0{_dba .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");
return _gebf ,nil ;};_feca :=len (_ffdf )/_eacfa ;_affd :=0;_fgec :=_agea .PdfObjectDictionary .Get ("\u0049\u006e\u0064e\u0078");var _ecda []int ;if _fgec !=nil {_dba .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_fgec );_cfeg ,_agca :=_fgec .(*PdfObjectArray );
if !_agca {_dba .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");
return nil ,_e .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _cfeg .Len ()%2!=0{_dba .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");
return nil ,_e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_affd =0;_egbe ,_deac :=_cfeg .ToIntegerArray ();if _deac !=nil {_dba .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_deac );
return nil ,_deac ;};for _fcfg :=0;_fcfg < len (_egbe );_fcfg +=2{_feaed :=_egbe [_fcfg ];_babcc :=_egbe [_fcfg +1];for _egdb :=0;_egdb < _babcc ;_egdb ++{_ecda =append (_ecda ,_feaed +_egdb );};_affd +=_babcc ;};}else {for _aaag :=0;_aaag < int (*_bebc );
_aaag ++{_ecda =append (_ecda ,_aaag );};_affd =int (*_bebc );};if _feca ==_affd +1{_dba .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");
_dbbf :=_affd -1;for _ ,_egce :=range _ecda {if _egce > _dbbf {_dbbf =_egce ;};};_ecda =append (_ecda ,_dbbf +1);_affd ++;};if _feca !=len (_ecda ){_dba .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_feca ,len (_ecda ));
return nil ,_e .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_dba .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_affd );
_dba .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_ecda );_feab :=func (_gccaa []byte )int64 {var _gbcdg int64 ;for _fbfa :=0;_fbfa < len (_gccaa );_fbfa ++{_gbcdg +=int64 (_gccaa [_fbfa ])*(1<<uint (8*(len (_gccaa )-_fbfa -1)));
};return _gbcdg ;};_dba .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_ffdf ));_bcfae :=0;for _bdfb :=0;_bdfb < len (_ffdf );_bdfb +=_eacfa {_bbdae :=_ebdd (len (_ffdf ),_bdfb ,_bdfb +_dage );
if _bbdae !=nil {_dba .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_bbdae );return nil ,_bbdae ;};_dgag :=_ffdf [_bdfb :_bdfb +_dage ];_bbdae =_ebdd (len (_ffdf ),_bdfb +_dage ,_bdfb +_bgcbc );
if _bbdae !=nil {_dba .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_bbdae );return nil ,_bbdae ;};_fdbc :=_ffdf [_bdfb +_dage :_bdfb +_bgcbc ];_bbdae =_ebdd (len (_ffdf ),_bdfb +_bgcbc ,_bdfb +_gfga );
if _bbdae !=nil {_dba .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_bbdae );return nil ,_bbdae ;};_befb :=_ffdf [_bdfb +_bgcbc :_bdfb +_gfga ];_deab :=_feab (_dgag );
_fecb :=_feab (_fdbc );_cgcc :=_feab (_befb );if _dbad [0]==0{_deab =1;};if _bcfae >=len (_ecda ){_dba .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");
break ;};_ageg :=_ecda [_bcfae ];_bcfae ++;_dba .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_ageg ,_dgag );_dba .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_ageg ,_fdbc );_dba .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_ageg ,_befb );
_dba .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_ageg ,_deab ,_fecb ,_cgcc );if _deab ==0{_dba .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");
}else if _deab ==1{_dba .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_fdbc );if _fecb ==_aacb {_dba .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_ageg ,_agea .ObjectNumber );
_ageg =int (_agea .ObjectNumber );};if _cdcff ,_bggd :=_deb ._bbbaa .ObjectMap [_ageg ];!_bggd ||int (_cgcc )> _cdcff .Generation {_aabg :=XrefObject {ObjectNumber :_ageg ,XType :XrefTypeTableEntry ,Offset :_fecb ,Generation :int (_cgcc )};_deb ._bbbaa .ObjectMap [_ageg ]=_aabg ;
};}else if _deab ==2{_dba .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_fedf :=_deb ._bbbaa .ObjectMap [_ageg ];!_fedf {_fbggf :=XrefObject {ObjectNumber :_ageg ,XType :XrefTypeObjectStream ,OsObjNumber :int (_fecb ),OsObjIndex :int (_cgcc )};
_deb ._bbbaa .ObjectMap [_ageg ]=_fbggf ;_dba .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_fbggf );};}else {_dba .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");
continue ;};};if _deb ._bebag ==nil {_adac :=XrefTypeObjectStream ;_deb ._bebag =&_adac ;};return _gebf ,nil ;};func (_dadd *offsetReader )Read (p []byte )(_ceegg int ,_gdff error ){return _dadd ._fcfb .Read (p )};

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_gbda *PdfObjectString )Decoded ()string {if _gbda ==nil {return "";};_ebde :=[]byte (_gbda ._gffd );if len (_ebde )>=2&&_ebde [0]==0xFE&&_ebde [1]==0xFF{return _dgc .UTF16ToString (_ebde [2:]);};return _dgc .PDFDocEncodingToString (_ebde );};

// WriteString outputs the object as it is to be written to file.
func (_dcce *PdfObjectInteger )WriteString ()string {return _ecd .FormatInt (int64 (*_dcce ),10)};func (_gcgfd *PdfParser )parseLinearizedDictionary ()(*PdfObjectDictionary ,error ){_ddcbd ,_dfac :=_gcgfd ._eege .Seek (0,_gd .SeekEnd );if _dfac !=nil {return nil ,_dfac ;
};var _fgdc int64 ;var _feee int64 =2048;for _fgdc < _ddcbd -4{if _ddcbd <=(_feee +_fgdc ){_feee =_ddcbd -_fgdc ;};_ ,_cccdb :=_gcgfd ._eege .Seek (_fgdc ,_gd .SeekStart );if _cccdb !=nil {return nil ,_cccdb ;};_adagf :=make ([]byte ,_feee );_ ,_cccdb =_gcgfd ._eege .Read (_adagf );
if _cccdb !=nil {return nil ,_cccdb ;};_dba .Log .Trace ("\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0066i\u0072\u0073\u0074\u0020\u0069\u006ed\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u003a \u0022\u0025\u0073\u0022",string (_adagf ));
_fefd :=_aafc .FindAllStringIndex (string (_adagf ),-1);if _fefd !=nil {_bdfd :=_fefd [0];_dba .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_fefd );_ ,_debc :=_gcgfd ._eege .Seek (int64 (_bdfd [0]),_gd .SeekStart );if _debc !=nil {return nil ,_debc ;
};_gcgfd ._cega =_beb .NewReader (_gcgfd ._eege );_bbcc ,_debc :=_gcgfd .ParseIndirectObject ();if _debc !=nil {return nil ,nil ;};if _ddgcc ,_bcad :=GetIndirect (_bbcc );_bcad {if _cdda ,_aadg :=GetDict (_ddgcc .PdfObject );_aadg {if _fgeg :=_cdda .Get ("\u004c\u0069\u006e\u0065\u0061\u0072\u0069\u007a\u0065\u0064");
_fgeg !=nil {return _cdda ,nil ;};return nil ,nil ;};};return nil ,nil ;};_fgdc +=_feee -4;};return nil ,_e .New ("\u0074\u0068\u0065\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064");
};

// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _bfdg ,_egceb :=obj .(*PdfObjectReference );_egceb {return _bfdg .Resolve ();};return obj ;};func _afbfg (_cgagdg _gd .ReadSeeker ,_acbda int64 )(*limitedReadSeeker ,error ){_ ,_gfee :=_cgagdg .Seek (0,_gd .SeekStart );
if _gfee !=nil {return nil ,_gfee ;};return &limitedReadSeeker {_agfcb :_cgagdg ,_dceb :_acbda },nil ;};

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _abcfc ,_aaab :=obj .(*PdfObjectReference );_aaab {obj =_abcfc .Resolve ();};_afeb ,_cgdb :=obj .(*PdfIndirectObject );_ffgb :=0;for _cgdb {obj =_afeb .PdfObject ;_afeb ,_cgdb =GetIndirect (obj );_ffgb ++;
if _ffgb > _abfa {_dba .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_abfa );
return nil ;};};return obj ;};

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_abfd *PdfParser )IsEncrypted ()(bool ,error ){if _abfd ._bfa !=nil {return true ,nil ;}else if _abfd ._ddgd ==nil {return false ,nil ;};_dba .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");
_ecfd :=_abfd ._ddgd .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _ecfd ==nil {return false ,nil ;};_dba .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_geag *PdfObjectDictionary ;);switch _eece :=_ecfd .(type ){case *PdfObjectDictionary :_geag =_eece ;
case *PdfObjectReference :_dba .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_eece );_cbbg ,_aaaf :=_abfd .LookupByReference (*_eece );_dba .Log .Trace ("\u0031\u003a\u0020%\u0071",_cbbg );
if _aaaf !=nil {return false ,_aaaf ;};_cfgc ,_decb :=_cbbg .(*PdfIndirectObject );if !_decb {_dba .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");
return false ,_e .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_afag ,_decb :=_cfgc .PdfObject .(*PdfObjectDictionary );_abfd ._gfcc =_cfgc ;_dba .Log .Trace ("\u0032\u003a\u0020%\u0071",_afag );if !_decb {return false ,_e .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");
};_geag =_afag ;case *PdfObjectNull :_dba .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");
return false ,nil ;default:return false ,_bb .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_eece );};_aggf ,_cebe :=PdfCryptNewDecrypt (_abfd ,_geag ,_abfd ._ddgd );if _cebe !=nil {return false ,_cebe ;
};for _ ,_eafa :=range []string {"\u0045n\u0063\u0072\u0079\u0070\u0074"}{_gegf :=_abfd ._ddgd .Get (PdfObjectName (_eafa ));if _gegf ==nil {continue ;};switch _aefe :=_gegf .(type ){case *PdfObjectReference :_aggf ._dfga [int (_aefe .ObjectNumber )]=struct{}{};
case *PdfIndirectObject :_aggf ._gbf [_aefe ]=true ;_aggf ._dfga [int (_aefe .ObjectNumber )]=struct{}{};};};_abfd ._bfa =_aggf ;_dba .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_aggf );
return true ,nil ;};const _ada ="\u0053\u0074\u0064C\u0046";

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_cbfg *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_bag :=PdfIndirectObject {};_bag ._dcab =_cbfg ;_dba .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_gfge ,_bbbbf :=_cbfg ._cega .Peek (20);
if _bbbbf !=nil {if _bbbbf !=_gd .EOF {_dba .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_bag ,_bbbbf ;
};};_dba .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_gfge ));_acec :=_aafc .FindStringSubmatchIndex (string (_gfge ));if len (_acec )< 6{if _bbbbf ==_gd .EOF {return nil ,_bbbbf ;
};_dba .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_gfge ));
return &_bag ,_e .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_cbfg ._cega .Discard (_acec [0]);_dba .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_acec );_bebdd :=_acec [1]-_acec [0];_fgfg :=make ([]byte ,_bebdd );_ ,_bbbbf =_cbfg .ReadAtLeast (_fgfg ,_bebdd );if _bbbbf !=nil {_dba .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_bbbbf );
return nil ,_bbbbf ;};_dba .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_fgfg );_ddag :=_aafc .FindStringSubmatch (string (_fgfg ));if len (_ddag )< 3{_dba .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_fgfg ));
return &_bag ,_e .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_fgbdd ,_ :=_ecd .Atoi (_ddag [1]);_egf ,_ :=_ecd .Atoi (_ddag [2]);_bag .ObjectNumber =int64 (_fgbdd );_bag .GenerationNumber =int64 (_egf );for {_efca ,_aeef :=_cbfg ._cega .Peek (2);if _aeef !=nil {return &_bag ,_aeef ;};_dba .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_efca ),string (_efca ));
if IsWhiteSpace (_efca [0]){_cbfg .skipSpaces ();}else if _efca [0]=='%'{_cbfg .skipComments ();}else if (_efca [0]=='<')&&(_efca [1]=='<'){_dba .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_bag .PdfObject ,_aeef =_cbfg .ParseDict ();
_dba .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_aeef );if _aeef !=nil {return &_bag ,_aeef ;};_dba .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");
}else if (_efca [0]=='/')||(_efca [0]=='(')||(_efca [0]=='[')||(_efca [0]=='<'){_bag .PdfObject ,_aeef =_cbfg .parseObject ();if _aeef !=nil {return &_bag ,_aeef ;};_dba .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");
}else if _efca [0]==']'{_dba .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");
_cbfg ._cega .Discard (1);}else {if _efca [0]=='e'{_fffg ,_gafc :=_cbfg .readTextLine ();if _gafc !=nil {return nil ,_gafc ;};if len (_fffg )>=6&&_fffg [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _efca [0]=='s'{_efca ,_ =_cbfg ._cega .Peek (10);
if string (_efca [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_adbae :=6;if len (_efca )> 6{if IsWhiteSpace (_efca [_adbae ])&&_efca [_adbae ]!='\r'&&_efca [_adbae ]!='\n'{_dba .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");
_cbfg ._gbgef ._cccb =true ;_adbae ++;};if _efca [_adbae ]=='\r'{_adbae ++;if _efca [_adbae ]=='\n'{_adbae ++;};}else if _efca [_adbae ]=='\n'{_adbae ++;}else {_cbfg ._gbgef ._cccb =true ;};};_cbfg ._cega .Discard (_adbae );_cdgc ,_cbfgc :=_bag .PdfObject .(*PdfObjectDictionary );
if !_cbfgc {return nil ,_e .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_dba .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_cdgc );
_fcg ,_egdee :=_cbfg .traceStreamLength (_cdgc .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _egdee !=nil {_dba .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_egdee );
return nil ,_egdee ;};_dba .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_fcg );_cfdcg ,_ecgaf :=_fcg .(*PdfObjectInteger );if !_ecgaf {return nil ,_e .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");
};_faecg :=*_cfdcg ;if _faecg < 0{return nil ,_e .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_fdgc :=_cbfg .GetFileOffset ();
_afeg :=_cbfg .xrefNextObjectOffset (_fdgc );if _fdgc +int64 (_faecg )> _afeg &&_afeg > _fdgc {_dba .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_fdgc +int64 (_faecg ));_dba .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_afeg );
_fgge :=_afeg -_fdgc -17;if _fgge < 0{return nil ,_e .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");
};_dba .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_fgge );_faecg =PdfObjectInteger (_fgge );
_cdgc .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_fgge ));};if int64 (_faecg )> _cbfg ._bcaf {_dba .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");
return nil ,_e .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_ddac :=make ([]byte ,_faecg );
_ ,_egdee =_cbfg .ReadAtLeast (_ddac ,int (_faecg ));if _egdee !=nil {_dba .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_ddac ),_ddac );_dba .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_egdee );
return nil ,_egdee ;};_dfce :=PdfObjectStream {};_dfce .Stream =_ddac ;_dfce .PdfObjectDictionary =_bag .PdfObject .(*PdfObjectDictionary );_dfce .ObjectNumber =_bag .ObjectNumber ;_dfce .GenerationNumber =_bag .GenerationNumber ;_dfce .PdfObjectReference ._dcab =_cbfg ;
_cbfg .skipSpaces ();_cbfg ._cega .Discard (9);_cbfg .skipSpaces ();return &_dfce ,nil ;};};_bag .PdfObject ,_aeef =_cbfg .parseObject ();if _bag .PdfObject ==nil {_dba .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");
_bag .PdfObject =MakeNull ();};return &_bag ,_aeef ;};};if _bag .PdfObject ==nil {_dba .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");
_bag .PdfObject =MakeNull ();};_dba .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_bag ,nil ;};

// Clear resets the dictionary to an empty state.
func (_dfgb *PdfObjectDictionary )Clear (){_dfgb ._ebce =[]PdfObjectName {};_dfgb ._bbfc =map[PdfObjectName ]PdfObject {};_dfgb ._addd =&_ec .Mutex {};};

// GetFilterName returns the name of the encoding filter.
func (_fcac *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };

// WriteString outputs the object as it is to be written to file.
func (_addfg *PdfObjectStreams )WriteString ()string {var _dbaba _ga .Builder ;_dbaba .WriteString (_ecd .FormatInt (_addfg .ObjectNumber ,10));_dbaba .WriteString ("\u0020\u0030\u0020\u0052");return _dbaba .String ();};

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};

// Seek implementation of Seek interface.
func (_dca *limitedReadSeeker )Seek (offset int64 ,whence int )(int64 ,error ){var _accdd int64 ;switch whence {case _gd .SeekStart :_accdd =offset ;case _gd .SeekCurrent :_bafef ,_aefg :=_dca ._agfcb .Seek (0,_gd .SeekCurrent );if _aefg !=nil {return 0,_aefg ;
};_accdd =_bafef +offset ;case _gd .SeekEnd :_accdd =_dca ._dceb +offset ;};if _age :=_dca .getError (_accdd );_age !=nil {return 0,_age ;};if _ ,_bdffb :=_dca ._agfcb .Seek (_accdd ,_gd .SeekStart );_bdffb !=nil {return 0,_bdffb ;};return _accdd ,nil ;
};

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_fcfac *MultiEncoder )AddEncoder (encoder StreamEncoder ){_fcfac ._gfbdc =append (_fcfac ._gfbdc ,encoder );};

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_gag *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_ae ,_efd :=obj .(*PdfObjectReference );if !_efd {return obj ,nil ;};_aag :=_gag .GetFileOffset ();defer func (){_gag .SetFileOffset (_aag )}();_ce ,_ag :=_gag .LookupByReference (*_ae );
if _ag !=nil {return nil ,_ag ;};_gaff ,_feg :=_ce .(*PdfIndirectObject );if !_feg {return _ce ,nil ;};_ce =_gaff .PdfObject ;_ ,_efd =_ce .(*PdfObjectReference );if _efd {return _gaff ,_e .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");
};return _ce ,nil ;};

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_accd *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_adbc :=_db .NewReader (encoded );var _bcec []byte ;for {_ecffd ,_feba :=_adbc .ReadByte ();if _feba !=nil {return nil ,_feba ;};if _ecffd > 128{_dbag ,_aedd :=_adbc .ReadByte ();
if _aedd !=nil {return nil ,_aedd ;};for _dbcc :=0;_dbcc < 257-int (_ecffd );_dbcc ++{_bcec =append (_bcec ,_dbag );};}else if _ecffd < 128{for _fcdc :=0;_fcdc < int (_ecffd )+1;_fcdc ++{_gdd ,_bbda :=_adbc .ReadByte ();if _bbda !=nil {return nil ,_bbda ;
};_bcec =append (_bcec ,_gdd );};}else {break ;};};return _bcec ,nil ;};

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};

// WriteString outputs the object as it is to be written to file.
func (_aefa *PdfObjectString )WriteString ()string {var _dfab _db .Buffer ;if _aefa ._fecf {_aaeaf :=_fb .EncodeToString (_aefa .Bytes ());_dfab .WriteString ("\u003c");_dfab .WriteString (_aaeaf );_dfab .WriteString ("\u003e");return _dfab .String ();
};_begcd :=map[byte ]string {'\n':"\u005c\u006e",'\r':"\u005c\u0072",'\t':"\u005c\u0074",'\b':"\u005c\u0062",'\f':"\u005c\u0066",'(':"\u005c\u0028",')':"\u005c\u0029",'\\':"\u005c\u005c"};_dfab .WriteString ("\u0028");for _bfba :=0;_bfba < len (_aefa ._gffd );
_bfba ++{_gaeb :=_aefa ._gffd [_bfba ];if _aabd ,_gfcd :=_begcd [_gaeb ];_gfcd {_dfab .WriteString (_aabd );}else {_dfab .WriteByte (_gaeb );};};_dfab .WriteString ("\u0029");return _dfab .String ();};

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_cdcc *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_cdecc error ){const _eabg ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";
if _cdcc ==nil {return _fc .Error (_eabg ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_cdcc .DefaultPageSettings ;};if _cdcc ._ecge ==nil {_cdcc ._ecge =_df .InitEncodeDocument (settings .FileMode );
};if _cdecc =settings .Validate ();_cdecc !=nil {return _fc .Wrap (_cdecc ,_eabg ,"");};_cebc ,_cdecc :=img .toBitmap ();if _cdecc !=nil {return _fc .Wrap (_cdecc ,_eabg ,"");};switch settings .Compression {case JB2Generic :if _cdecc =_cdcc ._ecge .AddGenericPage (_cebc ,settings .DuplicatedLinesRemoval );
_cdecc !=nil {return _fc .Wrap (_cdecc ,_eabg ,"");};case JB2SymbolCorrelation :return _fc .Error (_eabg ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
case JB2SymbolRankHaus :return _fc .Error (_eabg ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
default:return _fc .Error (_eabg ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_acde *PdfObjectDictionary )Keys ()[]PdfObjectName {if _acde ==nil {return nil ;};return _acde ._ebce ;};

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_ddcga *JBIG2Encoder )Encode ()(_agfc []byte ,_bbbb error ){const _cege ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _ddcga ._ecge ==nil {return nil ,_fc .Errorf (_cege ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");
};_ddcga ._ecge .FullHeaders =_ddcga .DefaultPageSettings .FileMode ;_agfc ,_bbbb =_ddcga ._ecge .Encode ();if _bbbb !=nil {return nil ,_fc .Wrap (_bbbb ,_cege ,"");};return _agfc ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_fbcb *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_gadd :=MakeDict ();_gadd .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_fbcb .GetFilterName ()));return _gadd ;};func (_agfcd *PdfParser )parseBool ()(PdfObjectBool ,error ){_aff ,_aedda :=_agfcd ._cega .Peek (4);
if _aedda !=nil {return PdfObjectBool (false ),_aedda ;};if (len (_aff )>=4)&&(string (_aff [:4])=="\u0074\u0072\u0075\u0065"){_agfcd ._cega .Discard (4);return PdfObjectBool (true ),nil ;};_aff ,_aedda =_agfcd ._cega .Peek (5);if _aedda !=nil {return PdfObjectBool (false ),_aedda ;
};if (len (_aff )>=5)&&(string (_aff [:5])=="\u0066\u0061\u006cs\u0065"){_agfcd ._cega .Discard (5);return PdfObjectBool (false ),nil ;};return PdfObjectBool (false ),_e .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");
};func _eeceg (_agcad *PdfObjectDictionary )(_bdga *_gdf .ImageBase ){var (_cfde *PdfObjectInteger ;_ceabe bool ;);if _cfde ,_ceabe =_agcad .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );_ceabe {_bdga =&_gdf .ImageBase {Width :int (*_cfde )};}else {return nil ;
};if _cfde ,_ceabe =_agcad .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );_ceabe {_bdga .Height =int (*_cfde );};if _cfde ,_ceabe =_agcad .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );
_ceabe {_bdga .BitsPerComponent =int (*_cfde );};if _cfde ,_ceabe =_agcad .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );_ceabe {_bdga .ColorComponents =int (*_cfde );};return _bdga ;};

// WriteString outputs the object as it is to be written to file.
func (_aaeab *PdfObjectFloat )WriteString ()string {return _ecd .FormatFloat (float64 (*_aaeab ),'f',-1,64);};

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_fage *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_fage .setWithLock (key ,val ,true );};

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_fcfc *_gdf .ImageBase ;};

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_cfdd []PdfObject ;};

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_bgc encryptDict ;_fbbg _ef .StdEncryptDict ;_gfd string ;_ead []byte ;_gbf map[PdfObject ]bool ;_acc map[PdfObject ]bool ;_cgb bool ;_da cryptFilters ;_fdgg string ;_gcag string ;_afd *PdfParser ;_dfga map[int ]struct{};};

// Read implementation of Read interface.
func (_gfdb *limitedReadSeeker )Read (p []byte )(_ebff int ,_ffgd error ){_ccbdb ,_ffgd :=_gfdb ._agfcb .Seek (0,_gd .SeekCurrent );if _ffgd !=nil {return 0,_ffgd ;};_beea :=_gfdb ._dceb -_ccbdb ;if _beea ==0{return 0,_gd .EOF ;};if _cfba :=int64 (len (p ));
_cfba < _beea {_beea =_cfba ;};_ecef :=make ([]byte ,_beea );_ebff ,_ffgd =_gfdb ._agfcb .Read (_ecef );copy (p ,_ecef );return _ebff ,_ffgd ;};func (_beeg *PdfParser )readTextLine ()(string ,error ){var _agdf _db .Buffer ;for {_cecc ,_cbbeg :=_beeg ._cega .Peek (1);
if _cbbeg !=nil {_dba .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_cbbeg .Error ());return _agdf .String (),_cbbeg ;};if (_cecc [0]!='\r')&&(_cecc [0]!='\n'){_ggcg ,_ :=_beeg ._cega .ReadByte ();_agdf .WriteByte (_ggcg );}else {break ;
};};return _agdf .String (),nil ;};

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fdcd *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_egafe []float64 ,_gffc error ){for _ ,_afgca :=range objects {_dgcc ,_fada :=GetNumberAsFloat (_afgca );if _fada !=nil {return nil ,_fada ;};_egafe =append (_egafe ,_dgcc );};return _egafe ,nil ;};

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_daedc :=PdfObjectBool (val );return &_daedc };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_ceaed *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_acdea *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_acdea ._cfdd ){return _e .New ("\u004f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_acdea ._cfdd [i ]=obj ;return nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_cfce *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_aebf :=MakeDict ();_aebf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cfce .GetFilterName ()));return _aebf ;};

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _gd .ReadSeeker )(*PdfParser ,error ){_gbad :=&PdfParser {_eege :rs ,ObjCache :make (objectCache ),_egef :map[int64 ]bool {},_adbb :make ([]int64 ,0),_dbbg :make (map[*PdfParser ]*PdfParser )};_becgf ,_bgdbg ,_gfca :=_gbad .parsePdfVersion ();
if _gfca !=nil {_dba .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_gfca );return nil ,_gfca ;};_gbad ._abfe .Major =_becgf ;_gbad ._abfe .Minor =_bgdbg ;
if _gbad ._ddgd ,_gfca =_gbad .loadXrefs ();_gfca !=nil {_dba .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_gfca );return nil ,_gfca ;
};_dba .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_gbad ._ddgd );_fagb ,_gfca :=_gbad .parseLinearizedDictionary ();if _gfca !=nil {return nil ,_gfca ;};if _fagb !=nil {_gbad ._feag ,_gfca =_gbad .checkLinearizedInformation (_fagb );
if _gfca !=nil {return nil ,_gfca ;};};if len (_gbad ._bbbaa .ObjectMap )==0{return nil ,_bb .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");
};_gbad ._aaggc =len (_gbad ._adbb );if _gbad ._feag &&_gbad ._aaggc !=0{_gbad ._aaggc --;};_gbad ._ddaa =make ([]*PdfParser ,_gbad ._aaggc );return _gbad ,nil ;};func _bfga (_cefbd int )int {_abegf :=_cefbd >>(_egdd -1);return (_cefbd ^_abegf )-_abegf };
func (_dcgb *PdfParser )skipComments ()error {if _ ,_gecaf :=_dcgb .skipSpaces ();_gecaf !=nil {return _gecaf ;};_gbbc :=true ;for {_fagd ,_edg :=_dcgb ._cega .Peek (1);if _edg !=nil {_dba .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_edg .Error ());
return _edg ;};if _gbbc &&_fagd [0]!='%'{return nil ;};_gbbc =false ;if (_fagd [0]!='\r')&&(_fagd [0]!='\n'){_dcgb ._cega .ReadByte ();}else {break ;};};return _dcgb .skipComments ();};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_gaee *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_ddd :=MakeDict ();_ddd .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gaee .GetFilterName ()));_ffgf :=_gaee .MakeDecodeParams ();if _ffgf !=nil {_ddd .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_ffgf );
};_ddd .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_gaee .EarlyChange )));return _ddd ;};

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};

// GetFilterName returns the name of the encoding filter.
func (_ddge *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };

// GetFilterName returns the name of the encoding filter.
func (_bcca *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };

// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_gffd string ;_fecf bool ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dfgg *LZWEncoder )MakeDecodeParams ()PdfObject {if _dfgg .Predictor > 1{_bbba :=MakeDict ();_bbba .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_dfgg .Predictor )));if _dfgg .BitsPerComponent !=8{_bbba .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_dfgg .BitsPerComponent )));
};if _dfgg .Columns !=1{_bbba .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_dfgg .Columns )));};if _dfgg .Colors !=1{_bbba .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_dfgg .Colors )));};return _bbba ;};return nil ;
};

// HeaderPosition gets the file header position.
func (_abde ParserMetadata )HeaderPosition ()int {return _abde ._feb };

// GetUpdatedObjects returns pdf objects which were updated from the specific version (from prevParser).
func (_bded *PdfParser )GetUpdatedObjects (prevParser *PdfParser )(map[int64 ]PdfObject ,error ){if prevParser ==nil {return nil ,_e .New ("\u0070\u0072e\u0076\u0069\u006f\u0075\u0073\u0020\u0070\u0061\u0072\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020nu\u006c\u006c");
};_bfbb ,_acbc :=_bded .getNumbersOfUpdatedObjects (prevParser );if _acbc !=nil {return nil ,_acbc ;};_dgffd :=make (map[int64 ]PdfObject );for _ ,_ffab :=range _bfbb {if _dfbfg ,_acbe :=_bded .LookupByNumber (_ffab );_acbe ==nil {_dgffd [int64 (_ffab )]=_dfbfg ;
}else {return nil ,_acbe ;};};return _dgffd ,nil ;};

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_adadc *JBIG2Encoder )DecodeGlobals (encoded []byte )(_gf .Globals ,error ){return _gf .DecodeGlobals (encoded );};

// GetXrefType returns the type of the first xref object (table or stream).
func (_agdg *PdfParser )GetXrefType ()*xrefType {return _agdg ._bebag };

// GetFilterName returns the name of the encoding filter.
func (_bfd *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_egdg *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_dba .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_dba .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_egdg .Predictor );
if _egdg .BitsPerComponent !=8{return nil ,_bb .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_egdg .BitsPerComponent );
};_ged ,_bdfg :=_egdg .DecodeBytes (streamObj .Stream );if _bdfg !=nil {return nil ,_bdfg ;};_ged ,_bdfg =_egdg .postDecodePredict (_ged );if _bdfg !=nil {return nil ,_bdfg ;};return _ged ,nil ;};func (_dggf *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_edeca :=_dggf ._cega .Discard (4);
return PdfObjectNull {},_edeca ;};

// GetFilterName returns the name of the encoding filter.
func (_effb *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_bcbc *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_dba .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_dba .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");
return []byte {},nil ;};_dcb :=_db .NewReader (encoded );_bbee ,_gcf :=_dg .NewReader (_dcb );if _gcf !=nil {_dba .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_gcf );_dba .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );
return nil ,_gcf ;};defer _bbee .Close ();var _edaf _db .Buffer ;_edaf .ReadFrom (_bbee );return _edaf .Bytes (),nil ;};const JB2ImageAutoThreshold =-1.0;

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_feaf *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_cbbe :=n ;_cggg :=0;_fffb :=0;for _cbbe > 0{_bgca ,_cbc :=_feaf ._cega .Read (p [_cggg :]);if _cbc !=nil {_dba .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_bgca ,_fffb ,_cbc .Error ());
return _cggg ,_e .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_fffb ++;_cggg +=_bgca ;_cbbe -=_bgca ;};return _cggg ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_eef *FlateEncoder )MakeDecodeParams ()PdfObject {if _eef .Predictor > 1{_gda :=MakeDict ();_gda .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_eef .Predictor )));if _eef .BitsPerComponent !=8{_gda .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_eef .BitsPerComponent )));
};if _eef .Columns !=1{_gda .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_eef .Columns )));};if _eef .Colors !=1{_gda .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_eef .Colors )));};return _gda ;};return nil ;};


// DecodeStream implements ASCII85 stream decoding.
func (_cabe *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _cabe .DecodeBytes (streamObj .Stream );};

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;func (_dfgd *PdfParser )parseHexString ()(*PdfObjectString ,error ){_dfgd ._cega .ReadByte ();var _bcag _db .Buffer ;for {_fcacg ,_baegd :=_dfgd ._cega .Peek (1);if _baegd !=nil {return MakeString (""),_baegd ;};if _fcacg [0]=='>'{_dfgd ._cega .ReadByte ();
break ;};_ffdd ,_ :=_dfgd ._cega .ReadByte ();if _dfgd ._cdbda {if _db .IndexByte (_gdea ,_ffdd )==-1{_dfgd ._gbgef ._fccc =true ;};};if !IsWhiteSpace (_ffdd ){_bcag .WriteByte (_ffdd );};};if _bcag .Len ()%2==1{_dfgd ._gbgef ._eaeg =true ;_bcag .WriteRune ('0');
};_fdeg ,_ :=_fb .DecodeString (_bcag .String ());return MakeHexString (string (_fdeg )),nil ;};func _acage (_fcfde string )(PdfObjectReference ,error ){_eadd :=PdfObjectReference {};_bdcb :=_efeg .FindStringSubmatch (_fcfde );if len (_bdcb )< 3{_dba .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");
return _eadd ,_e .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};_geab ,_ :=_ecd .Atoi (_bdcb [1]);_ceege ,_ :=_ecd .Atoi (_bdcb [2]);_eadd .ObjectNumber =int64 (_geab );
_eadd .GenerationNumber =int64 (_ceege );return _eadd ,nil ;};const _egdd =32<<(^uint (0)>>63);

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_eggc *PdfObjectReference )Resolve ()PdfObject {if _eggc ._dcab ==nil {return MakeNull ();};_ccde ,_ ,_bdcba :=_eggc ._dcab .resolveReference (_eggc );if _bdcba !=nil {_dba .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_bdcba );
return MakeNull ();};if _ccde ==nil {_dba .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");
return MakeNull ();};return _ccde ;};

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_bbbg *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_ebf :=_db .NewReader (encoded );_bfg ,_gbec :=_fg .Decode (_ebf );if _gbec !=nil {_dba .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_gbec );
return nil ,_gbec ;};_gbdg :=_bfg .Bounds ();var _bcc =make ([]byte ,_gbdg .Dx ()*_gbdg .Dy ()*_bbbg .ColorComponents *_bbbg .BitsPerComponent /8);_dag :=0;switch _bbbg .ColorComponents {case 1:_adba :=[]float64 {_bbbg .Decode [0],_bbbg .Decode [1]};for _aaca :=_gbdg .Min .Y ;
_aaca < _gbdg .Max .Y ;_aaca ++{for _bege :=_gbdg .Min .X ;_bege < _gbdg .Max .X ;_bege ++{_bgdd :=_bfg .At (_bege ,_aaca );if _bbbg .BitsPerComponent ==16{_bceb ,_ecbe :=_bgdd .(_c .Gray16 );if !_ecbe {return nil ,_e .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_geef :=_agfd (uint (_bceb .Y >>8),_adba [0],_adba [1]);_geca :=_agfd (uint (_bceb .Y ),_adba [0],_adba [1]);_bcc [_dag ]=byte (_geef );_dag ++;_bcc [_dag ]=byte (_geca );_dag ++;}else {_geba ,_gbbe :=_bgdd .(_c .Gray );if !_gbbe {return nil ,_e .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_bcc [_dag ]=byte (_agfd (uint (_geba .Y ),_adba [0],_adba [1]));_dag ++;};};};case 3:_bdcf :=[]float64 {_bbbg .Decode [0],_bbbg .Decode [1]};_dfe :=[]float64 {_bbbg .Decode [2],_bbbg .Decode [3]};_dgff :=[]float64 {_bbbg .Decode [4],_bbbg .Decode [5]};
for _bbad :=_gbdg .Min .Y ;_bbad < _gbdg .Max .Y ;_bbad ++{for _gdfa :=_gbdg .Min .X ;_gdfa < _gbdg .Max .X ;_gdfa ++{_addc :=_bfg .At (_gdfa ,_bbad );if _bbbg .BitsPerComponent ==16{_cedd ,_bbac :=_addc .(_c .RGBA64 );if !_bbac {return nil ,_e .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_egbd :=_agfd (uint (_cedd .R >>8),_bdcf [0],_bdcf [1]);_dafa :=_agfd (uint (_cedd .R ),_bdcf [0],_bdcf [1]);_gbgf :=_agfd (uint (_cedd .G >>8),_dfe [0],_dfe [1]);_ffbg :=_agfd (uint (_cedd .G ),_dfe [0],_dfe [1]);_fcbd :=_agfd (uint (_cedd .B >>8),_dgff [0],_dgff [1]);
_ggf :=_agfd (uint (_cedd .B ),_dgff [0],_dgff [1]);_bcc [_dag ]=byte (_egbd );_dag ++;_bcc [_dag ]=byte (_dafa );_dag ++;_bcc [_dag ]=byte (_gbgf );_dag ++;_bcc [_dag ]=byte (_ffbg );_dag ++;_bcc [_dag ]=byte (_fcbd );_dag ++;_bcc [_dag ]=byte (_ggf );
_dag ++;}else {_ffe ,_cggad :=_addc .(_c .RGBA );if _cggad {_dbe :=_agfd (uint (_ffe .R ),_bdcf [0],_bdcf [1]);_bab :=_agfd (uint (_ffe .G ),_dfe [0],_dfe [1]);_ccgc :=_agfd (uint (_ffe .B ),_dgff [0],_dgff [1]);_bcc [_dag ]=byte (_dbe );_dag ++;_bcc [_dag ]=byte (_bab );
_dag ++;_bcc [_dag ]=byte (_ccgc );_dag ++;}else {_gcbd ,_dagg :=_addc .(_c .YCbCr );if !_dagg {return nil ,_e .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_cab ,_cdae ,_cgfg ,_ :=_gcbd .RGBA ();_cgfa :=_agfd (uint (_cab >>8),_bdcf [0],_bdcf [1]);
_gcg :=_agfd (uint (_cdae >>8),_dfe [0],_dfe [1]);_egbg :=_agfd (uint (_cgfg >>8),_dgff [0],_dgff [1]);_bcc [_dag ]=byte (_cgfa );_dag ++;_bcc [_dag ]=byte (_gcg );_dag ++;_bcc [_dag ]=byte (_egbg );_dag ++;};};};};case 4:_dadf :=[]float64 {_bbbg .Decode [0],_bbbg .Decode [1]};
_efe :=[]float64 {_bbbg .Decode [2],_bbbg .Decode [3]};_dgffg :=[]float64 {_bbbg .Decode [4],_bbbg .Decode [5]};_gfc :=[]float64 {_bbbg .Decode [6],_bbbg .Decode [7]};for _ccad :=_gbdg .Min .Y ;_ccad < _gbdg .Max .Y ;_ccad ++{for _bgg :=_gbdg .Min .X ;
_bgg < _gbdg .Max .X ;_bgg ++{_fff :=_bfg .At (_bgg ,_ccad );_gde ,_agcg :=_fff .(_c .CMYK );if !_agcg {return nil ,_e .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_ebgac :=255-_agfd (uint (_gde .C ),_dadf [0],_dadf [1]);
_egaf :=255-_agfd (uint (_gde .M ),_efe [0],_efe [1]);_gac :=255-_agfd (uint (_gde .Y ),_dgffg [0],_dgffg [1]);_fabc :=255-_agfd (uint (_gde .K ),_gfc [0],_gfc [1]);_bcc [_dag ]=byte (_ebgac );_dag ++;_bcc [_dag ]=byte (_egaf );_dag ++;_bcc [_dag ]=byte (_gac );
_dag ++;_bcc [_dag ]=byte (_fabc );_dag ++;};};};return _bcc ,nil ;};func _gec (_bcg *_ef .StdEncryptDict ,_agg *PdfObjectDictionary ){_agg .Set ("\u0052",MakeInteger (int64 (_bcg .R )));_agg .Set ("\u0050",MakeInteger (int64 (_bcg .P )));_agg .Set ("\u004f",MakeStringFromBytes (_bcg .O ));
_agg .Set ("\u0055",MakeStringFromBytes (_bcg .U ));if _bcg .R >=5{_agg .Set ("\u004f\u0045",MakeStringFromBytes (_bcg .OE ));_agg .Set ("\u0055\u0045",MakeStringFromBytes (_bcg .UE ));_agg .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_bcg .EncryptMetadata ));
if _bcg .R > 5{_agg .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_bcg .Perms ));};};};

// HasDataAfterEOF checks if there is some data after EOF marker.
func (_ecb ParserMetadata )HasDataAfterEOF ()bool {return _ecb ._ccd };

// Clear resets the array to an empty state.
func (_cbaeg *PdfObjectArray )Clear (){_cbaeg ._ebb =[]PdfObject {}};func (_deaa *PdfParser )xrefNextObjectOffset (_fgcd int64 )int64 {_dgedf :=int64 (0);if len (_deaa ._bbbaa .ObjectMap )==0{return 0;};if len (_deaa ._bbbaa ._edf )==0{_bgbb :=0;for _ ,_dcgg :=range _deaa ._bbbaa .ObjectMap {if _dcgg .Offset > 0{_bgbb ++;
};};if _bgbb ==0{return 0;};_deaa ._bbbaa ._edf =make ([]XrefObject ,_bgbb );_gedg :=0;for _ ,_fdaff :=range _deaa ._bbbaa .ObjectMap {if _fdaff .Offset > 0{_deaa ._bbbaa ._edf [_gedg ]=_fdaff ;_gedg ++;};};_a .Slice (_deaa ._bbbaa ._edf ,func (_ggad ,_gbfa int )bool {return _deaa ._bbbaa ._edf [_ggad ].Offset < _deaa ._bbbaa ._edf [_gbfa ].Offset });
};_dbge :=_a .Search (len (_deaa ._bbbaa ._edf ),func (_gaac int )bool {return _deaa ._bbbaa ._edf [_gaac ].Offset >=_fgcd });if _dbge < len (_deaa ._bbbaa ._edf ){_dgedf =_deaa ._bbbaa ._edf [_dbge ].Offset ;};return _dgedf ;};

// Validate validates the page settings for the JBIG2 encoder.
func (_cefc JBIG2EncoderSettings )Validate ()error {const _caff ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _cefc .Threshold < 0||_cefc .Threshold > 1.0{return _fc .Errorf (_caff ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_cefc .Threshold );
};if _cefc .ResolutionX < 0{return _fc .Errorf (_caff ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_cefc .ResolutionX );
};if _cefc .ResolutionY < 0{return _fc .Errorf (_caff ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_cefc .ResolutionY );
};if _cefc .DefaultPixelValue !=0&&_cefc .DefaultPixelValue !=1{return _fc .Errorf (_caff ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_cefc .DefaultPixelValue );
};if _cefc .Compression !=JB2Generic {return _fc .Errorf (_caff ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
};return nil ;};func (_eedc *PdfParser )inspect ()(map[string ]int ,error ){_dba .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");_dba .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");
_gbdcb :=map[string ]int {};_cecf :=0;_dfcg :=0;var _gdfd []int ;for _fgae :=range _eedc ._bbbaa .ObjectMap {_gdfd =append (_gdfd ,_fgae );};_a .Ints (_gdfd );_deca :=0;for _ ,_fgce :=range _gdfd {_gccea :=_eedc ._bbbaa .ObjectMap [_fgce ];if _gccea .ObjectNumber ==0{continue ;
};_cecf ++;_dba .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_dba .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_gccea .ObjectNumber );
_ggega ,_ffabe :=_eedc .LookupByNumber (_gccea .ObjectNumber );if _ffabe !=nil {_dba .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_gccea .ObjectNumber ,_ffabe );
_dfcg ++;continue ;};_dba .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_ggega );_ebec ,_abagc :=_ggega .(*PdfIndirectObject );if _abagc {_dba .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_gccea .ObjectNumber ,_ebec );
_dbac ,_gaba :=_ebec .PdfObject .(*PdfObjectDictionary );if _gaba {if _faacg ,_eagc :=_dbac .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_eagc {_edda :=string (*_faacg );_dba .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_edda );
_ ,_ebfe :=_gbdcb [_edda ];if _ebfe {_gbdcb [_edda ]++;}else {_gbdcb [_edda ]=1;};}else if _fbad ,_ecca :=_dbac .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_ecca {_edc :=string (*_fbad );_dba .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_edc );
_ ,_dfaf :=_gbdcb [_edc ];if _dfaf {_gbdcb [_edc ]++;}else {_gbdcb [_edc ]=1;};};if _fffgb ,_caca :=_dbac .Get ("\u0053").(*PdfObjectName );_caca &&*_fffgb =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_bbef :=_gbdcb ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];
if _bbef {_gbdcb ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_gbdcb ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _agee ,_bcfcc :=_ggega .(*PdfObjectStream );_bcfcc {if _ddaaf ,_bdddg :=_agee .PdfObjectDictionary .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_bdddg {_dba .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_ddaaf );_abce :=string (*_ddaaf );_gbdcb [_abce ]++;};}else {_cddbg ,_dbcb :=_ggega .(*PdfObjectDictionary );
if _dbcb {_afegc ,_bdcgf :=_cddbg .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _bdcgf {_fafgd :=string (*_afegc );_dba .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_fafgd );_gbdcb [_fafgd ]++;
};};_dba .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_gccea .ObjectNumber ,_ggega );};_deca ++;};_dba .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");
_dba .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");_dba .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_cecf );_dba .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_dfcg );
for _fbcf ,_ccbee :=range _gbdcb {_dba .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_fbcf ,_ccbee );};_dba .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_eedc ._bbbaa .ObjectMap )< 1{_dba .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");
return nil ,_bb .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_cebfb ,_gedf :=_gbdcb ["\u0046\u006f\u006e\u0074"];
if !_gedf ||_cebfb < 2{_dba .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_dba .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");
};return _gbdcb ,nil ;};func (_ecdb *PdfParser )resolveReference (_ecfgd *PdfObjectReference )(PdfObject ,bool ,error ){_fded ,_eceda :=_ecdb .ObjCache [int (_ecfgd .ObjectNumber )];if _eceda {return _fded ,true ,nil ;};_bedc ,_bfec :=_ecdb .LookupByReference (*_ecfgd );
if _bfec !=nil {return nil ,false ,_bfec ;};_ecdb .ObjCache [int (_ecfgd .ObjectNumber )]=_bedc ;return _bedc ,false ,nil ;};

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_bbff *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _gfcf ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _gacd :=_bbff .AddPageImage (img ,&_bbff .DefaultPageSettings );
_gacd !=nil {return nil ,_fc .Wrap (_gacd ,_gfcf ,"");};return _bbff .Encode ();};

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_agcf *PdfCrypt )GetAccessPermissions ()_ef .Permissions {return _agcf ._fbbg .P };

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_ggeg *PdfParser )CheckAccessRights (password []byte )(bool ,_ef .Permissions ,error ){if _ggeg ._bfa ==nil {return true ,_ef .PermOwner ,nil ;};return _ggeg ._bfa .checkAccessRights (password );};

// GetXrefTable returns the PDFs xref table.
func (_aada *PdfParser )GetXrefTable ()XrefTable {return _aada ._bbbaa };

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_ecad *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_dadda :=_ecad .Get (key );if _dadda ==nil {return "",false ;};_faaed ,_agbf :=_dadda .(*PdfObjectString );if !_agbf {return "",false ;};return _faaed .Str (),true ;};func (_bcggd *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _bcggd ._bfb {return nil ,_bb .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");
};_bcggd ._bfb =true ;_bcggd ._eege .Seek (0,_gd .SeekStart );_bcggd ._cega =_beb .NewReader (_bcggd ._eege );_beefg :=20;_agef :=make ([]byte ,_beefg );_ccda :=XrefTable {};_ccda .ObjectMap =make (map[int ]XrefObject );for {_gbbfc ,_fbcea :=_bcggd ._cega .ReadByte ();
if _fbcea !=nil {if _fbcea ==_gd .EOF {break ;}else {return nil ,_fbcea ;};};if _gbbfc =='j'&&_agef [_beefg -1]=='b'&&_agef [_beefg -2]=='o'&&IsWhiteSpace (_agef [_beefg -3]){_dead :=_beefg -4;for IsWhiteSpace (_agef [_dead ])&&_dead > 0{_dead --;};if _dead ==0||!IsDecimalDigit (_agef [_dead ]){continue ;
};for IsDecimalDigit (_agef [_dead ])&&_dead > 0{_dead --;};if _dead ==0||!IsWhiteSpace (_agef [_dead ]){continue ;};for IsWhiteSpace (_agef [_dead ])&&_dead > 0{_dead --;};if _dead ==0||!IsDecimalDigit (_agef [_dead ]){continue ;};for IsDecimalDigit (_agef [_dead ])&&_dead > 0{_dead --;
};if _dead ==0{continue ;};_bfcd :=_bcggd .GetFileOffset ()-int64 (_beefg -_dead );_gddb :=append (_agef [_dead +1:],_gbbfc );_febf ,_afgb ,_gaec :=_ffee (string (_gddb ));if _gaec !=nil {_dba .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_gaec );
return nil ,_gaec ;};if _cfafg ,_eeee :=_ccda .ObjectMap [_febf ];!_eeee ||_cfafg .Generation < _afgb {_afed :=XrefObject {};_afed .XType =XrefTypeTableEntry ;_afed .ObjectNumber =_febf ;_afed .Generation =_afgb ;_afed .Offset =_bfcd ;_ccda .ObjectMap [_febf ]=_afed ;
};};_agef =append (_agef [1:_beefg ],_gbbfc );};_bcggd ._dged =nil ;return &_ccda ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_egbc *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_cefa :=MakeDict ();_cefa .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_egbc .GetFilterName ()));return _cefa ;};var _ageb =_b .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");


// String returns a string describing `array`.
func (_geade *PdfObjectArray )String ()string {_dgcb :="\u005b";for _eaebc ,_caaff :=range _geade .Elements (){_dgcb +=_caaff .String ();if _eaebc < (_geade .Len ()-1){_dgcb +="\u002c\u0020";};};_dgcb +="\u005d";return _dgcb ;};

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_cebf *PdfIndirectObject ,_fgdf bool ){obj =ResolveReference (obj );_cebf ,_fgdf =obj .(*PdfIndirectObject );return _cebf ,_fgdf ;};

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _dcded (o ,0,traversed );};func _gdc (_fad *_ef .StdEncryptDict ,_cbd *PdfObjectDictionary )error {R ,_bdc :=_cbd .Get ("\u0052").(*PdfObjectInteger );
if !_bdc {return _e .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");};if *R < 2||*R > 6{return _bb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );
};_fad .R =int (*R );O ,_bdc :=_cbd .GetString ("\u004f");if !_bdc {return _e .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");};if _fad .R ==5||_fad .R ==6{if len (O )< 48{return _bb .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));
};}else if len (O )!=32{return _bb .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));};_fad .O =[]byte (O );U ,_bdc :=_cbd .GetString ("\u0055");if !_bdc {return _e .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");
};if _fad .R ==5||_fad .R ==6{if len (U )< 48{return _bb .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));};}else if len (U )!=32{_dba .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));
};_fad .U =[]byte (U );if _fad .R >=5{OE ,_ee :=_cbd .GetString ("\u004f\u0045");if !_ee {return _e .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");
}else if len (OE )!=32{return _bb .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));};_fad .OE =[]byte (OE );UE ,_ee :=_cbd .GetString ("\u0055\u0045");if !_ee {return _e .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");
}else if len (UE )!=32{return _bb .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_fad .UE =[]byte (UE );};P ,_bdc :=_cbd .Get ("\u0050").(*PdfObjectInteger );if !_bdc {return _e .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");
};_fad .P =_ef .Permissions (*P );if _fad .R ==6{Perms ,_ade :=_cbd .GetString ("\u0050\u0065\u0072m\u0073");if !_ade {return _e .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");
}else if len (Perms )!=16{return _bb .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_fad .Perms =[]byte (Perms );};if _gdb ,_ggbf :=_cbd .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );
_ggbf {_fad .EncryptMetadata =bool (*_gdb );}else {_fad .EncryptMetadata =true ;};return nil ;};var (ErrUnsupportedEncodingParameters =_e .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");
ErrNoCCITTFaxDecode =_e .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoJBIG2Decode =_e .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoJPXDecode =_e .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoPdfVersion =_e .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_e .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
ErrNotSupported =_cf .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_e .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072");
);

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_afga *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_ggag :=range another .Keys (){_fggc :=another .Get (_ggag );_afga .Set (_ggag ,_fggc );};};return _afga ;};

// GetRevision returns PdfParser for the specific version of the Pdf document.
func (_cagcc *PdfParser )GetRevision (revisionNumber int )(*PdfParser ,error ){_addba :=_cagcc ._aaggc ;if _addba ==revisionNumber {return _cagcc ,nil ;};if _addba < revisionNumber {return nil ,_e .New ("\u0075\u006e\u0064\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0072\u0065\u0076\u0069\u0073i\u006fn\u004e\u0075\u006d\u0062\u0065\u0072\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e");
};if _cagcc ._ddaa [revisionNumber ]!=nil {return _cagcc ._ddaa [revisionNumber ],nil ;};_gceg :=_cagcc ;for ;_addba > revisionNumber ;_addba --{_daedb ,_gfbb :=_gceg .GetPreviousRevisionParser ();if _gfbb !=nil {return nil ,_gfbb ;};_cagcc ._ddaa [_addba -1]=_daedb ;
_cagcc ._dbbg [_gceg ]=_daedb ;_gceg =_daedb ;};return _gceg ,nil ;};

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_dgfdb :=MultiEncoder {};_dgfdb ._gfbdc =[]StreamEncoder {};return &_dgfdb ;};

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_gdef *PdfObjectArray )Get (i int )PdfObject {if _gdef ==nil ||i >=len (_gdef ._ebb )||i < 0{return nil ;};return _gdef ._ebb [i ];};type objectStream struct{N int ;_ab []byte ;_efa map[int ]int64 ;};type objectCache map[int ]PdfObject ;

// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_dcaa :=PdfObjectName (s );return &_dcaa };

// HeaderCommentBytes gets the header comment bytes.
func (_fbdd ParserMetadata )HeaderCommentBytes ()[4]byte {return _fbdd ._ded };

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_fcef *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_aeeb :=MakeDict ();_aeeb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_fcef .GetFilterName ()));_aeeb .SetIfNotNil ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_fcef .MakeDecodeParams ());
return _aeeb ;};

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_aadc *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _aadc .DecodeBytes (streamObj .Stream );};

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_ccag *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fce :=_db .NewReader (encoded );var _faec []byte ;for {_cgbd ,_gbeef :=_fce .ReadByte ();if _gbeef !=nil {return nil ,_gbeef ;};if _cgbd =='>'{break ;};if IsWhiteSpace (_cgbd ){continue ;
};if (_cgbd >='a'&&_cgbd <='f')||(_cgbd >='A'&&_cgbd <='F')||(_cgbd >='0'&&_cgbd <='9'){_faec =append (_faec ,_cgbd );}else {_dba .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_cgbd );
return nil ,_bb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_cgbd );};};if len (_faec )%2==1{_faec =append (_faec ,'0');
};_dba .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_faec );_fcfa :=make ([]byte ,_fb .DecodedLen (len (_faec )));_ ,_cffa :=_fb .Decode (_fcfa ,_faec );if _cffa !=nil {return nil ,_cffa ;};return _fcfa ,nil ;};func (_gfaf *PdfParser )parseName ()(PdfObjectName ,error ){var _gcbg _db .Buffer ;
_dadg :=false ;for {_dgcd ,_cac :=_gfaf ._cega .Peek (1);if _cac ==_gd .EOF {break ;};if _cac !=nil {return PdfObjectName (_gcbg .String ()),_cac ;};if !_dadg {if _dgcd [0]=='/'{_dadg =true ;_gfaf ._cega .ReadByte ();}else if _dgcd [0]=='%'{_gfaf .readComment ();
_gfaf .skipSpaces ();}else {_dba .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_dgcd ,_dgcd );return PdfObjectName (_gcbg .String ()),_bb .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_dgcd [0]);
};}else {if IsWhiteSpace (_dgcd [0]){break ;}else if (_dgcd [0]=='/')||(_dgcd [0]=='[')||(_dgcd [0]=='(')||(_dgcd [0]==']')||(_dgcd [0]=='<')||(_dgcd [0]=='>'){break ;}else if _dgcd [0]=='#'{_adbca ,_eecf :=_gfaf ._cega .Peek (3);if _eecf !=nil {return PdfObjectName (_gcbg .String ()),_eecf ;
};_faadg ,_eecf :=_fb .DecodeString (string (_adbca [1:3]));if _eecf !=nil {_dba .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");
_gcbg .WriteByte ('#');_gfaf ._cega .Discard (1);continue ;};_gfaf ._cega .Discard (3);_gcbg .Write (_faadg );}else {_acca ,_ :=_gfaf ._cega .ReadByte ();_gcbg .WriteByte (_acca );};};};return PdfObjectName (_gcbg .String ()),nil ;};

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_egac *PdfObjectStreams )Elements ()[]PdfObject {if _egac ==nil {return nil ;};return _egac ._cfdd ;};

// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_aacdf *PdfObjectInteger ,_beaa bool ){_aacdf ,_beaa =TraceToDirectObject (obj ).(*PdfObjectInteger );return _aacdf ,_beaa ;};

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_gegae *PdfObjectBool ,_dcae bool ){_gegae ,_dcae =TraceToDirectObject (obj ).(*PdfObjectBool );return _gegae ,_dcae ;};

// UpdateParams updates the parameter values of the encoder.
func (_edfd *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_aeb *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_edag :=MakeDict ();_edag .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_aeb .GetFilterName ()));_gcad :=_aeb .MakeDecodeParams ();if _gcad !=nil {_edag .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_gcad );
};return _edag ;};func (_befaf *PdfParser )repairSeekXrefMarker ()error {_fafd ,_gcadb :=_befaf ._eege .Seek (0,_gd .SeekEnd );if _gcadb !=nil {return _gcadb ;};_ggg :=_b .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");var _aaeeb int64 ;var _feebb int64 =1000;
for _aaeeb < _fafd {if _fafd <=(_feebb +_aaeeb ){_feebb =_fafd -_aaeeb ;};_ ,_bcfe :=_befaf ._eege .Seek (-_aaeeb -_feebb ,_gd .SeekEnd );if _bcfe !=nil {return _bcfe ;};_facb :=make ([]byte ,_feebb );_befaf ._eege .Read (_facb );_dba .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_facb ));
_geae :=_ggg .FindAllStringIndex (string (_facb ),-1);if _geae !=nil {_cbddd :=_geae [len (_geae )-1];_dba .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_geae );_befaf ._eege .Seek (-_aaeeb -_feebb +int64 (_cbddd [0]),_gd .SeekEnd );_befaf ._cega =_beb .NewReader (_befaf ._eege );
for {_fbbdc ,_begab :=_befaf ._cega .Peek (1);if _begab !=nil {return _begab ;};_dba .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_fbbdc [0],_fbbdc [0]);if !IsWhiteSpace (_fbbdc [0]){break ;};_befaf ._cega .Discard (1);};return nil ;
};_dba .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");
_aaeeb +=_feebb ;};_dba .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");
return _e .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dbee *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_fcdag *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _acce []int64 ;for _ ,_fcdb :=range _fcdag .Elements (){if _efdb ,_fbdfc :=_fcdb .(*PdfObjectInteger );_fbdfc {_acce =append (_acce ,int64 (*_efdb ));}else {return nil ,ErrTypeError ;};
};return _acce ,nil ;};type cryptFilters map[string ]_ge .Filter ;

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_gcdg :=&PdfObjectDictionary {};_gcdg ._bbfc =map[PdfObjectName ]PdfObject {};_gcdg ._ebce =[]PdfObjectName {};_gcdg ._addd =&_ec .Mutex {};return _gcdg ;};

// String returns a descriptive information string about the encryption method used.
func (_dec *PdfCrypt )String ()string {if _dec ==nil {return "";};_cbg :=_dec ._bgc .Filter +"\u0020\u002d\u0020";if _dec ._bgc .V ==0{_cbg +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";
}else if _dec ._bgc .V ==1{_cbg +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _dec ._bgc .V ==2{_cbg +=_bb .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_dec ._bgc .Length );}else if _dec ._bgc .V ==3{_cbg +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";
}else if _dec ._bgc .V >=4{_cbg +=_bb .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_dec ._fdgg ,_dec ._gcag );
_cbg +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _dbc ,_agf :=range _dec ._da {_cbg +=_bb .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_dbc ,_agf .Name (),_agf .KeyLength ());
};};_bac :=_dec .GetAccessPermissions ();_cbg +=_bb .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_bac );return _cbg ;};

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_dba .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_cbbc ,_ecfb :=NewEncoderFromStream (streamObj );if _ecfb !=nil {_dba .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_ecfb );
return _ecfb ;};if _gabd ,_aegg :=_cbbc .(*LZWEncoder );_aegg {_gabd .EarlyChange =0;streamObj .PdfObjectDictionary .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_dba .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_cbbc );
_aegd ,_ecfb :=_cbbc .EncodeBytes (streamObj .Stream );if _ecfb !=nil {_dba .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_ecfb );return _ecfb ;
};streamObj .Stream =_aegd ;streamObj .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_aegd ))));return nil ;};

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_c .Model ;Bounds ()_ea .Rectangle ;At (_fcab ,_cbf int )_c .Color ;Set (_baa ,_gdg int ,_dded _c .Color );};

// Len returns the number of elements in the streams.
func (_ggaf *PdfObjectStreams )Len ()int {if _ggaf ==nil {return 0;};return len (_ggaf ._cfdd );};

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_fcfbe :=TraceToDirectObject (obj ).(*PdfObjectNull );return _fcfbe ;};func (_efeb *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_efeb ._cega )};var _gdea =[]byte ("\u0030\u0031\u0032\u003345\u0036\u0037\u0038\u0039\u0061\u0062\u0063\u0064\u0065\u0066\u0041\u0042\u0043\u0044E\u0046");
var _ceag =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};

// String returns a string describing `ind`.
func (_fdedd *PdfIndirectObject )String ()string {return _bb .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_fdedd ).ObjectNumber );};func _fedba (_eacd *PdfObjectStream )(*MultiEncoder ,error ){_bcbdc :=NewMultiEncoder ();_ebcb :=_eacd .PdfObjectDictionary ;
if _ebcb ==nil {return _bcbdc ,nil ;};var _ebfa *PdfObjectDictionary ;var _cafe []PdfObject ;_eabb :=_ebcb .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _eabb !=nil {_babb ,_fceb :=_eabb .(*PdfObjectDictionary );if _fceb {_ebfa =_babb ;
};_edece ,_egde :=_eabb .(*PdfObjectArray );if _egde {for _ ,_fgfa :=range _edece .Elements (){_fgfa =TraceToDirectObject (_fgfa );if _eeecb ,_gdcc :=_fgfa .(*PdfObjectDictionary );_gdcc {_cafe =append (_cafe ,_eeecb );}else {_cafe =append (_cafe ,MakeDict ());
};};};};_eabb =_ebcb .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");if _eabb ==nil {return nil ,_bb .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");};_fged ,_aeec :=_eabb .(*PdfObjectArray );if !_aeec {return nil ,_bb .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");
};for _dfgga ,_bdgf :=range _fged .Elements (){_bbecd ,_acbd :=_bdgf .(*PdfObjectName );if !_acbd {return nil ,_bb .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");
};var _fecc PdfObject ;if _ebfa !=nil {_fecc =_ebfa ;}else {if len (_cafe )> 0{if _dfgga >=len (_cafe ){return nil ,_bb .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");
};_fecc =_cafe [_dfgga ];};};var _bcab *PdfObjectDictionary ;if _aedb ,_abgg :=_fecc .(*PdfObjectDictionary );_abgg {_bcab =_aedb ;};_dba .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_bbecd ,_fecc ,_bcab );
if *_bbecd ==StreamEncodingFilterNameFlate {_gdbbe ,_aaeef :=_gbd (_eacd ,_bcab );if _aaeef !=nil {return nil ,_aaeef ;};_bcbdc .AddEncoder (_gdbbe );}else if *_bbecd ==StreamEncodingFilterNameLZW {_ecea ,_eced :=_adf (_eacd ,_bcab );if _eced !=nil {return nil ,_eced ;
};_bcbdc .AddEncoder (_ecea );}else if *_bbecd ==StreamEncodingFilterNameASCIIHex {_gega :=NewASCIIHexEncoder ();_bcbdc .AddEncoder (_gega );}else if *_bbecd ==StreamEncodingFilterNameASCII85 {_bedd :=NewASCII85Encoder ();_bcbdc .AddEncoder (_bedd );}else if *_bbecd ==StreamEncodingFilterNameDCT {_fcdd ,_bebd :=_gbee (_eacd ,_bcbdc );
if _bebd !=nil {return nil ,_bebd ;};_bcbdc .AddEncoder (_fcdd );_dba .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_dba .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_bcbdc );
}else if *_bbecd ==StreamEncodingFilterNameCCITTFax {_eefcf ,_dffc :=_afgg (_eacd ,_bcab );if _dffc !=nil {return nil ,_dffc ;};_bcbdc .AddEncoder (_eefcf );}else {_dba .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_bbecd );
return nil ,_bb .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");};};return _bcbdc ,nil ;};

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_geddfe :=TraceToDirectObject (streamObj .PdfObjectDictionary .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _geddfe ==nil {return NewRawEncoder (),nil ;};if _ ,_bbcd :=_geddfe .(*PdfObjectNull );
_bbcd {return NewRawEncoder (),nil ;};_bdgeeg ,_bbfb :=_geddfe .(*PdfObjectName );if !_bbfb {_efffcd ,_ccaeb :=_geddfe .(*PdfObjectArray );if !_ccaeb {return nil ,_bb .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");
};if _efffcd .Len ()==0{return NewRawEncoder (),nil ;};if _efffcd .Len ()!=1{_cdbb ,_bfge :=_fedba (streamObj );if _bfge !=nil {_dba .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_bfge );
return nil ,_bfge ;};_dba .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_cdbb );return _cdbb ,nil ;};_geddfe =_efffcd .Get (0);_bdgeeg ,_ccaeb =_geddfe .(*PdfObjectName );if !_ccaeb {return nil ,_bb .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");
};};if _fcae ,_bbcb :=_fafca .Load (_bdgeeg .String ());_bbcb {return _fcae .(StreamEncoder ),nil ;};switch *_bdgeeg {case StreamEncodingFilterNameFlate :return _gbd (streamObj ,nil );case StreamEncodingFilterNameLZW :return _adf (streamObj ,nil );case StreamEncodingFilterNameDCT :return _gbee (streamObj ,nil );
case StreamEncodingFilterNameRunLength :return _bdge (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;case StreamEncodingFilterNameCCITTFax :return _afgg (streamObj ,nil );
case StreamEncodingFilterNameJBIG2 :return _aagee (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_dba .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");
return nil ,_bb .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_bdgeeg );};

// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_faacf *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_eed ,_fee :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _fee ==nil {_faacf .BitsPerComponent =int (_eed );
};_ddcgab ,_fee :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _fee ==nil {_faacf .Width =int (_ddcgab );};_cgagd ,_fee :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _fee ==nil {_faacf .Height =int (_cgagd );
};_decg ,_fee :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _fee ==nil {_faacf .ColorComponents =int (_decg );};};

// LookupByReference looks up a PdfObject by a reference.
func (_cga *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_dba .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());return _cga .LookupByNumber (int (ref .ObjectNumber ));
};

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
// 	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _ea .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _gffbf ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_fc .Error (_gffbf ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");
};var (_ddaf uint8 ;_edbc _gdf .Image ;_fggd error ;);if bwThreshold ==JB2ImageAutoThreshold {_edbc ,_fggd =_gdf .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_fc .Error (_gffbf ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");
}else {_ddaf =uint8 (255*bwThreshold );_edbc ,_fggd =_gdf .MonochromeThresholdConverter (_ddaf ).Convert (i );};if _fggd !=nil {return nil ,_fggd ;};return _gbdc (_edbc ),nil ;};

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_eedg *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_eedg ._ebb ){return _e .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_eedg ._ebb [i ]=obj ;return nil ;};

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_aaff *PdfParser )GetTrailer ()*PdfObjectDictionary {return _aaff ._ddgd };func _adf (_abab *PdfObjectStream ,_dgdb *PdfObjectDictionary )(*LZWEncoder ,error ){_ddbd :=NewLZWEncoder ();_cdec :=_abab .PdfObjectDictionary ;if _cdec ==nil {return _ddbd ,nil ;
};if _dgdb ==nil {_cfdcf :=TraceToDirectObject (_cdec .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _cfdcf !=nil {if _feae ,_dbdb :=_cfdcf .(*PdfObjectDictionary );_dbdb {_dgdb =_feae ;}else if _dgfb ,_adad :=_cfdcf .(*PdfObjectArray );
_adad {if _dgfb .Len ()==1{if _bbf ,_gbcbe :=GetDict (_dgfb .Get (0));_gbcbe {_dgdb =_bbf ;};};};if _dgdb ==nil {_dba .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_cfdcf );
return nil ,_bb .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_effdc :=_cdec .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _effdc !=nil {_gbdd ,_fbf :=_effdc .(*PdfObjectInteger );
if !_fbf {_dba .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_effdc );
return nil ,_bb .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_gbdd !=0&&*_gbdd !=1{return nil ,_bb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");
};_ddbd .EarlyChange =int (*_gbdd );}else {_ddbd .EarlyChange =1;};if _dgdb ==nil {return _ddbd ,nil ;};if _gbed ,_bebe :=GetIntVal (_dgdb .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));_bebe {if _gbed ==0||_gbed ==1{_ddbd .EarlyChange =_gbed ;
}else {_dba .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020E\u0061\u0072\u006c\u0079\u0043\u0068\u0061n\u0067\u0065\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020%\u0064",_gbed );};};_effdc =_dgdb .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");
if _effdc !=nil {_abbb ,_gbg :=_effdc .(*PdfObjectInteger );if !_gbg {_dba .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_effdc );
return nil ,_bb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_ddbd .Predictor =int (*_abbb );};_effdc =_dgdb .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
if _effdc !=nil {_cbba ,_acgfd :=_effdc .(*PdfObjectInteger );if !_acgfd {_dba .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
return nil ,_bb .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_ddbd .BitsPerComponent =int (*_cbba );};if _ddbd .Predictor > 1{_ddbd .Columns =1;_effdc =_dgdb .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");
if _effdc !=nil {_egb ,_gge :=_effdc .(*PdfObjectInteger );if !_gge {return nil ,_bb .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_ddbd .Columns =int (*_egb );
};_ddbd .Colors =1;_effdc =_dgdb .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _effdc !=nil {_acea ,_ffc :=_effdc .(*PdfObjectInteger );if !_ffc {return nil ,_bb .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");
};_ddbd .Colors =int (*_acea );};};_dba .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_dgdb .String ());return _ddbd ,nil ;};

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_cgbc string ,_gfeee bool ){_ecdfd ,_gfeee :=TraceToDirectObject (obj ).(*PdfObjectName );if _gfeee {return string (*_ecdfd ),true ;};return ;};

// RegisterCustomStreamEncoder register a custom encoder handler for certain filter.
func RegisterCustomStreamEncoder (filterName string ,customStreamEncoder StreamEncoder ){_fafca .Store (filterName ,customStreamEncoder );};

// HasNonConformantStream implements core.ParserMetadata.
func (_dbfb ParserMetadata )HasNonConformantStream ()bool {return _dbfb ._cccb };func (_bbgb *PdfObjectInteger )String ()string {return _bb .Sprintf ("\u0025\u0064",*_bbgb )};

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_ddae *PdfParser )Inspect ()(map[string ]int ,error ){return _ddae .inspect ()};

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_fae *FlateEncoder )SetPredictor (columns int ){_fae .Predictor =11;_fae .Columns =columns };

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 bit per component. It is also valid to provide 8 BPC, 1 CC image like
// a standard go image Gray data.
func (_bfdf *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _gfdc _gdf .Gray ;switch len (data ){case _bfdf .Rows *_bfdf .Columns :_gdad ,_gcaf :=_gdf .NewImage (_bfdf .Columns ,_bfdf .Rows ,8,1,data ,nil ,nil );if _gcaf !=nil {return nil ,_gcaf ;
};_gfdc =_gdad .(_gdf .Gray );case (_bfdf .Columns *_bfdf .Rows )+7>>3:_bfgc ,_bddd :=_gdf .NewImage (_bfdf .Columns ,_bfdf .Rows ,1,1,data ,nil ,nil );if _bddd !=nil {return nil ,_bddd ;};_gbge :=_bfgc .(*_gdf .Monochrome );if _bddd =_gbge .AddPadding ();
_bddd !=nil {return nil ,_bddd ;};_gfdc =_gbge ;default:if len (data )< _gdf .BytesPerLine (_bfdf .Columns ,1,1)*_bfdf .Rows {return nil ,_e .New ("p\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020i\u006e\u0070\u0075t\u0020d\u0061\u0074\u0061");
};_bfef ,_adgae :=_gdf .NewImage (_bfdf .Columns ,_bfdf .Rows ,1,1,data ,nil ,nil );if _adgae !=nil {return nil ,_adgae ;};_ggca :=_bfef .(*_gdf .Monochrome );_gfdc =_ggca ;};_ggdcf :=make ([][]byte ,_bfdf .Rows );for _abfbf :=0;_abfbf < _bfdf .Rows ;_abfbf ++{_bbde :=make ([]byte ,_bfdf .Columns );
for _ggfb :=0;_ggfb < _bfdf .Columns ;_ggfb ++{_daed :=_gfdc .GrayAt (_ggfb ,_abfbf );_bbde [_ggfb ]=_daed .Y >>7;};_ggdcf [_abfbf ]=_bbde ;};_fabg :=&_gaf .Encoder {K :_bfdf .K ,Columns :_bfdf .Columns ,EndOfLine :_bfdf .EndOfLine ,EndOfBlock :_bfdf .EndOfBlock ,BlackIs1 :_bfdf .BlackIs1 ,DamagedRowsBeforeError :_bfdf .DamagedRowsBeforeError ,Rows :_bfdf .Rows ,EncodedByteAlign :_bfdf .EncodedByteAlign };
return _fabg .Encode (_ggdcf ),nil ;};

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_bbfc map[PdfObjectName ]PdfObject ;_ebce []PdfObjectName ;_addd *_ec .Mutex ;_acgae *PdfParser ;};type objectStreams map[int ]objectStream ;

// PdfVersion returns version of the PDF file.
func (_fcba *PdfParser )PdfVersion ()Version {return _fcba ._abfe };

// UpdateParams updates the parameter values of the encoder.
func (_edff *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_ecg :=range _edff ._gfbdc {_ecg .UpdateParams (params );};};

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_dgdf *PdfObjectDictionary );EncodeBytes (_cca []byte )([]byte ,error );DecodeBytes (_cgga []byte )([]byte ,error );
DecodeStream (_dgaf *PdfObjectStream )([]byte ,error );};

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_bbcac *PdfParser )IsAuthenticated ()bool {return _bbcac ._bfa ._cgb };

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_ffcg *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_gaea :=encoded ;var _gbdge error ;for _ ,_gbcgc :=range _ffcg ._gfbdc {_dba .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_gbcgc ,_gbcgc );
_gaea ,_gbdge =_gbcgc .DecodeBytes (_gaea );if _gbdge !=nil {return nil ,_gbdge ;};};return _gaea ,nil ;};

// String returns a string representation of the *PdfObjectString.
func (_abef *PdfObjectString )String ()string {return _abef ._gffd };

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_dgeda *PdfObjectArray ,_ceec bool ){_dgeda ,_ceec =TraceToDirectObject (obj ).(*PdfObjectArray );return _dgeda ,_ceec ;};

// Remove removes an element specified by key.
func (_efddb *PdfObjectDictionary )Remove (key PdfObjectName ){_fgbb :=-1;for _cafff ,_gbbb :=range _efddb ._ebce {if _gbbb ==key {_fgbb =_cafff ;break ;};};if _fgbb >=0{_efddb ._ebce =append (_efddb ._ebce [:_fgbb ],_efddb ._ebce [_fgbb +1:]...);delete (_efddb ._bbfc ,key );
};};func _dcded (_bggae PdfObject ,_agcae int ,_bddc map[PdfObject ]struct{})error {_dba .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_agcae );
if _ ,_gddc :=_bddc [_bggae ];_gddc {_dba .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_bddc [_bggae ]=struct{}{};switch _egee :=_bggae .(type ){case *PdfIndirectObject :_ebca :=_egee ;
_dba .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_ebca );_dba .Log .Trace ("\u002d\u0020\u0025\u0073",_ebca .PdfObject );return _dcded (_ebca .PdfObject ,_agcae +1,_bddc );case *PdfObjectStream :_caed :=_egee ;return _dcded (_caed .PdfObjectDictionary ,_agcae +1,_bddc );
case *PdfObjectDictionary :_cgfaf :=_egee ;_dba .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_cgfaf );for _ ,_fdge :=range _cgfaf .Keys (){_gfedc :=_cgfaf .Get (_fdge );if _cfee ,_fbfc :=_gfedc .(*PdfObjectReference );_fbfc {_aadd :=_cfee .Resolve ();
_cgfaf .Set (_fdge ,_aadd );_gefd :=_dcded (_aadd ,_agcae +1,_bddc );if _gefd !=nil {return _gefd ;};}else {_cbac :=_dcded (_gfedc ,_agcae +1,_bddc );if _cbac !=nil {return _cbac ;};};};return nil ;case *PdfObjectArray :_gcgg :=_egee ;_dba .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_gcgg );
for _bcfc ,_aagd :=range _gcgg .Elements (){if _fbfaf ,_cegea :=_aagd .(*PdfObjectReference );_cegea {_bfgf :=_fbfaf .Resolve ();_gcgg .Set (_bcfc ,_bfgf );_dcgbg :=_dcded (_bfgf ,_agcae +1,_bddc );if _dcgbg !=nil {return _dcgbg ;};}else {_bcage :=_dcded (_aagd ,_agcae +1,_bddc );
if _bcage !=nil {return _bcage ;};};};return nil ;case *PdfObjectReference :_dba .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");return _e .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");
};return nil ;};

// String returns a string describing `null`.
func (_ffec *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_adde *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _gfbdb []float64 ;for _ ,_dfaa :=range _adde .Elements (){switch _gbae :=_dfaa .(type ){case *PdfObjectInteger :_gfbdb =append (_gfbdb ,float64 (*_gbae ));case *PdfObjectFloat :_gfbdb =append (_gfbdb ,float64 (*_gbae ));
default:return nil ,ErrTypeError ;};};return _gfbdb ,nil ;};

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_effd *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _effd .isEncrypted (obj ){return nil ;};switch _ffga :=obj .(type ){case *PdfIndirectObject :_effd ._acc [_ffga ]=true ;_dba .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_ffga .ObjectNumber ,_ffga .GenerationNumber );
_ecac :=_ffga .ObjectNumber ;_defg :=_ffga .GenerationNumber ;_dbfd :=_effd .Encrypt (_ffga .PdfObject ,_ecac ,_defg );if _dbfd !=nil {return _dbfd ;};return nil ;case *PdfObjectStream :_effd ._acc [_ffga ]=true ;_acac :=_ffga .PdfObjectDictionary ;if _beef ,_dfag :=_acac .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_dfag &&*_beef =="\u0058\u0052\u0065\u0066"{return nil ;};_aga :=_ffga .ObjectNumber ;_bdg :=_ffga .GenerationNumber ;_dba .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_aga ,_bdg );
_eeec :=_ada ;if _effd ._bgc .V >=4{_eeec =_effd ._fdgg ;_dba .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_effd ._fdgg );if _edec ,_cdg :=_acac .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );
_cdg {if _bcd ,_acb :=GetName (_edec .Get (0));_acb {if *_bcd =="\u0043\u0072\u0079p\u0074"{_eeec ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _eeg ,_bafe :=_acac .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );
_bafe {if _agdc ,_fece :=_eeg .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_fece {if _ ,_fdf :=_effd ._da [string (*_agdc )];_fdf {_dba .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_agdc );
_eeec =string (*_agdc );};};};};};};_dba .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_eeec );if _eeec =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_ffa :=_effd .Encrypt (_ffga .PdfObjectDictionary ,_aga ,_bdg );
if _ffa !=nil {return _ffa ;};_agfb ,_ffa :=_effd .makeKey (_eeec ,uint32 (_aga ),uint32 (_bdg ),_effd ._ead );if _ffa !=nil {return _ffa ;};_ffga .Stream ,_ffa =_effd .encryptBytes (_ffga .Stream ,_eeec ,_agfb );if _ffa !=nil {return _ffa ;};_acac .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_ffga .Stream ))));
return nil ;case *PdfObjectString :_dba .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_bbc :=_ada ;if _effd ._bgc .V >=4{_dba .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_effd ._gcag );
if _effd ._gcag =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_bbc =_effd ._gcag ;};_cecd ,_bbdb :=_effd .makeKey (_bbc ,uint32 (parentObjNum ),uint32 (parentGenNum ),_effd ._ead );if _bbdb !=nil {return _bbdb ;};_cbb :=_ffga .Str ();
_bcbf :=make ([]byte ,len (_cbb ));for _fde :=0;_fde < len (_cbb );_fde ++{_bcbf [_fde ]=_cbb [_fde ];};_dba .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_bcbf ,_bcbf );
_bcbf ,_bbdb =_effd .encryptBytes (_bcbf ,_bbc ,_cecd );if _bbdb !=nil {return _bbdb ;};_ffga ._gffd =string (_bcbf );return nil ;case *PdfObjectArray :for _ ,_abd :=range _ffga .Elements (){_fcad :=_effd .Encrypt (_abd ,parentObjNum ,parentGenNum );if _fcad !=nil {return _fcad ;
};};return nil ;case *PdfObjectDictionary :_bcf :=false ;if _bad :=_ffga .Get ("\u0054\u0079\u0070\u0065");_bad !=nil {_deg ,_ebaa :=_bad .(*PdfObjectName );if _ebaa &&*_deg =="\u0053\u0069\u0067"{_bcf =true ;};};for _ ,_gcaa :=range _ffga .Keys (){_ddc :=_ffga .Get (_gcaa );
if _bcf &&string (_gcaa )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_gcaa )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_gcaa )!="\u0050\u0072\u0065\u0076"&&string (_gcaa )!="\u004c\u0061\u0073\u0074"{_dbg :=_effd .Encrypt (_ddc ,parentObjNum ,parentGenNum );
if _dbg !=nil {return _dbg ;};};};return nil ;};return nil ;};func (_badc *limitedReadSeeker )getError (_acegd int64 )error {switch {case _acegd < 0:return _bb .Errorf ("\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064 \u006e\u0065\u0067\u0061\u0074\u0069\u0076e\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064",_acegd );
case _acegd > _badc ._dceb :return _bb .Errorf ("u\u006e\u0065\u0078\u0070ec\u0074e\u0064\u0020\u006f\u0066\u0066s\u0065\u0074\u003a\u0020\u0025\u0064",_acegd );};return nil ;};func (_fdad *PdfParser )checkPostEOFData ()error {const _fdgd ="\u0025\u0025\u0045O\u0046";
_ ,_cffg :=_fdad ._eege .Seek (-int64 (len ([]byte (_fdgd )))-1,_gd .SeekEnd );if _cffg !=nil {return _cffg ;};_abec :=make ([]byte ,len ([]byte (_fdgd ))+1);_ ,_cffg =_fdad ._eege .Read (_abec );if _cffg !=nil {if _cffg !=_gd .EOF {return _cffg ;};};if string (_abec )==_fdgd ||string (_abec )==_fdgd +"\u000a"{_fdad ._gbgef ._ccd =true ;
};return nil ;};

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_defc Version )String ()string {return _bb .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_defc .Major ,_defc .Minor );};func (_cgd *PdfParser )seekToEOFMarker (_fdfc int64 )error {var _bgdgb int64 ;var _aacd int64 =2048;for _bgdgb < _fdfc -4{if _fdfc <=(_aacd +_bgdgb ){_aacd =_fdfc -_bgdgb ;
};_ ,_dcgc :=_cgd ._eege .Seek (_fdfc -_bgdgb -_aacd ,_gd .SeekStart );if _dcgc !=nil {return _dcgc ;};_gdfac :=make ([]byte ,_aacd );_cgd ._eege .Read (_gdfac );_dba .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_gdfac ));
_gagc :=_fgac .FindAllStringIndex (string (_gdfac ),-1);if _gagc !=nil {_gade :=_gagc [len (_gagc )-1];_dba .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_gagc );_cgce :=_fdfc -_bgdgb -_aacd +int64 (_gade [0]);_cgd ._eege .Seek (_cgce ,_gd .SeekStart );
return nil ;};_dba .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");
_bgdgb +=_aacd -4;};_dba .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _fegb ;};

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_abbg *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){var _geegc _ea .Image ;if _abbg .ColorComponents ==1&&_abbg .BitsPerComponent ==8{_geegc =&_ea .Gray {Rect :_ea .Rect (0,0,_abbg .Width ,_abbg .Height ),Pix :data ,Stride :_gdf .BytesPerLine (_abbg .Width ,_abbg .BitsPerComponent ,_abbg .ColorComponents )};
}else {var _ddbc error ;_geegc ,_ddbc =_gdf .NewImage (_abbg .Width ,_abbg .Height ,_abbg .BitsPerComponent ,_abbg .ColorComponents ,data ,nil ,nil );if _ddbc !=nil {return nil ,_ddbc ;};};_gdcg :=_fg .Options {};_gdcg .Quality =_abbg .Quality ;var _cgbg _db .Buffer ;
if _caf :=_fg .Encode (&_cgbg ,_geegc ,&_gdcg );_caf !=nil {return nil ,_caf ;};return _cgbg .Bytes (),nil ;};

// GetParser returns the parser for lazy-loading or compare references.
func (_gfgaa *PdfObjectReference )GetParser ()*PdfParser {return _gfgaa ._dcab };

// WriteString outputs the object as it is to be written to file.
func (_fgeae *PdfObjectName )WriteString ()string {var _eeab _db .Buffer ;if len (*_fgeae )> 127{_dba .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_fgeae );};_eeab .WriteString ("\u002f");
for _bfdfe :=0;_bfdfe < len (*_fgeae );_bfdfe ++{_cfcc :=(*_fgeae )[_bfdfe ];if !IsPrintable (_cfcc )||_cfcc =='#'||IsDelimiter (_cfcc ){_eeab .WriteString (_bb .Sprintf ("\u0023\u0025\u002e2\u0078",_cfcc ));}else {_eeab .WriteByte (_cfcc );};};return _eeab .String ();
};var _fgdb =_b .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");func _ffee (_bcege string )(int ,int ,error ){_fcgf :=_aafc .FindStringSubmatch (_bcege );
if len (_fcgf )< 3{return 0,0,_e .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_efbf ,_ :=_ecd .Atoi (_fcgf [1]);_eadf ,_ :=_ecd .Atoi (_fcgf [2]);return _efbf ,_eadf ,nil ;};

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {_gcce :=PdfObjectFloat (val );return &_gcce };

// String returns the state of the bool as "true" or "false".
func (_aagfe *PdfObjectBool )String ()string {if *_aagfe {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// UpdateParams updates the parameter values of the encoder.
func (_dfea *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _fgbc ,_dgffa :=GetNumberAsInt64 (params .Get ("\u004b"));_dgffa ==nil {_dfea .K =int (_fgbc );};if _ccbd ,_bcdf :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));
_bcdf ==nil {_dfea .Columns =int (_ccbd );}else if _ccbd ,_bcdf =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_bcdf ==nil {_dfea .Columns =int (_ccbd );};if _eaac ,_afbf :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));
_afbf ==nil {_dfea .BlackIs1 =_eaac > 0;}else {if _cfgb ,_dcdg :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_dcdg {_dfea .BlackIs1 =_cfgb ;}else {if _efaaf ,_gbgc :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));
_gbgc {_eegd ,_abdd :=_efaaf .ToIntegerArray ();if _abdd ==nil {_dfea .BlackIs1 =_eegd [0]==1&&_eegd [1]==0;};};};};if _ceba ,_fade :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));
_fade ==nil {_dfea .EncodedByteAlign =_ceba > 0;}else {if _gdba ,_cfgd :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_cfgd {_dfea .EncodedByteAlign =_gdba ;};};if _abbbb ,_fbbe :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));
_fbbe ==nil {_dfea .EndOfLine =_abbbb > 0;}else {if _fafg ,_bgcb :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_bgcb {_dfea .EndOfLine =_fafg ;};};if _dbec ,_ecde :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));
_ecde ==nil {_dfea .Rows =int (_dbec );}else if _dbec ,_ecde =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_ecde ==nil {_dfea .Rows =int (_dbec );};if _gccf ,_gfg :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));
_gfg ==nil {_dfea .EndOfBlock =_gccf > 0;}else {if _abfba ,_dgfae :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_dgfae {_dfea .EndOfBlock =_abfba ;};};if _cgcf ,_eebg :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));
_eebg !=nil {_dfea .DamagedRowsBeforeError =int (_cgcf );};};

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_dddd *PdfObjectString ,_affb bool ){_dddd ,_affb =TraceToDirectObject (obj ).(*PdfObjectString );return _dddd ,_affb ;};

// NewCompliancePdfParser creates a new PdfParser that will parse input reader with the focus on extracting more metadata, which
// might affect performance of the regular PdfParser this function.
func NewCompliancePdfParser (rs _gd .ReadSeeker )(_eda *PdfParser ,_gdcf error ){_eda =&PdfParser {_eege :rs ,ObjCache :make (objectCache ),_egef :map[int64 ]bool {},_cdbda :true ,_dbbg :make (map[*PdfParser ]*PdfParser )};if _gdcf =_eda .parseDetailedHeader ();
_gdcf !=nil {return nil ,_gdcf ;};if _eda ._ddgd ,_gdcf =_eda .loadXrefs ();_gdcf !=nil {_dba .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_gdcf );
return nil ,_gdcf ;};_dba .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_eda ._ddgd );if len (_eda ._bbbaa .ObjectMap )==0{return nil ,_bb .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");
};return _eda ,nil ;};func (_fggdg *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_fggdg ._eege .Seek (0,_gd .SeekStart );_fggdg ._cega =_beb .NewReader (_fggdg ._eege );_aedaf :=20;_fead :=make ([]byte ,_aedaf );for {_gbfg ,_bfcb :=_fggdg ._cega .ReadByte ();
if _bfcb !=nil {if _bfcb ==_gd .EOF {break ;}else {return 0,0,_bfcb ;};};if IsDecimalDigit (_gbfg )&&_fead [_aedaf -1]=='.'&&IsDecimalDigit (_fead [_aedaf -2])&&_fead [_aedaf -3]=='-'&&_fead [_aedaf -4]=='F'&&_fead [_aedaf -5]=='D'&&_fead [_aedaf -6]=='P'{_cbbb :=int (_fead [_aedaf -2]-'0');
_baed :=int (_gbfg -'0');return _cbbb ,_baed ,nil ;};_fead =append (_fead [1:_aedaf ],_gbfg );};return 0,0,_e .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};func (_feagb *PdfObjectDictionary )setWithLock (_gbcgb PdfObjectName ,_efbc PdfObject ,_gebe bool ){if _gebe {_feagb ._addd .Lock ();
defer _feagb ._addd .Unlock ();};_ ,_gcfg :=_feagb ._bbfc [_gbcgb ];if !_gcfg {_feagb ._ebce =append (_feagb ._ebce ,_gbcgb );};_feagb ._bbfc [_gbcgb ]=_efbc ;};

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_gdbbc :=PdfObjectString {_gffd :s ,_fecf :true };return &_gdbbc ;};

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_gcbc *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;);

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {return &PdfObjectStreams {_cfdd :objects };};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_acdf *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_ddgg :=MakeDict ();_ddgg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_acdf .GetFilterName ()));return _ddgg ;};

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_gea *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _gea .DecodeBytes (streamObj .Stream );};func (_efffc *PdfParser )readComment ()(string ,error ){var _cafc _db .Buffer ;_ ,_dcadf :=_efffc .skipSpaces ();if _dcadf !=nil {return _cafc .String (),_dcadf ;
};_cccba :=true ;for {_fadb ,_abdeg :=_efffc ._cega .Peek (1);if _abdeg !=nil {_dba .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_abdeg .Error ());return _cafc .String (),_abdeg ;};if _cccba &&_fadb [0]!='%'{return _cafc .String (),_e .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");
};_cccba =false ;if (_fadb [0]!='\r')&&(_fadb [0]!='\n'){_fcda ,_ :=_efffc ._cega .ReadByte ();_cafc .WriteByte (_fcda );}else {break ;};};return _cafc .String (),nil ;};const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";
StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";
StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";
StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);func _edfa (_fdbg int )int {if _fdbg < 0{return -_fdbg ;
};return _fdbg ;};

// String returns a string describing `ref`.
func (_gdgd *PdfObjectReference )String ()string {return _bb .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_gdgd .ObjectNumber ,_gdgd .GenerationNumber );};

// GetXrefOffset returns the offset of the xref table.
func (_ebab *PdfParser )GetXrefOffset ()int64 {return _ebab ._cgfb };

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_geead *PdfObjectString )Str ()string {return _geead ._gffd };

// WriteString outputs the object as it is to be written to file.
func (_dadb *PdfObjectReference )WriteString ()string {var _gffe _ga .Builder ;_gffe .WriteString (_ecd .FormatInt (_dadb .ObjectNumber ,10));_gffe .WriteString ("\u0020");_gffe .WriteString (_ecd .FormatInt (_dadb .GenerationNumber ,10));_gffe .WriteString ("\u0020\u0052");
return _gffe .String ();};

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_fbgb *PdfObjectStream ,_cffga bool ){obj =ResolveReference (obj );_fbgb ,_cffga =obj .(*PdfObjectStream );return _fbgb ,_cffga ;};var _fafca _ec .Map ;func (_aafb *PdfParser )repairLocateXref ()(int64 ,error ){_fefa :=int64 (1000);
_aafb ._eege .Seek (-_fefa ,_gd .SeekCurrent );_beadf ,_aeddd :=_aafb ._eege .Seek (0,_gd .SeekCurrent );if _aeddd !=nil {return 0,_aeddd ;};_gebd :=make ([]byte ,_fefa );_aafb ._eege .Read (_gebd );_ccfb :=_fgdb .FindAllStringIndex (string (_gebd ),-1);
if len (_ccfb )< 1{_dba .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");return 0,_e .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");
};_eaba :=int64 (_ccfb [len (_ccfb )-1][0]);_ggeca :=_beadf +_eaba ;return _ggeca ,nil ;};func (_ggab *PdfObjectFloat )String ()string {return _bb .Sprintf ("\u0025\u0066",*_ggab )};func _gad (_gbcb *_ge .FilterDict ,_bee *PdfObjectDictionary )error {if _cfb ,_cfe :=_bee .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_cfe {if _ffg :=string (*_cfb );_ffg !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_dba .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_ffg );
};};_bde ,_ggbg :=_bee .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_ggbg {return _bb .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");
};_gbcb .CFM =string (*_bde );if _gfa ,_cce :=_bee .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_cce {_gbcb .AuthEvent =_ef .AuthEvent (*_gfa );}else {_gbcb .AuthEvent =_ef .EventDocOpen ;};if _cda ,_bga :=_bee .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );
_bga {_gbcb .Length =int (*_cda );};return nil ;};

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_gfbdc []StreamEncoder };

// DecodeStream implements ASCII hex decoding.
func (_dfdc *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _dfdc .DecodeBytes (streamObj .Stream );};

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_cbcg float64 ,_babbb bool ){_gbgcd ,_babbb :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _babbb {return float64 (*_gbgcd ),true ;};return 0,false ;};func _aagee (_agbc *PdfObjectStream ,_bbffc *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _cagf ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";
_dggg :=NewJBIG2Encoder ();_daeb :=_agbc .PdfObjectDictionary ;if _daeb ==nil {return _dggg ,nil ;};if _bbffc ==nil {_fbabd :=_daeb .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _fbabd !=nil {switch _cgeg :=_fbabd .(type ){case *PdfObjectDictionary :_bbffc =_cgeg ;
case *PdfObjectArray :if _cgeg .Len ()==1{if _bceg ,_cfgbe :=GetDict (_cgeg .Get (0));_cfgbe {_bbffc =_bceg ;};};default:_dba .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_fbabd );
return nil ,_fc .Errorf (_cagf ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_cgeg );};};};if _bbffc ==nil {return _dggg ,nil ;};_dggg .UpdateParams (_bbffc );
_ggbd ,_agdcd :=GetStream (_bbffc .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073"));if !_agdcd {return _dggg ,nil ;};var _addb error ;_dggg .Globals ,_addb =_gf .DecodeGlobals (_ggbd .Stream );if _addb !=nil {_addb =_fc .Wrap (_addb ,_cagf ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");
_dba .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_addb );return nil ,_addb ;};return _dggg ,nil ;};func _gbee (_caaf *PdfObjectStream ,_ggcf *MultiEncoder )(*DCTEncoder ,error ){_ecbc :=NewDCTEncoder ();_febg :=_caaf .PdfObjectDictionary ;
if _febg ==nil {return _ecbc ,nil ;};_edaa :=_caaf .Stream ;if _ggcf !=nil {_geeb ,_cfbd :=_ggcf .DecodeBytes (_edaa );if _cfbd !=nil {return nil ,_cfbd ;};_edaa =_geeb ;};_abfb :=_db .NewReader (_edaa );_efbg ,_ccae :=_fg .DecodeConfig (_abfb );if _ccae !=nil {_dba .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_ccae );
return nil ,_ccae ;};switch _efbg .ColorModel {case _c .RGBAModel :_ecbc .BitsPerComponent =8;_ecbc .ColorComponents =3;_ecbc .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0};case _c .RGBA64Model :_ecbc .BitsPerComponent =16;_ecbc .ColorComponents =3;_ecbc .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0};
case _c .GrayModel :_ecbc .BitsPerComponent =8;_ecbc .ColorComponents =1;_ecbc .Decode =[]float64 {0.0,1.0};case _c .Gray16Model :_ecbc .BitsPerComponent =16;_ecbc .ColorComponents =1;_ecbc .Decode =[]float64 {0.0,1.0};case _c .CMYKModel :_ecbc .BitsPerComponent =8;
_ecbc .ColorComponents =4;_ecbc .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0};case _c .YCbCrModel :_ecbc .BitsPerComponent =8;_ecbc .ColorComponents =3;_ecbc .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0};default:return nil ,_e .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");
};_ecbc .Width =_efbg .Width ;_ecbc .Height =_efbg .Height ;_dba .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_ecbc );_ecbc .Quality =DefaultJPEGQuality ;_gfaa ,_ebgb :=GetArray (_febg .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));
if _ebgb {_faa ,_fdgf :=_gfaa .ToFloat64Array ();if _fdgf !=nil {return _ecbc ,_fdgf ;};_ecbc .Decode =_faa ;};return _ecbc ,nil ;};

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _ge .Filter ,userPass ,ownerPass []byte ,perm _ef .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_abbd :=&PdfCrypt {_acc :make (map[PdfObject ]bool ),_da :make (cryptFilters ),_fbbg :_ef .StdEncryptDict {P :perm ,EncryptMetadata :true }};
var _cee Version ;if cf !=nil {_gff :=cf .PDFVersion ();_cee .Major ,_cee .Minor =_gff [0],_gff [1];V ,R :=cf .HandlerVersion ();_abbd ._bgc .V =V ;_abbd ._fbbg .R =R ;_abbd ._bgc .Length =cf .KeyLength ()*8;};const (_bgda =_ada ;);_abbd ._da [_bgda ]=cf ;
if _abbd ._bgc .V >=4{_abbd ._fdgg =_bgda ;_abbd ._gcag =_bgda ;};_aef :=_abbd .newEncryptDict ();_eca :=_ff .Sum ([]byte (_ac .Now ().Format (_ac .RFC850 )));_fdb :=string (_eca [:]);_bbb :=make ([]byte ,100);_ed .Read (_bbb );_eca =_ff .Sum (_bbb );_efaa :=string (_eca [:]);
_dba .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_bbb );_dba .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_fdb );_abbd ._gfd =_fdb ;_acag :=_abbd .generateParams (userPass ,ownerPass );
if _acag !=nil {return nil ,nil ,_acag ;};_gec (&_abbd ._fbbg ,_aef );if _abbd ._bgc .V >=4{if _fdg :=_abbd .saveCryptFilters (_aef );_fdg !=nil {return nil ,nil ,_fdg ;};};return _abbd ,&EncryptInfo {Version :_cee ,Encrypt :_aef ,ID0 :_fdb ,ID1 :_efaa },nil ;
};func (_dd *PdfParser )lookupObjectViaOS (_fcf int ,_ddg int )(PdfObject ,error ){var _aa *_db .Reader ;var _abe objectStream ;var _eg bool ;_abe ,_eg =_dd ._cbbf [_fcf ];if !_eg {_cd ,_ede :=_dd .LookupByNumber (_fcf );if _ede !=nil {_dba .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_fcf );
return nil ,_ede ;};_gg ,_cg :=_cd .(*PdfObjectStream );if !_cg {return nil ,_e .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _dd ._bfa !=nil &&!_dd ._bfa .isDecrypted (_gg ){return nil ,_e .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");
};_fa :=_gg .PdfObjectDictionary ;_dba .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_fa .String ());_ca ,_cg :=_fa .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_cg {_dba .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");
return nil ,_e .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _ga .ToLower (string (*_ca ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_dba .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");
return nil ,_e .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_cg :=_fa .Get ("\u004e").(*PdfObjectInteger );if !_cg {return nil ,_e .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");
};_gab ,_cg :=_fa .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_cg {return nil ,_e .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");
};_dba .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_ca ,*N );_gc ,_ede :=DecodeStream (_gg );if _ede !=nil {return nil ,_ede ;
};_dba .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_gc );_fd :=_dd .GetFileOffset ();defer func (){_dd .SetFileOffset (_fd )}();_aa =_db .NewReader (_gc );_dd ._cega =_beb .NewReader (_aa );_dba .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");
_bg :=map[int ]int64 {};for _ad :=0;_ad < int (*N );_ad ++{_dd .skipSpaces ();_fe ,_bf :=_dd .parseNumber ();if _bf !=nil {return nil ,_bf ;};_eb ,_gfe :=_fe .(*PdfObjectInteger );if !_gfe {return nil ,_e .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");
};_dd .skipSpaces ();_fe ,_bf =_dd .parseNumber ();if _bf !=nil {return nil ,_bf ;};_af ,_gfe :=_fe .(*PdfObjectInteger );if !_gfe {return nil ,_e .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");
};_dba .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_eb ,*_af );_bg [int (*_eb )]=int64 (*_gab +*_af );};_abe =objectStream {N :int (*N ),_ab :_gc ,_efa :_bg };_dd ._cbbf [_fcf ]=_abe ;}else {_ebe :=_dd .GetFileOffset ();
defer func (){_dd .SetFileOffset (_ebe )}();_aa =_db .NewReader (_abe ._ab );_dd ._cega =_beb .NewReader (_aa );};_ecf :=_abe ._efa [_ddg ];_dba .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_ddg ,_ecf );
_aa .Seek (_ecf ,_gd .SeekStart );_dd ._cega =_beb .NewReader (_aa );_abf ,_ :=_dd ._cega .Peek (100);_dba .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_abf ));_gae ,_fgb :=_dd .parseObject ();if _fgb !=nil {_dba .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_fgb );
return nil ,_fgb ;};if _gae ==nil {return nil ,_e .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");};_bgf :=PdfIndirectObject {};_bgf .ObjectNumber =int64 (_ddg );_bgf .PdfObject =_gae ;_bgf ._dcab =_dd ;
return &_bgf ,nil ;};var _gbbg =_b .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");

// UpdateParams updates the parameter values of the encoder.
func (_dgfa *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_decga *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_bbbd :=_decga .GetFileOffset ();_ ,_bbdf :=_decga ._eege .Seek (offset ,_gd .SeekStart );if _bbdf !=nil {return nil ,_bbdf ;};_cfgeg :=make ([]byte ,len );_ ,_bbdf =_gd .ReadAtLeast (_decga ._eege ,_cfgeg ,int (len ));
if _bbdf !=nil {return nil ,_bbdf ;};_decga .SetFileOffset (_bbbd );return _cfgeg ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_afbb *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_egdad :=MakeDict ();_egdad .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_afbb .GetFilterArray ());for _ ,_gceb :=range _afbb ._gfbdc {_bcaa :=_gceb .MakeStreamDict ();for _ ,_cbgb :=range _bcaa .Keys (){_dgffe :=_bcaa .Get (_cbgb );
if _cbgb !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_cbgb !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_egdad .Set (_cbgb ,_dgffe );};};};_ffaa :=_afbb .MakeDecodeParams ();if _ffaa !=nil {_egdad .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_ffaa );
};return _egdad ;};func (_dgfd *PdfCrypt )decryptBytes (_bea []byte ,_baff string ,_bgdac []byte )([]byte ,error ){_dba .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_fea ,_aabe :=_dgfd ._da [_baff ];if !_aabe {return nil ,_bb .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_baff );
};return _fea .DecryptBytes (_bea ,_bgdac );};func (_bdaa *ASCII85Encoder )base256Tobase85 (_bgb uint32 )[5]byte {_aece :=[5]byte {0,0,0,0,0};_badf :=_bgb ;for _dfcf :=0;_dfcf < 5;_dfcf ++{_gfde :=uint32 (1);for _aae :=0;_aae < 4-_dfcf ;_aae ++{_gfde *=85;
};_abag :=_badf /_gfde ;_badf =_badf %_gfde ;_aece [_dfcf ]=byte (_abag );};return _aece ;};func (_ebefc *PdfParser )parseArray ()(*PdfObjectArray ,error ){_fcec :=MakeArray ();_ebefc ._cega .ReadByte ();for {_ebefc .skipSpaces ();_abgf ,_abc :=_ebefc ._cega .Peek (1);
if _abc !=nil {return _fcec ,_abc ;};if _abgf [0]==']'{_ebefc ._cega .ReadByte ();break ;};_dbed ,_abc :=_ebefc .parseObject ();if _abc !=nil {return _fcec ,_abc ;};_fcec .Append (_dbed );};return _fcec ,nil ;};

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ceeg *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_faeg :=MakeDict ();_faeg .Set ("\u004b",MakeInteger (int64 (_ceeg .K )));_faeg .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_ceeg .Columns )));if _ceeg .BlackIs1 {_faeg .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_ceeg .BlackIs1 ));
};if _ceeg .EncodedByteAlign {_faeg .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_ceeg .EncodedByteAlign ));};if _ceeg .EndOfLine &&_ceeg .K >=0{_faeg .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_ceeg .EndOfLine ));
};if _ceeg .Rows !=0&&!_ceeg .EndOfBlock {_faeg .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_ceeg .Rows )));};if !_ceeg .EndOfBlock {_faeg .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_ceeg .EndOfBlock ));};if _ceeg .DamagedRowsBeforeError !=0{_faeg .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_ceeg .DamagedRowsBeforeError )));
};return _faeg ;};

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_eefaa :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_eefaa .PdfObjectDictionary =encoder .MakeStreamDict ();_ccaf ,_dadfg :=encoder .EncodeBytes (contents );
if _dadfg !=nil {return nil ,_dadfg ;};_eefaa .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_ccaf ))));_eefaa .Stream =_ccaf ;return _eefaa ,nil ;};

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_ccbe *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _ccbe .DecodeBytes (streamObj .Stream );};func (_fbbda *PdfParser )checkLinearizedInformation (_eegc *PdfObjectDictionary )(bool ,error ){var _gecd error ;
_fbbda ._gbeb ,_gecd =GetNumberAsInt64 (_eegc .Get ("\u004c"));if _gecd !=nil {return false ,_gecd ;};_gecd =_fbbda .seekToEOFMarker (_fbbda ._gbeb );switch _gecd {case nil :return true ,nil ;case _fegb :return false ,nil ;default:return false ,_gecd ;
};};

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_ddcg *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _faae []byte ;_dba .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_gcba :=0;_eaeb :=false ;for _gcba < len (encoded )&&!_eaeb {_dacg :=[5]byte {0,0,0,0,0};
_fccge :=0;_bgga :=0;_dbb :=4;for _bgga < 5+_fccge {if _gcba +_bgga ==len (encoded ){break ;};_cfae :=encoded [_gcba +_bgga ];if IsWhiteSpace (_cfae ){_fccge ++;_bgga ++;continue ;}else if _cfae =='~'&&_gcba +_bgga +1< len (encoded )&&encoded [_gcba +_bgga +1]=='>'{_dbb =(_bgga -_fccge )-1;
if _dbb < 0{_dbb =0;};_eaeb =true ;break ;}else if _cfae >='!'&&_cfae <='u'{_cfae -='!';}else if _cfae =='z'&&_bgga -_fccge ==0{_dbb =4;_bgga ++;break ;}else {_dba .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");
return nil ,_e .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_dacg [_bgga -_fccge ]=_cfae ;_bgga ++;};_gcba +=_bgga ;for _aaf :=_dbb +1;_aaf < 5;_aaf ++{_dacg [_aaf ]=84;
};_fgf :=uint32 (_dacg [0])*85*85*85*85+uint32 (_dacg [1])*85*85*85+uint32 (_dacg [2])*85*85+uint32 (_dacg [3])*85+uint32 (_dacg [4]);_daff :=[]byte {byte ((_fgf >>24)&0xff),byte ((_fgf >>16)&0xff),byte ((_fgf >>8)&0xff),byte (_fgf &0xff)};_faae =append (_faae ,_daff [:_dbb ]...);
};_dba .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_dba .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_faae );
return _faae ,nil ;};func _befa (_dbafb PdfObject )(*float64 ,error ){switch _bdgee :=_dbafb .(type ){case *PdfObjectFloat :_agdfg :=float64 (*_bdgee );return &_agdfg ,nil ;case *PdfObjectInteger :_ffcf :=float64 (*_bdgee );return &_ffcf ,nil ;case *PdfObjectNull :return nil ,nil ;
};return nil ,ErrNotANumber ;};

// MakeDictMap creates a PdfObjectDictionary initialized from a map of keys to values.
func MakeDictMap (objmap map[string ]PdfObject )*PdfObjectDictionary {_eabc :=MakeDict ();return _eabc .Update (objmap );};type offsetReader struct{_fcfb _gd .ReadSeeker ;_afef int64 ;};

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_dba .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_cad ,_febe :=NewEncoderFromStream (streamObj );if _febe !=nil {_dba .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_febe );
return nil ,_febe ;};_dba .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_cad );_ggcgf ,_febe :=_cad .DecodeStream (streamObj );if _febe !=nil {_dba .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_febe );
return nil ,_febe ;};return _ggcgf ,nil ;};func _fdbcg (_bcef ,_dfcc PdfObject ,_debb int )bool {if _debb > _abfa {_dba .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_abfa );
return false ;};if _bcef ==nil &&_dfcc ==nil {return true ;}else if _bcef ==nil ||_dfcc ==nil {return false ;};if _g .TypeOf (_bcef )!=_g .TypeOf (_dfcc ){return false ;};switch _debde :=_bcef .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;
case *PdfObjectName :return *_debde ==*(_dfcc .(*PdfObjectName ));case *PdfObjectString :return *_debde ==*(_dfcc .(*PdfObjectString ));case *PdfObjectInteger :return *_debde ==*(_dfcc .(*PdfObjectInteger ));case *PdfObjectBool :return *_debde ==*(_dfcc .(*PdfObjectBool ));
case *PdfObjectFloat :return *_debde ==*(_dfcc .(*PdfObjectFloat ));case *PdfIndirectObject :return _fdbcg (TraceToDirectObject (_bcef ),TraceToDirectObject (_dfcc ),_debb +1);case *PdfObjectArray :_eeea :=_dfcc .(*PdfObjectArray );if len ((*_debde )._ebb )!=len ((*_eeea )._ebb ){return false ;
};for _cacb ,_bcea :=range (*_debde )._ebb {if !_fdbcg (_bcea ,(*_eeea )._ebb [_cacb ],_debb +1){return false ;};};return true ;case *PdfObjectDictionary :_ddbca :=_dfcc .(*PdfObjectDictionary );_degb ,_gdfc :=(*_debde )._bbfc ,(*_ddbca )._bbfc ;if len (_degb )!=len (_gdfc ){return false ;
};for _ddbda ,_efbgc :=range _degb {_agfe ,_eafd :=_gdfc [_ddbda ];if !_eafd ||!_fdbcg (_efbgc ,_agfe ,_debb +1){return false ;};};return true ;case *PdfObjectStream :_fcgb :=_dfcc .(*PdfObjectStream );return _fdbcg ((*_debde ).PdfObjectDictionary ,(*_fcgb ).PdfObjectDictionary ,_debb +1);
default:_dba .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_bcef );
};return false ;};var _efeg =_b .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");func (_dfca *PdfCrypt )checkAccessRights (_afg []byte )(bool ,_ef .Permissions ,error ){_ccec :=_dfca .securityHandler ();
_efb ,_gbe ,_cde :=_ccec .Authenticate (&_dfca ._fbbg ,_afg );if _cde !=nil {return false ,0,_cde ;}else if _gbe ==0||len (_efb )==0{return false ,0,nil ;};return true ,_gbe ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_cdce *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_caab ,_fdcg :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _fdcg ==nil {_cdce .Predictor =int (_caab );};_dcfb ,_fdcg :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));
if _fdcg ==nil {_cdce .BitsPerComponent =int (_dcfb );};_agce ,_fdcg :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _fdcg ==nil {_cdce .Columns =int (_agce );};_cdfb ,_fdcg :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));
if _fdcg ==nil {_cdce .Colors =int (_cdfb );};_fagg ,_fdcg :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _fdcg ==nil {_cdce .EarlyChange =int (_fagg );};};

// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_gdbge *PdfObjectDictionary ,_bgccc bool ){_gdbge ,_bgccc =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _gdbge ,_bgccc ;};func (_cgf *PdfCrypt )saveCryptFilters (_ccc *PdfObjectDictionary )error {if _cgf ._bgc .V < 4{return _e .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");
};_agc :=MakeDict ();_ccc .Set ("\u0043\u0046",_agc );for _cfg ,_cag :=range _cgf ._da {if _cfg =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_edba :=_gfb (_cag ,"");_agc .Set (PdfObjectName (_cfg ),_edba );};_ccc .Set ("\u0053\u0074\u0072\u0046",MakeName (_cgf ._gcag ));
_ccc .Set ("\u0053\u0074\u006d\u0046",MakeName (_cgf ._fdgg ));return nil ;};var _fdccg =_b .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");


// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_dbba []byte ,_cecb bool ){_gbgeg ,_cecb :=TraceToDirectObject (obj ).(*PdfObjectString );if _cecb {return _gbgeg .Bytes (),true ;};return ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_aee *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_dcab *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};

// Len returns the number of elements in the array.
func (_fbce *PdfObjectArray )Len ()int {if _fbce ==nil {return 0;};return len (_fbce ._ebb );};

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;Decode []float64 ;};

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_ecge *_df .Document ;

// Globals are the JBIG2 global segments.
Globals _gf .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};func (_ceab *PdfParser )parsePdfVersion ()(int ,int ,error ){var _fbge int64 =20;_gadaf :=make ([]byte ,_fbge );_ceab ._eege .Seek (0,_gd .SeekStart );_ceab ._eege .Read (_gadaf );var _afaf error ;var _fbbd ,_afgc int ;
if _cgcb :=_ccdf .FindStringSubmatch (string (_gadaf ));len (_cgcb )< 3{if _fbbd ,_afgc ,_afaf =_ceab .seekPdfVersionTopDown ();_afaf !=nil {_dba .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");
return 0,0,_afaf ;};_ceab ._eege ,_afaf =_faad (_ceab ._eege ,_ceab .GetFileOffset ()-8);if _afaf !=nil {return 0,0,_afaf ;};}else {if _fbbd ,_afaf =_ecd .Atoi (_cgcb [1]);_afaf !=nil {return 0,0,_afaf ;};if _afgc ,_afaf =_ecd .Atoi (_cgcb [2]);_afaf !=nil {return 0,0,_afaf ;
};_ceab .SetFileOffset (0);};_ceab ._cega =_beb .NewReader (_ceab ._eege );_dba .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_fbbd ,_afgc );return _fbbd ,_afgc ,nil ;};

// HasInvalidSubsectionHeader implements core.ParserMetadata interface.
func (_ebg ParserMetadata )HasInvalidSubsectionHeader ()bool {return _ebg ._fda };

// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_fcgc :=PdfObjectString {_gffd :s };return &_fcgc };func _gbd (_aad *PdfObjectStream ,_bgff *PdfObjectDictionary )(*FlateEncoder ,error ){_geb :=NewFlateEncoder ();_fed :=_aad .PdfObjectDictionary ;if _fed ==nil {return _geb ,nil ;
};_geb ._fcfc =_eeceg (_fed );if _bgff ==nil {_dcf :=TraceToDirectObject (_fed .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));switch _eeb :=_dcf .(type ){case *PdfObjectArray :if _eeb .Len ()!=1{_dba .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_eeb .Len ());
return nil ,_e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _efdd ,_cgfe :=GetDict (_eeb .Get (0));_cgfe {_bgff =_efdd ;};case *PdfObjectDictionary :_bgff =_eeb ;case *PdfObjectNull ,nil :default:_dba .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_dcf );
return nil ,_bb .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _bgff ==nil {return _geb ,nil ;};_dba .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_bgff .String ());
_cfge :=_bgff .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _cfge ==nil {_dba .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");
}else {_bdb ,_aagg :=_cfge .(*PdfObjectInteger );if !_aagg {_dba .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_cfge );
return nil ,_bb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_geb .Predictor =int (*_bdb );};_cfge =_bgff .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
if _cfge !=nil {_fcaa ,_adag :=_cfge .(*PdfObjectInteger );if !_adag {_dba .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
return nil ,_bb .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_geb .BitsPerComponent =int (*_fcaa );};if _geb .Predictor > 1{_geb .Columns =1;_cfge =_bgff .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");
if _cfge !=nil {_ceeea ,_cfc :=_cfge .(*PdfObjectInteger );if !_cfc {return nil ,_bb .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_geb .Columns =int (*_ceeea );
};_geb .Colors =1;_cfge =_bgff .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _cfge !=nil {_gdfg ,_cced :=_cfge .(*PdfObjectInteger );if !_cced {return nil ,_bb .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");
};_geb .Colors =int (*_gdfg );};};return _geb ,nil ;};

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_bgea *MultiEncoder )GetFilterArray ()*PdfObjectArray {_bgcgc :=make ([]PdfObject ,len (_bgea ._gfbdc ));for _begg ,_fdcc :=range _bgea ._gfbdc {_bgcgc [_begg ]=MakeName (_fdcc .GetFilterName ());};return MakeArray (_bgcgc ...);};

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){switch _fadg :=obj .(type ){case *PdfObjectFloat :_dba .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");
return int64 (*_fadg ),nil ;case *PdfObjectInteger :return int64 (*_fadg ),nil ;case *PdfObjectReference :_badd :=TraceToDirectObject (obj );return GetNumberAsInt64 (_badd );case *PdfIndirectObject :return GetNumberAsInt64 (_fadg .PdfObject );};return 0,ErrNotANumber ;
};

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_bcbfe *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_dba .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_bcbfe .GetFilterName ());
return encoded ,ErrNoJPXDecode ;};

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _gccee (obj ,0)};

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_aafa *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _aafa .DecodeBytes (streamObj .Stream );};

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {return &PdfObjectArray {_ebb :objects }};func (_bgec *JBIG2Encoder )encodeImage (_defe _ea .Image )([]byte ,error ){const _begc ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";_gdcbg ,_fegg :=GoImageToJBIG2 (_defe ,JB2ImageAutoThreshold );
if _fegg !=nil {return nil ,_fc .Wrap (_fegg ,_begc ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");};if _fegg =_bgec .AddPageImage (_gdcbg ,&_bgec .DefaultPageSettings );
_fegg !=nil {return nil ,_fc .Wrap (_fegg ,_begc ,"");};return _bgec .Encode ();};func _cdf (_gbc PdfObject )(int64 ,int64 ,error ){if _aba ,_bfe :=_gbc .(*PdfIndirectObject );_bfe {return _aba .ObjectNumber ,_aba .GenerationNumber ,nil ;};if _dcd ,_bd :=_gbc .(*PdfObjectStream );
_bd {return _dcd .ObjectNumber ,_dcd .GenerationNumber ,nil ;};return 0,0,_e .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");};

// String returns a string describing `streams`.
func (_daddf *PdfObjectStreams )String ()string {return _bb .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_daddf .ObjectNumber );};

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;func _gfb (_fab _ge .Filter ,_cgag _ef .AuthEvent )*PdfObjectDictionary {if _cgag ==""{_cgag =_ef .EventDocOpen ;};_edef :=MakeDict ();_edef .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));
_edef .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_cgag )));_edef .Set ("\u0043\u0046\u004d",MakeName (_fab .Name ()));_edef .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_fab .KeyLength ())));return _edef ;
};

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_gead *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_ddedf :=data ;var _gbcd error ;for _aace :=len (_gead ._gfbdc )-1;_aace >=0;_aace --{_fbcc :=_gead ._gfbdc [_aace ];_ddedf ,_gbcd =_fbcc .EncodeBytes (_ddedf );if _gbcd !=nil {return nil ,_gbcd ;
};};return _ddedf ,nil ;};type xrefType int ;

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_beb .Reader )(PdfObject ,error ){_effed :=false ;_cfdbd :=true ;var _fbeeb _db .Buffer ;for {if _dba .Log .IsLogLevel (_dba .LogLevelTrace ){_dba .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_fbeeb .String ());
};_bbeg ,_gefb :=buf .Peek (1);if _gefb ==_gd .EOF {break ;};if _gefb !=nil {_dba .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_gefb );return nil ,_gefb ;};if _cfdbd &&(_bbeg [0]=='-'||_bbeg [0]=='+'){_caga ,_ :=buf .ReadByte ();_fbeeb .WriteByte (_caga );
_cfdbd =false ;}else if IsDecimalDigit (_bbeg [0]){_cddd ,_ :=buf .ReadByte ();_fbeeb .WriteByte (_cddd );}else if _bbeg [0]=='.'{_eabf ,_ :=buf .ReadByte ();_fbeeb .WriteByte (_eabf );_effed =true ;}else if _bbeg [0]=='e'||_bbeg [0]=='E'{_caedg ,_ :=buf .ReadByte ();
_fbeeb .WriteByte (_caedg );_effed =true ;_cfdbd =true ;}else {break ;};};var _geee PdfObject ;if _effed {_cegf ,_bbaf :=_ecd .ParseFloat (_fbeeb .String (),64);if _bbaf !=nil {_dba .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_fbeeb .String (),_bbaf );
_cegf =0.0;};_gcadbf :=PdfObjectFloat (_cegf );_geee =&_gcadbf ;}else {_fgga ,_fddb :=_ecd .ParseInt (_fbeeb .String (),10,64);if _fddb !=nil {_dba .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_fbeeb .String (),_fddb );
_fgga =0;};_abfed :=PdfObjectInteger (_fgga );_geee =&_abfed ;};return _geee ,nil ;};

// Update updates multiple keys and returns the dictionary back so can be used in a chained fashion.
func (_aeaa *PdfObjectDictionary )Update (objmap map[string ]PdfObject )*PdfObjectDictionary {_aeaa ._addd .Lock ();defer _aeaa ._addd .Unlock ();for _adbbb ,_cefd :=range objmap {_aeaa .setWithLock (PdfObjectName (_adbbb ),_cefd ,false );};return _aeaa ;
};func (_fbb *PdfParser )lookupByNumberWrapper (_ggb int ,_gb bool )(PdfObject ,bool ,error ){_efc ,_def ,_bc :=_fbb .lookupByNumber (_ggb ,_gb );if _bc !=nil {return nil ,_def ,_bc ;};if !_def &&_fbb ._bfa !=nil &&_fbb ._bfa ._cgb &&!_fbb ._bfa .isDecrypted (_efc ){_cdd :=_fbb ._bfa .Decrypt (_efc ,0,0);
if _cdd !=nil {return nil ,_def ,_cdd ;};};return _efc ,_def ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cggag *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_cead :=&LZWEncoder {};_cead .Predictor =1;_cead .BitsPerComponent =8;_cead .Colors =1;_cead .Columns =1;_cead .EarlyChange =1;return _cead ;};func _gddf (_cceg ,_cfgg ,_dab uint8 )uint8 {_gdbg :=int (_dab );_dege :=int (_cfgg )-_gdbg ;
_bgbf :=int (_cceg )-_gdbg ;_gdbg =_bfga (_dege +_bgbf );_dege =_bfga (_dege );_bgbf =_bfga (_bgbf );if _dege <=_bgbf &&_dege <=_gdbg {return _cceg ;}else if _bgbf <=_gdbg {return _cfgg ;};return _dab ;};

// ParserMetadata is the parser based metadata information about document.
// The data here could be used on document verification.
type ParserMetadata struct{_feb int ;_bcgg bool ;_ded [4]byte ;_ccd bool ;_eaeg bool ;_fccc bool ;_cccb bool ;_fda bool ;_edd bool ;};const _abfa =10;

// UpdateParams updates the parameter values of the encoder.
func (_feaee *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};

// GetEncryptObj returns the PdfIndirectObject which has information about the PDFs encryption details.
func (_acad *PdfParser )GetEncryptObj ()*PdfIndirectObject {return _acad ._gfcc };

// WriteString outputs the object as it is to be written to file.
func (_fbgc *PdfObjectStream )WriteString ()string {var _aead _ga .Builder ;_aead .WriteString (_ecd .FormatInt (_fbgc .ObjectNumber ,10));_aead .WriteString ("\u0020\u0030\u0020\u0052");return _aead .String ();};const (DefaultJPEGQuality =75;);func (_fca *PdfCrypt )securityHandler ()_ef .StdHandler {if _fca ._fbbg .R >=5{return _ef .NewHandlerR6 ();
};return _ef .NewHandlerR4 (_fca ._gfd ,_fca ._bgc .Length );};func _faad (_afca _gd .ReadSeeker ,_cegg int64 )(*offsetReader ,error ){_ggbgd :=&offsetReader {_fcfb :_afca ,_afef :_cegg };_ ,_beba :=_ggbgd .Seek (0,_gd .SeekStart );return _ggbgd ,_beba ;
};

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_dgge *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _dgge .Predictor !=1{return nil ,_bb .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");
};if _dgge .EarlyChange ==1{return nil ,_bb .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");
};var _gaa _db .Buffer ;_eacf :=_be .NewWriter (&_gaa ,_be .MSB ,8);_eacf .Write (data );_eacf .Close ();return _gaa .Bytes (),nil ;};

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _afab _db .Buffer ;_afab .Write ([]byte {0xFE,0xFF});_afab .WriteString (_dgc .StringToUTF16 (s ));return &PdfObjectString {_gffd :_afab .String (),_fecf :true };};return &PdfObjectString {_gffd :string (_dgc .StringToPDFDocEncoding (s )),_fecf :false };
};

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_ebb []PdfObject };func (_dcad *PdfParser )skipSpaces ()(int ,error ){_efde :=0;for {_faab ,_eebf :=_dcad ._cega .ReadByte ();if _eebf !=nil {return 0,_eebf ;};if IsWhiteSpace (_faab ){_efde ++;}else {_dcad ._cega .UnreadByte ();
break ;};};return _efde ,nil ;};func (_gee *PdfParser )lookupByNumber (_cfd int ,_fef bool )(PdfObject ,bool ,error ){_ecdf ,_aab :=_gee .ObjCache [_cfd ];if _aab {_dba .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_cfd );
return _ecdf ,false ,nil ;};if _gee ._dged ==nil {_gee ._dged =map[int ]bool {};};if _gee ._dged [_cfd ]{_dba .Log .Debug ("ER\u0052\u004f\u0052\u003a\u0020\u004c\u006fok\u0075\u0070\u0020\u006f\u0066\u0020\u0025\u0064\u0020\u0069\u0073\u0020\u0061\u006c\u0072e\u0061\u0064\u0079\u0020\u0069\u006e\u0020\u0070\u0072\u006f\u0067\u0072\u0065\u0073\u0073\u0020\u002d\u0020\u0072\u0065c\u0075\u0072\u0073\u0069\u0076\u0065 \u006c\u006f\u006f\u006b\u0075\u0070\u0020\u0061\u0074t\u0065m\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064",_cfd );
return nil ,false ,_e .New ("\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006f\u006f\u006b\u0075p\u0020a\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064");};_gee ._dged [_cfd ]=true ;defer delete (_gee ._dged ,_cfd );
_abb ,_aab :=_gee ._bbbaa .ObjectMap [_cfd ];if !_aab {_dba .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
var _cdc PdfObjectNull ;return &_cdc ,false ,nil ;};_dba .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_cfd );if _abb .XType ==XrefTypeTableEntry {_dba .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_abb .ObjectNumber );
_dba .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_abb .Generation );_dba .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_abb .Offset );
_gee ._eege .Seek (_abb .Offset ,_gd .SeekStart );_gee ._cega =_beb .NewReader (_gee ._eege );_gcb ,_ega :=_gee .ParseIndirectObject ();if _ega !=nil {_dba .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_ega );
if _fef {_dba .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_ggd ,_eae :=_gee .repairRebuildXrefsTopDown ();
if _eae !=nil {_dba .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_eae );return nil ,false ,_eae ;};_gee ._bbbaa =*_ggd ;return _gee .lookupByNumber (_cfd ,false );
};return nil ,false ,_ega ;};if _fef {_bgd ,_ ,_ :=_cdf (_gcb );if int (_bgd )!=_cfd {_dba .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_eaf :=_gee .rebuildXrefTable ();
if _eaf !=nil {return nil ,false ,_eaf ;};_gee .ObjCache =objectCache {};return _gee .lookupByNumberWrapper (_cfd ,false );};};_dba .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_gee .ObjCache [_cfd ]=_gcb ;
return _gcb ,false ,nil ;}else if _abb .XType ==XrefTypeObjectStream {_dba .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_dba .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");
_dba .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_abb .OsObjNumber ,_abb .OsObjIndex );
if _abb .OsObjNumber ==_cfd {_dba .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_e .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");
};if _ ,_gca :=_gee ._bbbaa .ObjectMap [_abb .OsObjNumber ];_gca {_ddb ,_bbe :=_gee .lookupObjectViaOS (_abb .OsObjNumber ,_cfd );if _bbe !=nil {_dba .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_bbe );
return nil ,true ,_bbe ;};_dba .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_gee .ObjCache [_cfd ]=_ddb ;if _gee ._bfa !=nil {_gee ._bfa ._gbf [_ddb ]=true ;};return _ddb ,true ,nil ;};_dba .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");
return nil ,true ,_e .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
};return nil ,false ,_e .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};

// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _fdbcg (obj1 ,obj2 ,0)};

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_fdec *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _cgc _db .Buffer ;_dfba :=_db .NewReader (encoded );var _aggb _gd .ReadCloser ;if _fdec .EarlyChange ==1{_aggb =_bed .NewReader (_dfba ,_bed .MSB ,8);}else {_aggb =_be .NewReader (_dfba ,_be .MSB ,8);
};defer _aggb .Close ();if _ ,_ege :=_cgc .ReadFrom (_aggb );_ege !=nil {if _ege !=_gd .ErrUnexpectedEOF ||_cgc .Len ()==0{return nil ,_ege ;};_dba .Log .Debug ("\u0057\u0041\u0052\u004e\u003a\u0020\u004c\u005a\u0057\u0020\u0064\u0065\u0063\u006f\u0064i\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076\u002e \u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062e \u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_ege );
};return _cgc .Bytes (),nil ;};

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_geddf *JBIG2Image )ToGoImage ()(_ea .Image ,error ){const _eea ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _geddf .Data ==nil {return nil ,_fc .Error (_eea ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");
};if _geddf .Width ==0||_geddf .Height ==0{return nil ,_fc .Error (_eea ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");
};_ebeb ,_cedg :=_gdf .NewImage (_geddf .Width ,_geddf .Height ,1,1,_geddf .Data ,nil ,nil );if _cedg !=nil {return nil ,_cedg ;};return _ebeb ,nil ;};

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
//	renamed to String() as a pretty string to use in debugging etc.
func (_fdgdb *MultiEncoder )GetFilterName ()string {_dbgg :="";for _aeee ,_bgdb :=range _fdgdb ._gfbdc {_dbgg +=_bgdb .GetFilterName ();if _aeee < len (_fdgdb ._gfbdc )-1{_dbgg +="\u0020";};};return _dbgg ;};

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_cgff *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _cage :=val .(type ){case *PdfObjectName :if _cage !=nil {_cgff .Set (key ,val );};case *PdfObjectDictionary :if _cage !=nil {_cgff .Set (key ,val );
};case *PdfObjectStream :if _cage !=nil {_cgff .Set (key ,val );};case *PdfObjectString :if _cage !=nil {_cgff .Set (key ,val );};case *PdfObjectNull :if _cage !=nil {_cgff .Set (key ,val );};case *PdfObjectInteger :if _cage !=nil {_cgff .Set (key ,val );
};case *PdfObjectArray :if _cage !=nil {_cgff .Set (key ,val );};case *PdfObjectBool :if _cage !=nil {_cgff .Set (key ,val );};case *PdfObjectFloat :if _cage !=nil {_cgff .Set (key ,val );};case *PdfObjectReference :if _cage !=nil {_cgff .Set (key ,val );
};case *PdfIndirectObject :if _cage !=nil {_cgff .Set (key ,val );};default:_dba .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );
};};};

// GetRevisionNumber returns the current version of the Pdf document.
func (_abcf *PdfParser )GetRevisionNumber ()int {return _abcf ._aaggc };

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};func _gbdc (_fdafd _gdf .Image )*JBIG2Image {_cbgd :=_fdafd .Base ();return &JBIG2Image {Data :_cbgd .Data ,Width :_cbgd .Width ,Height :_cbgd .Height ,HasPadding :true };};

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_edf []XrefObject ;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_ebc *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_ddef :=_db .NewReader (data );var _afb []byte ;var _cfed []byte ;_eagd ,_dafe :=_ddef .ReadByte ();if _dafe ==_gd .EOF {return []byte {},nil ;}else if _dafe !=nil {return nil ,_dafe ;
};_bbca :=1;for {_eefc ,_gbea :=_ddef .ReadByte ();if _gbea ==_gd .EOF {break ;}else if _gbea !=nil {return nil ,_gbea ;};if _eefc ==_eagd {if len (_cfed )> 0{_cfed =_cfed [:len (_cfed )-1];if len (_cfed )> 0{_afb =append (_afb ,byte (len (_cfed )-1));
_afb =append (_afb ,_cfed ...);};_bbca =1;_cfed =[]byte {};};_bbca ++;if _bbca >=127{_afb =append (_afb ,byte (257-_bbca ),_eagd );_bbca =0;};}else {if _bbca > 0{if _bbca ==1{_cfed =[]byte {_eagd };}else {_afb =append (_afb ,byte (257-_bbca ),_eagd );};
_bbca =0;};_cfed =append (_cfed ,_eefc );if len (_cfed )>=127{_afb =append (_afb ,byte (len (_cfed )-1));_afb =append (_afb ,_cfed ...);_cfed =[]byte {};};};_eagd =_eefc ;};if len (_cfed )> 0{_afb =append (_afb ,byte (len (_cfed )-1));_afb =append (_afb ,_cfed ...);
}else if _bbca > 0{_afb =append (_afb ,byte (257-_bbca ),_eagd );};_afb =append (_afb ,128);return _afb ,nil ;};func (_gadb *PdfCrypt )authenticate (_cea []byte )(bool ,error ){_gadb ._cgb =false ;_adb :=_gadb .securityHandler ();_egd ,_ece ,_gcca :=_adb .Authenticate (&_gadb ._fbbg ,_cea );
if _gcca !=nil {return false ,_gcca ;}else if _ece ==0||len (_egd )==0{return false ,nil ;};_gadb ._cgb =true ;_gadb ._ead =_egd ;return true ,nil ;};

// EncodeBytes encodes data into ASCII85 encoded format.
func (_acba *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _gcge _db .Buffer ;for _aaa :=0;_aaa < len (data );_aaa +=4{_faac :=data [_aaa ];_agb :=1;_gbgfd :=byte (0);if _aaa +1< len (data ){_gbgfd =data [_aaa +1];_agb ++;};_fcdf :=byte (0);
if _aaa +2< len (data ){_fcdf =data [_aaa +2];_agb ++;};_egdc :=byte (0);if _aaa +3< len (data ){_egdc =data [_aaa +3];_agb ++;};_dfbd :=(uint32 (_faac )<<24)|(uint32 (_gbgfd )<<16)|(uint32 (_fcdf )<<8)|uint32 (_egdc );if _dfbd ==0{_gcge .WriteByte ('z');
}else {_aage :=_acba .base256Tobase85 (_dfbd );for _ ,_fbbb :=range _aage [:_agb +1]{_gcge .WriteByte (_fbbb +'!');};};};_gcge .WriteString ("\u007e\u003e");return _gcge .Bytes (),nil ;};

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_efgbe *PdfParser )GetFileOffset ()int64 {_ffgega ,_ :=_efgbe ._eege .Seek (0,_gd .SeekCurrent );_ffgega -=int64 (_efgbe ._cega .Buffered ());return _ffgega ;};func _cgg (_efg int )cryptFilters {return cryptFilters {_ada :_ge .NewFilterV2 (_efg )}};


// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_dgad *PdfParser )GetObjectNums ()[]int {var _edeaf []int ;for _ ,_bgecc :=range _dgad ._bbbaa .ObjectMap {_edeaf =append (_edeaf ,_bgecc .ObjectNumber );};_a .Ints (_edeaf );return _edeaf ;};func (_cdcb *FlateEncoder )postDecodePredict (_cagc []byte )([]byte ,error ){if _cdcb .Predictor > 1{if _cdcb .Predictor ==2{_dba .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_dba .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_cdcb .Colors );_dega :=_cdcb .Columns *_cdcb .Colors ;if _dega < 1{return []byte {},nil ;};_dggd :=len (_cagc )/_dega ;if len (_cagc )%_dega !=0{_dba .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");
return nil ,_bb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_cagc ),_dega );};if _dega %_cdcb .Colors !=0{return nil ,_bb .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_dega ,_cdcb .Colors );
};if _dega > len (_cagc ){_dba .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_dega ,len (_cagc ));
return nil ,_e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_dba .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_cagc ),_cagc );
_bafff :=_db .NewBuffer (nil );for _afa :=0;_afa < _dggd ;_afa ++{_egadf :=_cagc [_dega *_afa :_dega *(_afa +1)];for _cfdc :=_cdcb .Colors ;_cfdc < _dega ;_cfdc ++{_egadf [_cfdc ]+=_egadf [_cfdc -_cdcb .Colors ];};_bafff .Write (_egadf );};_gagg :=_bafff .Bytes ();
_dba .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_gagg ),_gagg );return _gagg ,nil ;}else if _cdcb .Predictor >=10&&_cdcb .Predictor <=15{_dba .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_gada :=_cdcb .Columns *_cdcb .Colors +1;_afaa :=len (_cagc )/_gada ;if len (_cagc )%_gada !=0{return nil ,_bb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_cagc ),_gada );
};if _gada > len (_cagc ){_dba .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_gada ,len (_cagc ));
return nil ,_e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_cfaf :=_db .NewBuffer (nil );_dba .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_cdcb .Columns );
_dba .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_cagc ),_gada ,_afaa );_abdg :=make ([]byte ,_gada );for _eab :=0;_eab < _gada ;_eab ++{_abdg [_eab ]=0;};
_eabd :=_cdcb .Colors ;for _aabb :=0;_aabb < _afaa ;_aabb ++{_fdfd :=_cagc [_gada *_aabb :_gada *(_aabb +1)];_fcd :=_fdfd [0];switch _fcd {case _bdf :case _gfdf :for _bdcda :=1+_eabd ;_bdcda < _gada ;_bdcda ++{_fdfd [_bdcda ]+=_fdfd [_bdcda -_eabd ];};
case _dfd :for _bcgc :=1;_bcgc < _gada ;_bcgc ++{_fdfd [_bcgc ]+=_abdg [_bcgc ];};case _cgbb :for _ccf :=1;_ccf < _eabd +1;_ccf ++{_fdfd [_ccf ]+=_abdg [_ccf ]/2;};for _ccb :=_eabd +1;_ccb < _gada ;_ccb ++{_fdfd [_ccb ]+=byte ((int (_fdfd [_ccb -_eabd ])+int (_abdg [_ccb ]))/2);
};case _decf :for _cged :=1;_cged < _gada ;_cged ++{var _ffgeg ,_fedb ,_baeg byte ;_fedb =_abdg [_cged ];if _cged >=_eabd +1{_ffgeg =_fdfd [_cged -_eabd ];_baeg =_abdg [_cged -_eabd ];};_fdfd [_cged ]+=_gddf (_ffgeg ,_fedb ,_baeg );};default:_dba .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_fcd ,_aabb );
return nil ,_bb .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_fcd );};copy (_abdg ,_fdfd );_cfaf .Write (_fdfd [1:]);};_cba :=_cfaf .Bytes ();return _cba ,nil ;
}else {_dba .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_cdcb .Predictor );return nil ,_bb .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_cdcb .Predictor );
};};return _cagc ,nil ;};

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_fbdf :=MakeArray ();for _ ,_cefca :=range vals {_fbdf .Append (MakeFloat (_cefca ));};return _fbdf ;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_aadb *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _aadb .Predictor !=1&&_aadb .Predictor !=11{_dba .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");
return nil ,ErrUnsupportedEncodingParameters ;};if _aadb .Predictor ==11{_eefg :=_aadb .Columns ;_acee :=len (data )/_eefg ;if len (data )%_eefg !=0{_dba .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");
return nil ,_e .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_gfbd :=_db .NewBuffer (nil );_eccd :=make ([]byte ,_eefg );for _acgg :=0;_acgg < _acee ;_acgg ++{_dcc :=data [_eefg *_acgg :_eefg *(_acgg +1)];
_eccd [0]=_dcc [0];for _cbae :=1;_cbae < _eefg ;_cbae ++{_eccd [_cbae ]=byte (int (_dcc [_cbae ]-_dcc [_cbae -1])%256);};_gfbd .WriteByte (1);_gfbd .Write (_eccd );};data =_gfbd .Bytes ();};var _cefb _db .Buffer ;_baeb :=_dg .NewWriter (&_cefb );_baeb .Write (data );
_baeb .Close ();return _cefb .Bytes (),nil ;};const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);func (_cagb *PdfParser )traceStreamLength (_ecfgg PdfObject )(PdfObject ,error ){_cgcee ,_febd :=_ecfgg .(*PdfObjectReference );
if _febd {_gfcgd ,_caea :=_cagb ._egef [_cgcee .ObjectNumber ];if _caea &&_gfcgd {_dba .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");
return nil ,_e .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_cagb ._egef [_cgcee .ObjectNumber ]=true ;};_dgbg ,_cgegd :=_cagb .Resolve (_ecfgg );if _cgegd !=nil {return nil ,_cgegd ;
};_dba .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_dgbg );if _febd {_cagb ._egef [_cgcee .ObjectNumber ]=false ;};return _dgbg ,nil ;};

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_cgec *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_dba .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_cgec .GetFilterName ());
return streamObj .Stream ,ErrNoJPXDecode ;};

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};func (_fafa *PdfCrypt )encryptBytes (_caa []byte ,_dfbf string ,_dbaf []byte )([]byte ,error ){_dba .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_acf ,_bbdc :=_fafa ._da [_dfbf ];
if !_bbdc {return nil ,_bb .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_dfbf );};return _acf .EncryptBytes (_caa ,_dbaf );};func _fcgca ()string {return _dba .Version };


// Append appends PdfObject(s) to the streams.
func (_cacca *PdfObjectStreams )Append (objects ...PdfObject ){if _cacca ==nil {_dba .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");
return ;};_cacca ._cfdd =append (_cacca ._cfdd ,objects ...);};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_eccbf *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_adef :=PdfObjectNull {};return &_adef };

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;};func (_fba *PdfCrypt )generateParams (_bbec ,_cae []byte )error {_bcfb :=_fba .securityHandler ();_beg ,_beca :=_bcfb .GenerateParams (&_fba ._fbbg ,_cae ,_bbec );if _beca !=nil {return _beca ;
};_fba ._ead =_beg ;return nil ;};type limitedReadSeeker struct{_agfcb _gd .ReadSeeker ;_dceb int64 ;};var _abda =_b .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");