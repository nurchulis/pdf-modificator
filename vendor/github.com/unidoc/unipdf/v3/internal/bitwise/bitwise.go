//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_bc "encoding/binary";_dc "errors";_b "fmt";_f "github.com/unidoc/unipdf/v3/common";_e "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_d "io";);var _ BinaryWriter =&BufferedWriter {};var _ _d .ByteWriter =&BufferedWriter {};
func (_caa *BufferedWriter )grow (_abfg int ){if _caa ._c ==nil &&_abfg < _eb {_caa ._c =make ([]byte ,_abfg ,_eb );return ;};_ed :=len (_caa ._c );if _caa ._eba !=0{_ed ++;};_dd :=cap (_caa ._c );switch {case _abfg <=_dd /2-_ed :_f .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_caa ._c ),cap (_caa ._c ),_abfg );
_f .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_dd ,_ed );copy (_caa ._c ,_caa ._c [_caa .fullOffset ():]);
case _dd > _eg -_dd -_abfg :_f .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_abc :=make ([]byte ,2*_dd +_abfg );copy (_abc ,_caa ._c );_caa ._c =_abc ;};_caa ._c =_caa ._c [:_ed +_abfg ];
};func (_dcbg *Reader )readUnalignedByte ()(_ad byte ,_ebae error ){_fgd :=_dcbg ._cce ;_ad =_dcbg ._bcb <<(8-_fgd );_dcbg ._bcb ,_ebae =_dcbg .readBufferByte ();if _ebae !=nil {return 0,_ebae ;};_ad |=_dcbg ._bcb >>_fgd ;_dcbg ._bcb &=1<<_fgd -1;return _ad ,nil ;
};func (_fgb *Reader )Mark (){_fgb ._ecb =_fgb ._cb ;_fgb ._dga =_fgb ._cce ;_fgb ._ecd =_fgb ._bcb ;_fgb ._ead =_fgb ._fb ;};func (_dca *BufferedWriter )Len ()int {return _dca .byteCapacity ()};type BufferedWriter struct{_c []byte ;_eba uint8 ;_dcc int ;
_fa bool ;};func (_acg *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _acg ._cce !=0{return _acg .ReadBits (_acg ._cce );};return 0,nil ;};func (_ebb *BufferedWriter )expandIfNeeded (_bf int ){if !_ebb .tryGrowByReslice (_bf ){_ebb .grow (_bf );};
};func (_bfd *BufferedWriter )writeShiftedBytes (_ede []byte )int {for _ ,_gd :=range _ede {_bfd .writeByte (_gd );};return len (_ede );};var _ _d .Writer =&BufferedWriter {};func (_ffc *BufferedWriter )fullOffset ()int {_cf :=_ffc ._dcc ;if _ffc ._eba !=0{_cf ++;
};return _cf ;};func (_cgb *BufferedWriter )byteCapacity ()int {_bd :=len (_cgb ._c )-_cgb ._dcc ;if _cgb ._eba !=0{_bd --;};return _bd ;};func (_fbf *Writer )Data ()[]byte {return _fbf ._dadb };func (_gcf *Reader )AbsoluteLength ()uint64 {return uint64 (len (_gcf ._ea ._gf ))};
func (_eaad *Writer )SkipBits (skip int )error {const _eff ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_adf :=int (_eaad ._cbc )+skip ;if _adf >=0&&_adf < 8{_eaad ._cbc =uint8 (_adf );return nil ;
};_adf =int (_eaad ._cbc )+_eaad ._edf *8+skip ;if _adf < 0{return _e .Errorf (_eff ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_efcc :=_adf /8;_gdd :=_adf %8;_f .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");
_f .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_eaad ._cbc ,_eaad ._edf ,int (_eaad ._cbc )+(_eaad ._edf )*8,len (_eaad ._dadb ),cap (_eaad ._dadb ));
_f .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_adf ,_gdd );_eaad ._cbc =uint8 (_gdd );if _cga :=_efcc -_eaad ._edf ;
_cga > 0&&len (_eaad ._dadb )-1< _efcc {_f .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_cga );return _e .Errorf (_eff ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};
_eaad ._edf =_efcc ;_f .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_eaad ._cbc ,_eaad ._edf );return nil ;};func (_df *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _df .writeBit (uint8 (bit ));
};return _e .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};const (_eb =64;_eg =int (^uint (0)>>1););func (_gcfd *Reader )ReadUint32 ()(uint32 ,error ){_ceg :=make ([]byte ,4);
_ ,_bfg :=_gcfd .Read (_ceg );if _bfg !=nil {return 0,_bfg ;};return _bc .BigEndian .Uint32 (_ceg ),nil ;};func (_fc *BufferedWriter )writeFullBytes (_bgb []byte )int {_dgd :=copy (_fc ._c [_fc .fullOffset ():],_bgb );_fc ._dcc +=_dgd ;return _dgd ;};func (_dcb *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_dcb ._aaf =-1;
_dcb ._cce =0;_dcb ._bcb =0;_dcb ._fb =0;var _bfgc int64 ;switch whence {case _d .SeekStart :_bfgc =offset ;case _d .SeekCurrent :_bfgc =_dcb ._cb +offset ;case _d .SeekEnd :_bfgc =int64 (_dcb ._ea ._fe )+offset ;default:return 0,_dc .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _bfgc < 0{return 0,_dc .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_dcb ._cb =_bfgc ;
_dcb ._cce =0;return _bfgc ,nil ;};type Reader struct{_ea readerSource ;_bcb byte ;_cce byte ;_cb int64 ;_fb int ;_aaf int ;_ecb int64 ;_dga byte ;_ecd byte ;_ead int ;};func (_efc *Reader )ReadByte ()(byte ,error ){if _efc ._cce ==0{return _efc .readBufferByte ();
};return _efc .readUnalignedByte ();};func (_fffe *Reader )Length ()uint64 {return uint64 (_fffe ._ea ._fe )};func (_fea *Reader )BitPosition ()int {return int (_fea ._cce )};func (_efa *Writer )WriteBits (bits uint64 ,number int )(_cbfd int ,_ccf error ){const _eab ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_e .Errorf (_eab ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_aagg :=number /8;if _aagg > 0{_faa :=number -_aagg *8;for _eef :=_aagg -1;_eef >=0;_eef --{_fgg :=byte ((bits >>uint (_eef *8+_faa ))&0xff);if _ccf =_efa .WriteByte (_fgg );_ccf !=nil {return _cbfd ,_e .Wrapf (_ccf ,_eab ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_aagg -_eef +1);
};};number -=_aagg *8;if number ==0{return _aagg ,nil ;};};var _afg int ;for _gcb :=0;_gcb < number ;_gcb ++{if _efa ._ddf {_afg =int ((bits >>uint (number -1-_gcb ))&0x1);}else {_afg =int (bits &0x1);bits >>=1;};if _ccf =_efa .WriteBit (_afg );_ccf !=nil {return _cbfd ,_e .Wrapf (_ccf ,_eab ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_gcb );
};};return _aagg ,nil ;};func (_faf *Reader )ReadBits (n byte )(_gfe uint64 ,_fec error ){if n < _faf ._cce {_feca :=_faf ._cce -n ;_gfe =uint64 (_faf ._bcb >>_feca );_faf ._bcb &=1<<_feca -1;_faf ._cce =_feca ;return _gfe ,nil ;};if n > _faf ._cce {if _faf ._cce > 0{_gfe =uint64 (_faf ._bcb );
n -=_faf ._cce ;};for n >=8{_dgff ,_aaae :=_faf .readBufferByte ();if _aaae !=nil {return 0,_aaae ;};_gfe =_gfe <<8+uint64 (_dgff );n -=8;};if n > 0{if _faf ._bcb ,_fec =_faf .readBufferByte ();_fec !=nil {return 0,_fec ;};_feb :=8-n ;_gfe =_gfe <<n +uint64 (_faf ._bcb >>_feb );
_faf ._bcb &=1<<_feb -1;_faf ._cce =_feb ;}else {_faf ._cce =0;};return _gfe ,nil ;};_faf ._cce =0;return uint64 (_faf ._bcb ),nil ;};type StreamReader interface{_d .Reader ;_d .ByteReader ;_d .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;
ReadBit ()(int ,error );ReadBits (_aag byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();AbsolutePosition ()int64 ;};func (_ccec *Reader )Reset (){_ccec ._cb =_ccec ._ecb ;_ccec ._cce =_ccec ._dga ;_ccec ._bcb =_ccec ._ecd ;
_ccec ._fb =_ccec ._ead ;};func (_cgd *Writer )WriteByte (c byte )error {return _cgd .writeByte (c )};func (_dg *BufferedWriter )ResetBitIndex (){_dg ._eba =0};func (_abfd *Reader )ReadBool ()(bool ,error ){return _abfd .readBool ()};func (_dbb *Reader )RelativePosition ()int64 {return _dbb ._cb };
func (_abd *Writer )byteCapacity ()int {_afd :=len (_abd ._dadb )-_abd ._edf ;if _abd ._cbc !=0{_afd --;};return _afd ;};func (_abf *BufferedWriter )WriteBits (bits uint64 ,number int )(_cg int ,_acb error ){const _ff ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_e .Errorf (_ff ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_eec :=number /8;if _eec > 0{_dgf :=number -_eec *8;for _bgf :=_eec -1;_bgf >=0;_bgf --{_fff :=byte ((bits >>uint (_bgf *8+_dgf ))&0xff);if _acb =_abf .WriteByte (_fff );_acb !=nil {return _cg ,_e .Wrapf (_acb ,_ff ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_eec -_bgf +1);
};};number -=_eec *8;if number ==0{return _eec ,nil ;};};var _aaa int ;for _cc :=0;_cc < number ;_cc ++{if _abf ._fa {_aaa =int ((bits >>uint (number -1-_cc ))&0x1);}else {_aaa =int (bits &0x1);bits >>=1;};if _acb =_abf .WriteBit (_aaa );_acb !=nil {return _cg ,_e .Wrapf (_acb ,_ff ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_cc );
};};return _eec ,nil ;};func (_dac *Reader )read (_dad []byte )(int ,error ){if _dac ._cb >=int64 (_dac ._ea ._fe ){return 0,_d .EOF ;};_dac ._aaf =-1;_ge :=copy (_dad ,_dac ._ea ._gf [(int64 (_dac ._ea ._aeg )+_dac ._cb ):(_dac ._ea ._aeg +_dac ._ea ._fe )]);
_dac ._cb +=int64 (_ge );return _ge ,nil ;};func (_bff *Reader )readBufferByte ()(byte ,error ){if _bff ._cb >=int64 (_bff ._ea ._fe ){return 0,_d .EOF ;};_bff ._aaf =-1;_ddb :=_bff ._ea ._gf [int64 (_bff ._ea ._aeg )+_bff ._cb ];_bff ._cb ++;_bff ._fb =int (_ddb );
return _ddb ,nil ;};func (_fad *Reader )NewPartialReader (offset ,length int ,relative bool )(*Reader ,error ){if offset < 0{return nil ,_dc .New ("p\u0061\u0072\u0074\u0069\u0061\u006c\u0020\u0072\u0065\u0061\u0064\u0065\u0072\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062e \u006e\u0065\u0067a\u0074i\u0076\u0065");
};if relative {offset =_fad ._ea ._aeg +offset ;};if length > 0{_fcd :=len (_fad ._ea ._gf );if relative {_fcd =_fad ._ea ._fe ;};if offset +length > _fcd {return nil ,_b .Errorf ("\u0070\u0061r\u0074\u0069\u0061l\u0020\u0072\u0065\u0061\u0064e\u0072\u0020\u006f\u0066\u0066se\u0074\u0028\u0025\u0064\u0029\u002b\u006c\u0065\u006e\u0067\u0074\u0068\u0028\u0025\u0064\u0029\u003d\u0025d\u0020i\u0073\u0020\u0067\u0072\u0065\u0061ter\u0020\u0074\u0068\u0061\u006e\u0020\u0074\u0068\u0065\u0020\u006f\u0072ig\u0069n\u0061\u006c\u0020\u0072e\u0061d\u0065r\u0020\u006ce\u006e\u0067th\u003a\u0020\u0025\u0064",offset ,length ,offset +length ,_fad ._ea ._fe );
};};if length < 0{_da :=len (_fad ._ea ._gf );if relative {_da =_fad ._ea ._fe ;};length =_da -offset ;};return &Reader {_ea :readerSource {_gf :_fad ._ea ._gf ,_fe :length ,_aeg :offset }},nil ;};func (_gge *Writer )ResetBit (){_gge ._cbc =0};func NewReader (data []byte )*Reader {return &Reader {_ea :readerSource {_gf :data ,_fe :len (data ),_aeg :0}};
};func NewWriterMSB (data []byte )*Writer {return &Writer {_dadb :data ,_ddf :true }};var _ BinaryWriter =&Writer {};func NewWriter (data []byte )*Writer {return &Writer {_dadb :data }};func (_fd *BufferedWriter )Data ()[]byte {return _fd ._c };func (_bg *BufferedWriter )Write (d []byte )(int ,error ){_bg .expandIfNeeded (len (d ));
if _bg ._eba ==0{return _bg .writeFullBytes (d ),nil ;};return _bg .writeShiftedBytes (d ),nil ;};func (_afe *Reader )AbsolutePosition ()int64 {return _afe ._cb +int64 (_afe ._ea ._aeg )};func (_afc *Reader )Read (p []byte )(_cbf int ,_bag error ){if _afc ._cce ==0{return _afc .read (p );
};for ;_cbf < len (p );_cbf ++{if p [_cbf ],_bag =_afc .readUnalignedByte ();_bag !=nil {return 0,_bag ;};};return _cbf ,nil ;};func (_dba *Reader )readBool ()(_cbd bool ,_gfd error ){if _dba ._cce ==0{_dba ._bcb ,_gfd =_dba .readBufferByte ();if _gfd !=nil {return false ,_gfd ;
};_cbd =(_dba ._bcb &0x80)!=0;_dba ._bcb ,_dba ._cce =_dba ._bcb &0x7f,7;return _cbd ,nil ;};_dba ._cce --;_cbd =(_dba ._bcb &(1<<_dba ._cce ))!=0;_dba ._bcb &=1<<_dba ._cce -1;return _cbd ,nil ;};func (_ec *BufferedWriter )Reset (){_ec ._c =_ec ._c [:0];
_ec ._dcc =0;_ec ._eba =0};type readerSource struct{_gf []byte ;_aeg int ;_fe int ;};func (_aafa *Reader )ReadBit ()(_dag int ,_dagd error ){_cceg ,_dagd :=_aafa .readBool ();if _dagd !=nil {return 0,_dagd ;};if _cceg {_dag =1;};return _dag ,nil ;};func (_ade *Writer )FinishByte (){if _ade ._cbc ==0{return ;
};_ade ._cbc =0;_ade ._edf ++;};func (_cfc *Reader )Align ()(_ag byte ){_ag =_cfc ._cce ;_cfc ._cce =0;return _ag };type Writer struct{_dadb []byte ;_cbc uint8 ;_edf int ;_ddf bool ;};func (_bgc *BufferedWriter )tryGrowByReslice (_ce int )bool {if _ba :=len (_bgc ._c );
_ce <=cap (_bgc ._c )-_ba {_bgc ._c =_bgc ._c [:_ba +_ce ];return true ;};return false ;};func (_ac *BufferedWriter )WriteByte (bt byte )error {if _ac ._dcc > len (_ac ._c )-1||(_ac ._dcc ==len (_ac ._c )-1&&_ac ._eba !=0){_ac .expandIfNeeded (1);};_ac .writeByte (bt );
return nil ;};func (_ae *BufferedWriter )FinishByte (){if _ae ._eba ==0{return ;};_ae ._eba =0;_ae ._dcc ++;};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_fa :true }};func (_ddfc *Writer )writeByte (_ebd byte )error {if _ddfc ._edf > len (_ddfc ._dadb )-1{return _d .EOF ;
};if _ddfc ._edf ==len (_ddfc ._dadb )-1&&_ddfc ._cbc !=0{return _d .EOF ;};if _ddfc ._cbc ==0{_ddfc ._dadb [_ddfc ._edf ]=_ebd ;_ddfc ._edf ++;return nil ;};if _ddfc ._ddf {_ddfc ._dadb [_ddfc ._edf ]|=_ebd >>_ddfc ._cbc ;_ddfc ._edf ++;_ddfc ._dadb [_ddfc ._edf ]=byte (uint16 (_ebd )<<(8-_ddfc ._cbc )&0xff);
}else {_ddfc ._dadb [_ddfc ._edf ]|=byte (uint16 (_ebd )<<_ddfc ._cbc &0xff);_ddfc ._edf ++;_ddfc ._dadb [_ddfc ._edf ]=_ebd >>(8-_ddfc ._cbc );};return nil ;};type BitWriter interface{WriteBit (_ebc int )error ;WriteBits (_cac uint64 ,_af int )(_fdf int ,_ef error );
FinishByte ();SkipBits (_gcg int )error ;};var (_ _d .Reader =&Reader {};_ _d .ByteReader =&Reader {};_ _d .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_ab *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _e .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_ab ._c )-1< _ab ._dcc {_ab .expandIfNeeded (1);};_gb :=_ab ._eba ;if _ab ._fa {_gb =7-_ab ._eba ;};_ab ._c [_ab ._dcc ]|=byte (uint16 (bit <<_gb )&0xff);_ab ._eba ++;if _ab ._eba ==8{_ab ._dcc ++;_ab ._eba =0;};return nil ;};func (_aafb *Writer )Write (p []byte )(int ,error ){if len (p )> _aafb .byteCapacity (){return 0,_d .EOF ;
};for _ ,_gbd :=range p {if _ga :=_aafb .writeByte (_gbd );_ga !=nil {return 0,_ga ;};};return len (p ),nil ;};func (_agc *Writer )UseMSB ()bool {return _agc ._ddf };func (_ee *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_gg :=int (_ee ._eba )+skip ;
if _gg >=0&&_gg < 8{_ee ._eba =uint8 (_gg );return nil ;};_gg =int (_ee ._eba )+_ee ._dcc *8+skip ;if _gg < 0{return _e .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_bb :=_gg /8;_ggd :=_gg %8;_ee ._eba =uint8 (_ggd );if _fg :=_bb -_ee ._dcc ;_fg > 0&&len (_ee ._c )-1< _bb {if _ee ._eba !=0{_fg ++;};_ee .expandIfNeeded (_fg );};_ee ._dcc =_bb ;return nil ;};type BinaryWriter interface{BitWriter ;_d .Writer ;_d .ByteWriter ;
Data ()[]byte ;};func (_dae *Writer )writeBit (_cdd uint8 )error {if len (_dae ._dadb )-1< _dae ._edf {return _d .EOF ;};_egc :=_dae ._cbc ;if _dae ._ddf {_egc =7-_dae ._cbc ;};_dae ._dadb [_dae ._edf ]|=byte (uint16 (_cdd <<_egc )&0xff);_dae ._cbc ++;
if _dae ._cbc ==8{_dae ._edf ++;_dae ._cbc =0;};return nil ;};func (_aec *BufferedWriter )writeByte (_gc byte ){switch {case _aec ._eba ==0:_aec ._c [_aec ._dcc ]=_gc ;_aec ._dcc ++;case _aec ._fa :_aec ._c [_aec ._dcc ]|=_gc >>_aec ._eba ;_aec ._dcc ++;
_aec ._c [_aec ._dcc ]=byte (uint16 (_gc )<<(8-_aec ._eba )&0xff);default:_aec ._c [_aec ._dcc ]|=byte (uint16 (_gc )<<_aec ._eba &0xff);_aec ._dcc ++;_aec ._c [_aec ._dcc ]=_gc >>(8-_aec ._eba );};};