//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_a "encoding/binary";_ba "errors";_cd "fmt";_fa "github.com/unidoc/unipdf/v3/common";_bg "github.com/unidoc/unipdf/v3/internal/bitwise";_bb "image";_c "image/color";_g "image/draw";_f "math";);func (_fge *Monochrome )AddPadding ()(_ebbd error ){if _ccbb :=((_fge .Width *_fge .Height )+7)>>3;
len (_fge .Data )< _ccbb {return _cd .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064a\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002e\u0020\u0054\u0068\u0065\u0020\u0064\u0061t\u0061\u0020s\u0068\u006fu\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 l\u0065\u0061\u0073\u0074\u003a\u0020\u0027\u0025\u0064'\u0020\u0062\u0079\u0074\u0065\u0073",len (_fge .Data ),_ccbb );
};_bggbg :=_fge .Width %8;if _bggbg ==0{return nil ;};_bfgd :=_fge .Width /8;_caba :=_bg .NewReader (_fge .Data );_edb :=make ([]byte ,_fge .Height *_fge .BytesPerLine );_gfbe :=_bg .NewWriterMSB (_edb );_gfcg :=make ([]byte ,_bfgd );var (_egd int ;_aedg uint64 ;
);for _egd =0;_egd < _fge .Height ;_egd ++{if _ ,_ebbd =_caba .Read (_gfcg );_ebbd !=nil {return _ebbd ;};if _ ,_ebbd =_gfbe .Write (_gfcg );_ebbd !=nil {return _ebbd ;};if _aedg ,_ebbd =_caba .ReadBits (byte (_bggbg ));_ebbd !=nil {return _ebbd ;};if _ebbd =_gfbe .WriteByte (byte (_aedg )<<uint (8-_bggbg ));
_ebbd !=nil {return _ebbd ;};};_fge .Data =_gfbe .Data ();return nil ;};func _fbdc (_bgdf Gray ,_fde NRGBA ,_baf _bb .Rectangle ){for _ccb :=0;_ccb < _baf .Max .X ;_ccb ++{for _edd :=0;_edd < _baf .Max .Y ;_edd ++{_gcbgb :=_bgd (_fde .NRGBAAt (_ccb ,_edd ));
_bgdf .SetGray (_ccb ,_edd ,_gcbgb );};};};func _fc ()(_ea [256]uint32 ){for _gegg :=0;_gegg < 256;_gegg ++{if _gegg &0x01!=0{_ea [_gegg ]|=0xf;};if _gegg &0x02!=0{_ea [_gegg ]|=0xf0;};if _gegg &0x04!=0{_ea [_gegg ]|=0xf00;};if _gegg &0x08!=0{_ea [_gegg ]|=0xf000;
};if _gegg &0x10!=0{_ea [_gegg ]|=0xf0000;};if _gegg &0x20!=0{_ea [_gegg ]|=0xf00000;};if _gegg &0x40!=0{_ea [_gegg ]|=0xf000000;};if _gegg &0x80!=0{_ea [_gegg ]|=0xf0000000;};};return _ea ;};func (_ebbf *Monochrome )getBit (_cfb ,_bade int )uint8 {return _ebbf .Data [_cfb +(_bade >>3)]>>uint (7-(_bade &7))&1;
};func (_cbbd *Monochrome )getBitAt (_ddgc ,_dgd int )bool {_ecgc :=_dgd *_cbbd .BytesPerLine +(_ddgc >>3);_bdc :=_ddgc &0x07;_bgfg :=uint (7-_bdc );if _ecgc > len (_cbbd .Data )-1{return false ;};if (_cbbd .Data [_ecgc ]>>_bgfg )&0x01>=1{return true ;
};return false ;};func (_agab *Monochrome )Scale (scale float64 )(*Monochrome ,error ){var _cgac bool ;_fbb :=scale ;if scale < 1{_fbb =1/scale ;_cgac =true ;};_gbbf :=NextPowerOf2 (uint (_fbb ));if InDelta (float64 (_gbbf ),_fbb ,0.001){if _cgac {return _agab .ReduceBinary (_fbb );
};return _agab .ExpandBinary (int (_gbbf ));};_cbfc :=int (_f .RoundToEven (float64 (_agab .Width )*scale ));_dcgf :=int (_f .RoundToEven (float64 (_agab .Height )*scale ));return _agab .ScaleLow (_cbfc ,_dcgf );};func (_bde *Monochrome )ResolveDecode ()error {if len (_bde .Decode )!=2{return nil ;
};if _bde .Decode [0]==1&&_bde .Decode [1]==0{if _fbfd :=_bde .InverseData ();_fbfd !=nil {return _fbfd ;};_bde .Decode =nil ;};return nil ;};func (_eab *CMYK32 )Bounds ()_bb .Rectangle {return _bb .Rectangle {Max :_bb .Point {X :_eab .Width ,Y :_eab .Height }};
};func (_gbaa *NRGBA16 )setNRGBA (_adec ,_aada ,_bcab int ,_bdac _c .NRGBA ){if _adec *3%2==0{_gbaa .Data [_bcab ]=(_bdac .R >>4)<<4|(_bdac .G >>4);_gbaa .Data [_bcab +1]=(_bdac .B >>4)<<4|(_gbaa .Data [_bcab +1]&0xf);}else {_gbaa .Data [_bcab ]=(_gbaa .Data [_bcab ]&0xf0)|(_bdac .R >>4);
_gbaa .Data [_bcab +1]=(_bdac .G >>4)<<4|(_bdac .B >>4);};if _gbaa .Alpha !=nil {_abece :=_aada *BytesPerLine (_gbaa .Width ,4,1);if _abece < len (_gbaa .Alpha ){if _adec %2==0{_gbaa .Alpha [_abece ]=(_bdac .A >>uint (4))<<uint (4)|(_gbaa .Alpha [_bcab ]&0xf);
}else {_gbaa .Alpha [_abece ]=(_gbaa .Alpha [_abece ]&0xf0)|(_bdac .A >>uint (4));};};};};func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _f .Abs (xmax -xmin )< 0.000001{return ymin ;};_gdcdc :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );
return _gdcdc ;};type Image interface{_g .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_cacba ,_bggd int )(_c .Color ,error );Validate ()error ;};func (_degg *Monochrome )copy ()*Monochrome {_abad :=_eaa (_degg .Width ,_degg .Height );
_abad .ModelThreshold =_degg .ModelThreshold ;_abad .Data =make ([]byte ,len (_degg .Data ));copy (_abad .Data ,_degg .Data );if len (_degg .Decode )!=0{_abad .Decode =make ([]float64 ,len (_degg .Decode ));copy (_abad .Decode ,_degg .Decode );};if len (_degg .Alpha )!=0{_abad .Alpha =make ([]byte ,len (_degg .Alpha ));
copy (_abad .Alpha ,_degg .Alpha );};return _abad ;};func _cca (_gfd _c .NRGBA )_c .CMYK {_cff ,_dbbg ,_dcfg ,_ :=_gfd .RGBA ();_gfeb ,_gggf ,_fdbb ,_fag :=_c .RGBToCMYK (uint8 (_cff >>8),uint8 (_dbbg >>8),uint8 (_dcfg >>8));return _c .CMYK {C :_gfeb ,M :_gggf ,Y :_fdbb ,K :_fag };
};func IsPowerOf2 (n uint )bool {return n > 0&&(n &(n -1))==0};func _aec (_eeaf NRGBA ,_gbea RGBA ,_gfef _bb .Rectangle ){for _bcfa :=0;_bcfa < _gfef .Max .X ;_bcfa ++{for _dcce :=0;_dcce < _gfef .Max .Y ;_dcce ++{_ddgd :=_eeaf .NRGBAAt (_bcfa ,_dcce );
_gbea .SetRGBA (_bcfa ,_dcce ,_cced (_ddgd ));};};};func _gada (_gfee *Monochrome ,_eaag ,_ceae int ,_becg ,_gcef int ,_adde RasterOperator ,_cbed *Monochrome ,_edg ,_afdb int )error {var _ggbe ,_dbff ,_aedb ,_cddb int ;if _eaag < 0{_edg -=_eaag ;_becg +=_eaag ;
_eaag =0;};if _edg < 0{_eaag -=_edg ;_becg +=_edg ;_edg =0;};_ggbe =_eaag +_becg -_gfee .Width ;if _ggbe > 0{_becg -=_ggbe ;};_dbff =_edg +_becg -_cbed .Width ;if _dbff > 0{_becg -=_dbff ;};if _ceae < 0{_afdb -=_ceae ;_gcef +=_ceae ;_ceae =0;};if _afdb < 0{_ceae -=_afdb ;
_gcef +=_afdb ;_afdb =0;};_aedb =_ceae +_gcef -_gfee .Height ;if _aedb > 0{_gcef -=_aedb ;};_cddb =_afdb +_gcef -_cbed .Height ;if _cddb > 0{_gcef -=_cddb ;};if _becg <=0||_gcef <=0{return nil ;};var _ffbg error ;switch {case _eaag &7==0&&_edg &7==0:_ffbg =_decd (_gfee ,_eaag ,_ceae ,_becg ,_gcef ,_adde ,_cbed ,_edg ,_afdb );
case _eaag &7==_edg &7:_ffbg =_dbbcd (_gfee ,_eaag ,_ceae ,_becg ,_gcef ,_adde ,_cbed ,_edg ,_afdb );default:_ffbg =_eeag (_gfee ,_eaag ,_ceae ,_becg ,_gcef ,_adde ,_cbed ,_edg ,_afdb );};if _ffbg !=nil {return _ffbg ;};return nil ;};func _cfedd (_bgcg CMYK ,_adfbg RGBA ,_ccge _bb .Rectangle ){for _deeg :=0;
_deeg < _ccge .Max .X ;_deeg ++{for _bbee :=0;_bbee < _ccge .Max .Y ;_bbee ++{_gcee :=_bgcg .CMYKAt (_deeg ,_bbee );_adfbg .SetRGBA (_deeg ,_bbee ,_fbd (_gcee ));};};};func _agba (_cga _bb .Image )(Image ,error ){if _bfegd ,_afb :=_cga .(*Monochrome );
_afb {return _bfegd ,nil ;};_bbe :=_cga .Bounds ();var _eae Gray ;switch _dgb :=_cga .(type ){case Gray :_eae =_dgb ;case NRGBA :_eae =&Gray8 {ImageBase :NewImageBase (_bbe .Max .X ,_bbe .Max .Y ,8,1,nil ,nil ,nil )};_fbdc (_eae ,_dgb ,_bbe );case nrgba64 :_eae =&Gray8 {ImageBase :NewImageBase (_bbe .Max .X ,_bbe .Max .Y ,8,1,nil ,nil ,nil )};
_abbc (_eae ,_dgb ,_bbe );default:_ecgg ,_bdbb :=GrayConverter .Convert (_cga );if _bdbb !=nil {return nil ,_bdbb ;};_eae =_ecgg .(Gray );};_gfad ,_gcgb :=NewImage (_bbe .Max .X ,_bbe .Max .Y ,1,1,nil ,nil ,nil );if _gcgb !=nil {return nil ,_gcgb ;};_abgd :=_gfad .(*Monochrome );
_dbe :=AutoThresholdTriangle (GrayHistogram (_eae ));for _gcf :=0;_gcf < _bbe .Max .X ;_gcf ++{for _ede :=0;_ede < _bbe .Max .Y ;_ede ++{_abfe :=_adf (_eae .GrayAt (_gcf ,_ede ),monochromeModel (_dbe ));_abgd .SetGray (_gcf ,_ede ,_abfe );};};return _gfad ,nil ;
};func (_bagde *NRGBA64 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtNRGBA64 (x ,y ,_bagde .Width ,_bagde .Data ,_bagde .Alpha ,_bagde .Decode );};func (_cggc *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_cggc .copy ()}};func (_aabd *Gray16 )GrayAt (x ,y int )_c .Gray {_ccdb ,_ :=_aabd .ColorAt (x ,y );
return _c .Gray {Y :uint8 (_ccdb .(_c .Gray16 ).Y >>8)};};const (PixSrc RasterOperator =0xc;PixDst RasterOperator =0xa;PixNotSrc RasterOperator =0x3;PixNotDst RasterOperator =0x5;PixClr RasterOperator =0x0;PixSet RasterOperator =0xf;PixSrcOrDst RasterOperator =0xe;
PixSrcAndDst RasterOperator =0x8;PixSrcXorDst RasterOperator =0x6;PixNotSrcOrDst RasterOperator =0xb;PixNotSrcAndDst RasterOperator =0x2;PixSrcOrNotDst RasterOperator =0xd;PixSrcAndNotDst RasterOperator =0x4;PixNotPixSrcOrDst RasterOperator =0x1;PixNotPixSrcAndDst RasterOperator =0x7;
PixNotPixSrcXorDst RasterOperator =0x9;PixPaint =PixSrcOrDst ;PixSubtract =PixNotSrcAndDst ;PixMask =PixSrcAndDst ;);var _ Image =&Gray4 {};func (_dgf *Monochrome )Base ()*ImageBase {return &_dgf .ImageBase };func (_ccad *Gray16 )Set (x ,y int ,c _c .Color ){_acecg :=(y *_ccad .BytesPerLine /2+x )*2;
if _acecg +1>=len (_ccad .Data ){return ;};_agbb :=_c .Gray16Model .Convert (c ).(_c .Gray16 );_ccad .Data [_acecg ],_ccad .Data [_acecg +1]=uint8 (_agbb .Y >>8),uint8 (_agbb .Y &0xff);};func (_bafc *Gray4 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray4BPC (x ,y ,_bafc .BytesPerLine ,_bafc .Data ,_bafc .Decode );
};func _gdff (_egef _bb .Image ,_afcd Image ,_cfee _bb .Rectangle ){if _ddag ,_dgce :=_egef .(SMasker );_dgce &&_ddag .HasAlpha (){_afcd .(SMasker ).MakeAlpha ();};switch _adfd :=_egef .(type ){case Gray :_eaade (_adfd ,_afcd .(RGBA ),_cfee );case NRGBA :_aec (_adfd ,_afcd .(RGBA ),_cfee );
case *_bb .NYCbCrA :_cgde (_adfd ,_afcd .(RGBA ),_cfee );case CMYK :_cfedd (_adfd ,_afcd .(RGBA ),_cfee );case RGBA :_afae (_adfd ,_afcd .(RGBA ),_cfee );case nrgba64 :_beeba (_adfd ,_afcd .(RGBA ),_cfee );default:_bcc (_egef ,_afcd ,_cfee );};};type Monochrome struct{ImageBase ;
ModelThreshold uint8 ;};func (_affe *Monochrome )Bounds ()_bb .Rectangle {return _bb .Rectangle {Max :_bb .Point {X :_affe .Width ,Y :_affe .Height }};};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;
Decode []float64 ;BytesPerLine int ;};func (_dada *CMYK32 )At (x ,y int )_c .Color {_eagdd ,_ :=_dada .ColorAt (x ,y );return _eagdd };var _ Image =&NRGBA32 {};func (_ggde *Gray2 )ColorModel ()_c .Model {return Gray2Model };func _adgg (_adeb _bb .Image )(Image ,error ){if _ebgf ,_dee :=_adeb .(*CMYK32 );
_dee {return _ebgf .Copy (),nil ;};_gcde :=_adeb .Bounds ();_efc ,_abe :=NewImage (_gcde .Max .X ,_gcde .Max .Y ,8,4,nil ,nil ,nil );if _abe !=nil {return nil ,_abe ;};switch _ecf :=_adeb .(type ){case CMYK :_deaf (_ecf ,_efc .(CMYK ),_gcde );case Gray :_aee (_ecf ,_efc .(CMYK ),_gcde );
case NRGBA :_ecdc (_ecf ,_efc .(CMYK ),_gcde );case RGBA :_deea (_ecf ,_efc .(CMYK ),_gcde );default:_bcc (_adeb ,_efc ,_gcde );};return _efc ,nil ;};func _eeag (_dcde *Monochrome ,_bffa ,_ebgge ,_bcgc ,_gfaa int ,_edbe RasterOperator ,_bcde *Monochrome ,_abde ,_acbg int )error {var (_deed bool ;
_cbcc bool ;_ccbe byte ;_gaee int ;_efg int ;_gbaf int ;_gddc int ;_cebg bool ;_fdea int ;_dfdc int ;_eebg int ;_ccdf bool ;_afe byte ;_cgfff int ;_gcc int ;_dfda int ;_bbga byte ;_gfcf int ;_feedf int ;_gaca uint ;_gbc uint ;_ddce byte ;_egfg shift ;_aaf bool ;
_dcge bool ;_acca ,_aegf int ;);if _abde &7!=0{_feedf =8-(_abde &7);};if _bffa &7!=0{_efg =8-(_bffa &7);};if _feedf ==0&&_efg ==0{_ddce =_acgb [0];}else {if _efg > _feedf {_gaca =uint (_efg -_feedf );}else {_gaca =uint (8-(_feedf -_efg ));};_gbc =8-_gaca ;
_ddce =_acgb [_gaca ];};if (_bffa &7)!=0{_deed =true ;_gaee =8-(_bffa &7);_ccbe =_acgb [_gaee ];_gbaf =_dcde .BytesPerLine *_ebgge +(_bffa >>3);_gddc =_bcde .BytesPerLine *_acbg +(_abde >>3);_gfcf =8-(_abde &7);if _gaee > _gfcf {_egfg =_bbcba ;if _bcgc >=_feedf {_aaf =true ;
};}else {_egfg =_baff ;};};if _bcgc < _gaee {_cbcc =true ;_ccbe &=_bdedc [8-_gaee +_bcgc ];};if !_cbcc {_fdea =(_bcgc -_gaee )>>3;if _fdea !=0{_cebg =true ;_dfdc =_dcde .BytesPerLine *_ebgge +((_bffa +_efg )>>3);_eebg =_bcde .BytesPerLine *_acbg +((_abde +_efg )>>3);
};};_cgfff =(_bffa +_bcgc )&7;if !(_cbcc ||_cgfff ==0){_ccdf =true ;_afe =_bdedc [_cgfff ];_gcc =_dcde .BytesPerLine *_ebgge +((_bffa +_efg )>>3)+_fdea ;_dfda =_bcde .BytesPerLine *_acbg +((_abde +_efg )>>3)+_fdea ;if _cgfff > int (_gbc ){_dcge =true ;
};};switch _edbe {case PixSrc :if _deed {for _acca =0;_acca < _gfaa ;_acca ++{if _egfg ==_bbcba {_bbga =_bcde .Data [_gddc ]<<_gaca ;if _aaf {_bbga =_cgb (_bbga ,_bcde .Data [_gddc +1]>>_gbc ,_ddce );};}else {_bbga =_bcde .Data [_gddc ]>>_gbc ;};_dcde .Data [_gbaf ]=_cgb (_dcde .Data [_gbaf ],_bbga ,_ccbe );
_gbaf +=_dcde .BytesPerLine ;_gddc +=_bcde .BytesPerLine ;};};if _cebg {for _acca =0;_acca < _gfaa ;_acca ++{for _aegf =0;_aegf < _fdea ;_aegf ++{_bbga =_cgb (_bcde .Data [_eebg +_aegf ]<<_gaca ,_bcde .Data [_eebg +_aegf +1]>>_gbc ,_ddce );_dcde .Data [_dfdc +_aegf ]=_bbga ;
};_dfdc +=_dcde .BytesPerLine ;_eebg +=_bcde .BytesPerLine ;};};if _ccdf {for _acca =0;_acca < _gfaa ;_acca ++{_bbga =_bcde .Data [_dfda ]<<_gaca ;if _dcge {_bbga =_cgb (_bbga ,_bcde .Data [_dfda +1]>>_gbc ,_ddce );};_dcde .Data [_gcc ]=_cgb (_dcde .Data [_gcc ],_bbga ,_afe );
_gcc +=_dcde .BytesPerLine ;_dfda +=_bcde .BytesPerLine ;};};case PixNotSrc :if _deed {for _acca =0;_acca < _gfaa ;_acca ++{if _egfg ==_bbcba {_bbga =_bcde .Data [_gddc ]<<_gaca ;if _aaf {_bbga =_cgb (_bbga ,_bcde .Data [_gddc +1]>>_gbc ,_ddce );};}else {_bbga =_bcde .Data [_gddc ]>>_gbc ;
};_dcde .Data [_gbaf ]=_cgb (_dcde .Data [_gbaf ],^_bbga ,_ccbe );_gbaf +=_dcde .BytesPerLine ;_gddc +=_bcde .BytesPerLine ;};};if _cebg {for _acca =0;_acca < _gfaa ;_acca ++{for _aegf =0;_aegf < _fdea ;_aegf ++{_bbga =_cgb (_bcde .Data [_eebg +_aegf ]<<_gaca ,_bcde .Data [_eebg +_aegf +1]>>_gbc ,_ddce );
_dcde .Data [_dfdc +_aegf ]=^_bbga ;};_dfdc +=_dcde .BytesPerLine ;_eebg +=_bcde .BytesPerLine ;};};if _ccdf {for _acca =0;_acca < _gfaa ;_acca ++{_bbga =_bcde .Data [_dfda ]<<_gaca ;if _dcge {_bbga =_cgb (_bbga ,_bcde .Data [_dfda +1]>>_gbc ,_ddce );};
_dcde .Data [_gcc ]=_cgb (_dcde .Data [_gcc ],^_bbga ,_afe );_gcc +=_dcde .BytesPerLine ;_dfda +=_bcde .BytesPerLine ;};};case PixSrcOrDst :if _deed {for _acca =0;_acca < _gfaa ;_acca ++{if _egfg ==_bbcba {_bbga =_bcde .Data [_gddc ]<<_gaca ;if _aaf {_bbga =_cgb (_bbga ,_bcde .Data [_gddc +1]>>_gbc ,_ddce );
};}else {_bbga =_bcde .Data [_gddc ]>>_gbc ;};_dcde .Data [_gbaf ]=_cgb (_dcde .Data [_gbaf ],_bbga |_dcde .Data [_gbaf ],_ccbe );_gbaf +=_dcde .BytesPerLine ;_gddc +=_bcde .BytesPerLine ;};};if _cebg {for _acca =0;_acca < _gfaa ;_acca ++{for _aegf =0;
_aegf < _fdea ;_aegf ++{_bbga =_cgb (_bcde .Data [_eebg +_aegf ]<<_gaca ,_bcde .Data [_eebg +_aegf +1]>>_gbc ,_ddce );_dcde .Data [_dfdc +_aegf ]|=_bbga ;};_dfdc +=_dcde .BytesPerLine ;_eebg +=_bcde .BytesPerLine ;};};if _ccdf {for _acca =0;_acca < _gfaa ;
_acca ++{_bbga =_bcde .Data [_dfda ]<<_gaca ;if _dcge {_bbga =_cgb (_bbga ,_bcde .Data [_dfda +1]>>_gbc ,_ddce );};_dcde .Data [_gcc ]=_cgb (_dcde .Data [_gcc ],_bbga |_dcde .Data [_gcc ],_afe );_gcc +=_dcde .BytesPerLine ;_dfda +=_bcde .BytesPerLine ;
};};case PixSrcAndDst :if _deed {for _acca =0;_acca < _gfaa ;_acca ++{if _egfg ==_bbcba {_bbga =_bcde .Data [_gddc ]<<_gaca ;if _aaf {_bbga =_cgb (_bbga ,_bcde .Data [_gddc +1]>>_gbc ,_ddce );};}else {_bbga =_bcde .Data [_gddc ]>>_gbc ;};_dcde .Data [_gbaf ]=_cgb (_dcde .Data [_gbaf ],_bbga &_dcde .Data [_gbaf ],_ccbe );
_gbaf +=_dcde .BytesPerLine ;_gddc +=_bcde .BytesPerLine ;};};if _cebg {for _acca =0;_acca < _gfaa ;_acca ++{for _aegf =0;_aegf < _fdea ;_aegf ++{_bbga =_cgb (_bcde .Data [_eebg +_aegf ]<<_gaca ,_bcde .Data [_eebg +_aegf +1]>>_gbc ,_ddce );_dcde .Data [_dfdc +_aegf ]&=_bbga ;
};_dfdc +=_dcde .BytesPerLine ;_eebg +=_bcde .BytesPerLine ;};};if _ccdf {for _acca =0;_acca < _gfaa ;_acca ++{_bbga =_bcde .Data [_dfda ]<<_gaca ;if _dcge {_bbga =_cgb (_bbga ,_bcde .Data [_dfda +1]>>_gbc ,_ddce );};_dcde .Data [_gcc ]=_cgb (_dcde .Data [_gcc ],_bbga &_dcde .Data [_gcc ],_afe );
_gcc +=_dcde .BytesPerLine ;_dfda +=_bcde .BytesPerLine ;};};case PixSrcXorDst :if _deed {for _acca =0;_acca < _gfaa ;_acca ++{if _egfg ==_bbcba {_bbga =_bcde .Data [_gddc ]<<_gaca ;if _aaf {_bbga =_cgb (_bbga ,_bcde .Data [_gddc +1]>>_gbc ,_ddce );};}else {_bbga =_bcde .Data [_gddc ]>>_gbc ;
};_dcde .Data [_gbaf ]=_cgb (_dcde .Data [_gbaf ],_bbga ^_dcde .Data [_gbaf ],_ccbe );_gbaf +=_dcde .BytesPerLine ;_gddc +=_bcde .BytesPerLine ;};};if _cebg {for _acca =0;_acca < _gfaa ;_acca ++{for _aegf =0;_aegf < _fdea ;_aegf ++{_bbga =_cgb (_bcde .Data [_eebg +_aegf ]<<_gaca ,_bcde .Data [_eebg +_aegf +1]>>_gbc ,_ddce );
_dcde .Data [_dfdc +_aegf ]^=_bbga ;};_dfdc +=_dcde .BytesPerLine ;_eebg +=_bcde .BytesPerLine ;};};if _ccdf {for _acca =0;_acca < _gfaa ;_acca ++{_bbga =_bcde .Data [_dfda ]<<_gaca ;if _dcge {_bbga =_cgb (_bbga ,_bcde .Data [_dfda +1]>>_gbc ,_ddce );};
_dcde .Data [_gcc ]=_cgb (_dcde .Data [_gcc ],_bbga ^_dcde .Data [_gcc ],_afe );_gcc +=_dcde .BytesPerLine ;_dfda +=_bcde .BytesPerLine ;};};case PixNotSrcOrDst :if _deed {for _acca =0;_acca < _gfaa ;_acca ++{if _egfg ==_bbcba {_bbga =_bcde .Data [_gddc ]<<_gaca ;
if _aaf {_bbga =_cgb (_bbga ,_bcde .Data [_gddc +1]>>_gbc ,_ddce );};}else {_bbga =_bcde .Data [_gddc ]>>_gbc ;};_dcde .Data [_gbaf ]=_cgb (_dcde .Data [_gbaf ],^_bbga |_dcde .Data [_gbaf ],_ccbe );_gbaf +=_dcde .BytesPerLine ;_gddc +=_bcde .BytesPerLine ;
};};if _cebg {for _acca =0;_acca < _gfaa ;_acca ++{for _aegf =0;_aegf < _fdea ;_aegf ++{_bbga =_cgb (_bcde .Data [_eebg +_aegf ]<<_gaca ,_bcde .Data [_eebg +_aegf +1]>>_gbc ,_ddce );_dcde .Data [_dfdc +_aegf ]|=^_bbga ;};_dfdc +=_dcde .BytesPerLine ;_eebg +=_bcde .BytesPerLine ;
};};if _ccdf {for _acca =0;_acca < _gfaa ;_acca ++{_bbga =_bcde .Data [_dfda ]<<_gaca ;if _dcge {_bbga =_cgb (_bbga ,_bcde .Data [_dfda +1]>>_gbc ,_ddce );};_dcde .Data [_gcc ]=_cgb (_dcde .Data [_gcc ],^_bbga |_dcde .Data [_gcc ],_afe );_gcc +=_dcde .BytesPerLine ;
_dfda +=_bcde .BytesPerLine ;};};case PixNotSrcAndDst :if _deed {for _acca =0;_acca < _gfaa ;_acca ++{if _egfg ==_bbcba {_bbga =_bcde .Data [_gddc ]<<_gaca ;if _aaf {_bbga =_cgb (_bbga ,_bcde .Data [_gddc +1]>>_gbc ,_ddce );};}else {_bbga =_bcde .Data [_gddc ]>>_gbc ;
};_dcde .Data [_gbaf ]=_cgb (_dcde .Data [_gbaf ],^_bbga &_dcde .Data [_gbaf ],_ccbe );_gbaf +=_dcde .BytesPerLine ;_gddc +=_bcde .BytesPerLine ;};};if _cebg {for _acca =0;_acca < _gfaa ;_acca ++{for _aegf =0;_aegf < _fdea ;_aegf ++{_bbga =_cgb (_bcde .Data [_eebg +_aegf ]<<_gaca ,_bcde .Data [_eebg +_aegf +1]>>_gbc ,_ddce );
_dcde .Data [_dfdc +_aegf ]&=^_bbga ;};_dfdc +=_dcde .BytesPerLine ;_eebg +=_bcde .BytesPerLine ;};};if _ccdf {for _acca =0;_acca < _gfaa ;_acca ++{_bbga =_bcde .Data [_dfda ]<<_gaca ;if _dcge {_bbga =_cgb (_bbga ,_bcde .Data [_dfda +1]>>_gbc ,_ddce );
};_dcde .Data [_gcc ]=_cgb (_dcde .Data [_gcc ],^_bbga &_dcde .Data [_gcc ],_afe );_gcc +=_dcde .BytesPerLine ;_dfda +=_bcde .BytesPerLine ;};};case PixSrcOrNotDst :if _deed {for _acca =0;_acca < _gfaa ;_acca ++{if _egfg ==_bbcba {_bbga =_bcde .Data [_gddc ]<<_gaca ;
if _aaf {_bbga =_cgb (_bbga ,_bcde .Data [_gddc +1]>>_gbc ,_ddce );};}else {_bbga =_bcde .Data [_gddc ]>>_gbc ;};_dcde .Data [_gbaf ]=_cgb (_dcde .Data [_gbaf ],_bbga |^_dcde .Data [_gbaf ],_ccbe );_gbaf +=_dcde .BytesPerLine ;_gddc +=_bcde .BytesPerLine ;
};};if _cebg {for _acca =0;_acca < _gfaa ;_acca ++{for _aegf =0;_aegf < _fdea ;_aegf ++{_bbga =_cgb (_bcde .Data [_eebg +_aegf ]<<_gaca ,_bcde .Data [_eebg +_aegf +1]>>_gbc ,_ddce );_dcde .Data [_dfdc +_aegf ]=_bbga |^_dcde .Data [_dfdc +_aegf ];};_dfdc +=_dcde .BytesPerLine ;
_eebg +=_bcde .BytesPerLine ;};};if _ccdf {for _acca =0;_acca < _gfaa ;_acca ++{_bbga =_bcde .Data [_dfda ]<<_gaca ;if _dcge {_bbga =_cgb (_bbga ,_bcde .Data [_dfda +1]>>_gbc ,_ddce );};_dcde .Data [_gcc ]=_cgb (_dcde .Data [_gcc ],_bbga |^_dcde .Data [_gcc ],_afe );
_gcc +=_dcde .BytesPerLine ;_dfda +=_bcde .BytesPerLine ;};};case PixSrcAndNotDst :if _deed {for _acca =0;_acca < _gfaa ;_acca ++{if _egfg ==_bbcba {_bbga =_bcde .Data [_gddc ]<<_gaca ;if _aaf {_bbga =_cgb (_bbga ,_bcde .Data [_gddc +1]>>_gbc ,_ddce );
};}else {_bbga =_bcde .Data [_gddc ]>>_gbc ;};_dcde .Data [_gbaf ]=_cgb (_dcde .Data [_gbaf ],_bbga &^_dcde .Data [_gbaf ],_ccbe );_gbaf +=_dcde .BytesPerLine ;_gddc +=_bcde .BytesPerLine ;};};if _cebg {for _acca =0;_acca < _gfaa ;_acca ++{for _aegf =0;
_aegf < _fdea ;_aegf ++{_bbga =_cgb (_bcde .Data [_eebg +_aegf ]<<_gaca ,_bcde .Data [_eebg +_aegf +1]>>_gbc ,_ddce );_dcde .Data [_dfdc +_aegf ]=_bbga &^_dcde .Data [_dfdc +_aegf ];};_dfdc +=_dcde .BytesPerLine ;_eebg +=_bcde .BytesPerLine ;};};if _ccdf {for _acca =0;
_acca < _gfaa ;_acca ++{_bbga =_bcde .Data [_dfda ]<<_gaca ;if _dcge {_bbga =_cgb (_bbga ,_bcde .Data [_dfda +1]>>_gbc ,_ddce );};_dcde .Data [_gcc ]=_cgb (_dcde .Data [_gcc ],_bbga &^_dcde .Data [_gcc ],_afe );_gcc +=_dcde .BytesPerLine ;_dfda +=_bcde .BytesPerLine ;
};};case PixNotPixSrcOrDst :if _deed {for _acca =0;_acca < _gfaa ;_acca ++{if _egfg ==_bbcba {_bbga =_bcde .Data [_gddc ]<<_gaca ;if _aaf {_bbga =_cgb (_bbga ,_bcde .Data [_gddc +1]>>_gbc ,_ddce );};}else {_bbga =_bcde .Data [_gddc ]>>_gbc ;};_dcde .Data [_gbaf ]=_cgb (_dcde .Data [_gbaf ],^(_bbga |_dcde .Data [_gbaf ]),_ccbe );
_gbaf +=_dcde .BytesPerLine ;_gddc +=_bcde .BytesPerLine ;};};if _cebg {for _acca =0;_acca < _gfaa ;_acca ++{for _aegf =0;_aegf < _fdea ;_aegf ++{_bbga =_cgb (_bcde .Data [_eebg +_aegf ]<<_gaca ,_bcde .Data [_eebg +_aegf +1]>>_gbc ,_ddce );_dcde .Data [_dfdc +_aegf ]=^(_bbga |_dcde .Data [_dfdc +_aegf ]);
};_dfdc +=_dcde .BytesPerLine ;_eebg +=_bcde .BytesPerLine ;};};if _ccdf {for _acca =0;_acca < _gfaa ;_acca ++{_bbga =_bcde .Data [_dfda ]<<_gaca ;if _dcge {_bbga =_cgb (_bbga ,_bcde .Data [_dfda +1]>>_gbc ,_ddce );};_dcde .Data [_gcc ]=_cgb (_dcde .Data [_gcc ],^(_bbga |_dcde .Data [_gcc ]),_afe );
_gcc +=_dcde .BytesPerLine ;_dfda +=_bcde .BytesPerLine ;};};case PixNotPixSrcAndDst :if _deed {for _acca =0;_acca < _gfaa ;_acca ++{if _egfg ==_bbcba {_bbga =_bcde .Data [_gddc ]<<_gaca ;if _aaf {_bbga =_cgb (_bbga ,_bcde .Data [_gddc +1]>>_gbc ,_ddce );
};}else {_bbga =_bcde .Data [_gddc ]>>_gbc ;};_dcde .Data [_gbaf ]=_cgb (_dcde .Data [_gbaf ],^(_bbga &_dcde .Data [_gbaf ]),_ccbe );_gbaf +=_dcde .BytesPerLine ;_gddc +=_bcde .BytesPerLine ;};};if _cebg {for _acca =0;_acca < _gfaa ;_acca ++{for _aegf =0;
_aegf < _fdea ;_aegf ++{_bbga =_cgb (_bcde .Data [_eebg +_aegf ]<<_gaca ,_bcde .Data [_eebg +_aegf +1]>>_gbc ,_ddce );_dcde .Data [_dfdc +_aegf ]=^(_bbga &_dcde .Data [_dfdc +_aegf ]);};_dfdc +=_dcde .BytesPerLine ;_eebg +=_bcde .BytesPerLine ;};};if _ccdf {for _acca =0;
_acca < _gfaa ;_acca ++{_bbga =_bcde .Data [_dfda ]<<_gaca ;if _dcge {_bbga =_cgb (_bbga ,_bcde .Data [_dfda +1]>>_gbc ,_ddce );};_dcde .Data [_gcc ]=_cgb (_dcde .Data [_gcc ],^(_bbga &_dcde .Data [_gcc ]),_afe );_gcc +=_dcde .BytesPerLine ;_dfda +=_bcde .BytesPerLine ;
};};case PixNotPixSrcXorDst :if _deed {for _acca =0;_acca < _gfaa ;_acca ++{if _egfg ==_bbcba {_bbga =_bcde .Data [_gddc ]<<_gaca ;if _aaf {_bbga =_cgb (_bbga ,_bcde .Data [_gddc +1]>>_gbc ,_ddce );};}else {_bbga =_bcde .Data [_gddc ]>>_gbc ;};_dcde .Data [_gbaf ]=_cgb (_dcde .Data [_gbaf ],^(_bbga ^_dcde .Data [_gbaf ]),_ccbe );
_gbaf +=_dcde .BytesPerLine ;_gddc +=_bcde .BytesPerLine ;};};if _cebg {for _acca =0;_acca < _gfaa ;_acca ++{for _aegf =0;_aegf < _fdea ;_aegf ++{_bbga =_cgb (_bcde .Data [_eebg +_aegf ]<<_gaca ,_bcde .Data [_eebg +_aegf +1]>>_gbc ,_ddce );_dcde .Data [_dfdc +_aegf ]=^(_bbga ^_dcde .Data [_dfdc +_aegf ]);
};_dfdc +=_dcde .BytesPerLine ;_eebg +=_bcde .BytesPerLine ;};};if _ccdf {for _acca =0;_acca < _gfaa ;_acca ++{_bbga =_bcde .Data [_dfda ]<<_gaca ;if _dcge {_bbga =_cgb (_bbga ,_bcde .Data [_dfda +1]>>_gbc ,_ddce );};_dcde .Data [_gcc ]=_cgb (_dcde .Data [_gcc ],^(_bbga ^_dcde .Data [_gcc ]),_afe );
_gcc +=_dcde .BytesPerLine ;_dfda +=_bcde .BytesPerLine ;};};default:_fa .Log .Debug ("\u004f\u0070e\u0072\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006e\u006f\u0074\u0020\u0070\u0065\u0072\u006d\u0069tt\u0065\u0064",_edbe );
return _ba .New ("\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065r\u0061\u0074\u0069\u006f\u006e\u0020\u006eo\u0074\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064");};return nil ;};func _cceb (_cabe int ,_bef int )int {if _cabe < _bef {return _cabe ;
};return _bef ;};type colorConverter struct{_cce func (_ffa _bb .Image )(Image ,error );};func _faafe (_gefb _bb .Image )(Image ,error ){if _deeb ,_caaec :=_gefb .(*Gray16 );_caaec {return _deeb .Copy (),nil ;};_ccbfe :=_gefb .Bounds ();_ecdd ,_bafe :=NewImage (_ccbfe .Max .X ,_ccbfe .Max .Y ,16,1,nil ,nil ,nil );
if _bafe !=nil {return nil ,_bafe ;};_bbbf (_gefb ,_ecdd ,_ccbfe );return _ecdd ,nil ;};func _aace (_cfed _c .NYCbCrA )_c .RGBA {_gfb ,_faab ,_fceec ,_fcdc :=_cdb (_cfed ).RGBA ();return _c .RGBA {R :uint8 (_gfb >>8),G :uint8 (_faab >>8),B :uint8 (_fceec >>8),A :uint8 (_fcdc >>8)};
};func (_cecd *NRGBA16 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtNRGBA16 (x ,y ,_cecd .Width ,_cecd .BytesPerLine ,_cecd .Data ,_cecd .Alpha ,_cecd .Decode );};func _ef (_dfe ,_adge int ,_egb []byte )*Monochrome {_bdf :=_eaa (_dfe ,_adge );
_bdf .Data =_egb ;return _bdf ;};func (_cefb *NRGBA32 )Base ()*ImageBase {return &_cefb .ImageBase };func (_eda colorConverter )Convert (src _bb .Image )(Image ,error ){return _eda ._cce (src )};var _ Image =&Monochrome {};func (_beac *CMYK32 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtCMYK (x ,y ,_beac .Width ,_beac .Data ,_beac .Decode );
};func (_dbf *Monochrome )IsUnpadded ()bool {return (_dbf .Width *_dbf .Height )==len (_dbf .Data )};func _caeb (_fbe _c .Gray )_c .Gray {_fbe .Y >>=4;_fbe .Y |=_fbe .Y <<4;return _fbe };type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();
};func (_bfbe *ImageBase )setEightPartlyBytes (_dagd ,_aaddb int ,_dgbab uint64 )(_dgbb error ){var (_adbd byte ;_cgff int ;);for _afgfd :=1;_afgfd <=_aaddb ;_afgfd ++{_cgff =64-_afgfd *8;_adbd =byte (_dgbab >>uint (_cgff )&0xff);if _dgbb =_bfbe .setByte (_dagd +_afgfd -1,_adbd );
_dgbb !=nil {return _dgbb ;};};_ceg :=_bfbe .BytesPerLine *8-_bfbe .Width ;if _ceg ==0{return nil ;};_cgff -=8;_adbd =byte (_dgbab >>uint (_cgff )&0xff)<<uint (_ceg );if _dgbb =_bfbe .setByte (_dagd +_aaddb ,_adbd );_dgbb !=nil {return _dgbb ;};return nil ;
};func _egede (_bgab _c .NRGBA )_c .NRGBA {_bgab .R =_bgab .R >>4|(_bgab .R >>4)<<4;_bgab .G =_bgab .G >>4|(_bgab .G >>4)<<4;_bgab .B =_bgab .B >>4|(_bgab .B >>4)<<4;return _bgab ;};func (_fage *ImageBase )setTwoBytes (_bbcb int ,_cebd uint16 )error {if _bbcb +1> len (_fage .Data )-1{return _ba .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_fage .Data [_bbcb ]=byte ((_cebd &0xff00)>>8);_fage .Data [_bbcb +1]=byte (_cebd &0xff);return nil ;};func (_dabf *NRGBA32 )setRGBA (_feba int ,_eecg _c .NRGBA ){_fbbaa :=3*_feba ;_dabf .Data [_fbbaa ]=_eecg .R ;_dabf .Data [_fbbaa +1]=_eecg .G ;_dabf .Data [_fbbaa +2]=_eecg .B ;
if _feba < len (_dabf .Alpha ){_dabf .Alpha [_feba ]=_eecg .A ;};};var _ _bb .Image =&Gray2 {};func (_gdca monochromeModel )Convert (c _c .Color )_c .Color {_fbgd :=_c .GrayModel .Convert (c ).(_c .Gray );return _adf (_fbgd ,_gdca );};func _adf (_afag _c .Gray ,_fagbc monochromeModel )_c .Gray {if _afag .Y > uint8 (_fagbc ){return _c .Gray {Y :_f .MaxUint8 };
};return _c .Gray {};};func _deae (_egdcb _bb .Image )(Image ,error ){if _cbbg ,_bbgd :=_egdcb .(*NRGBA64 );_bbgd {return _cbbg .Copy (),nil ;};_dfgc ,_dbeda ,_eaad :=_edgb (_egdcb ,2);_gdab ,_ddae :=NewImage (_dfgc .Max .X ,_dfgc .Max .Y ,16,3,nil ,_eaad ,nil );
if _ddae !=nil {return nil ,_ddae ;};_agcf (_egdcb ,_gdab ,_dfgc );if len (_eaad )!=0&&!_dbeda {if _gbbca :=_ggdf (_eaad ,_gdab );_gbbca !=nil {return nil ,_gbbca ;};};return _gdab ,nil ;};func (_bacb *NRGBA64 )At (x ,y int )_c .Color {_abag ,_ :=_bacb .ColorAt (x ,y );
return _abag };func (_eedc *NRGBA64 )Validate ()error {if len (_eedc .Data )!=3*2*_eedc .Width *_eedc .Height {return _ba .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_c .CMYK ,error ){_ggb :=4*(y *width +x );if _ggb +3>=len (data ){return _c .CMYK {},_cd .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};C :=data [_ggb ]&0xff;M :=data [_ggb +1]&0xff;Y :=data [_ggb +2]&0xff;K :=data [_ggb +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);
Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _c .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};func (_cec *Gray2 )Base ()*ImageBase {return &_cec .ImageBase };
func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray ,error ){_dcfd :=y *bytesPerLine +x >>3;if _dcfd >=len (data ){return _c .Gray {},_cd .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_dec :=data [_dcfd ]>>uint (7-(x &7))&1;if len (decode )==2{_dec =uint8 (LinearInterpolate (float64 (_dec ),0.0,1.0,decode [0],decode [1]))&1;};return _c .Gray {Y :_dec *255},nil ;};func (_ggae *NRGBA64 )ColorModel ()_c .Model {return _c .NRGBA64Model };
func (_cedd *Gray4 )Set (x ,y int ,c _c .Color ){if x >=_cedd .Width ||y >=_cedd .Height {return ;};_ccbd :=Gray4Model .Convert (c ).(_c .Gray );_cedd .setGray (x ,y ,_ccbd );};func (_gccc *NRGBA16 )Base ()*ImageBase {return &_gccc .ImageBase };func _dbga (_afd _c .CMYK )_c .NRGBA {_acdb ,_begf ,_ggag :=_c .CMYKToRGB (_afd .C ,_afd .M ,_afd .Y ,_afd .K );
return _c .NRGBA {R :_acdb ,G :_begf ,B :_ggag ,A :0xff};};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;case 2:return Gray2Converter ,nil ;
case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;};
case 4:return CMYKConverter ,nil ;};return nil ,_cd .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );
};func (_ffd *Monochrome )setGrayBit (_bagd ,_aded int ){_ffd .Data [_bagd ]|=0x80>>uint (_aded &7)};func (_bcfd *ImageBase )setByte (_eeac int ,_abd byte )error {if _eeac > len (_bcfd .Data )-1{return _ba .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_bcfd .Data [_eeac ]=_abd ;return nil ;};func (_adbc *NRGBA16 )Validate ()error {if len (_adbc .Data )!=3*_adbc .Width *_adbc .Height /2{return _ba .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func init (){_dbgg ()};func (_cfeca *Gray16 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray16BPC (x ,y ,_cfeca .BytesPerLine ,_cfeca .Data ,_cfeca .Decode );};func _eaf (_efa ,_cae *Monochrome ,_bcf []byte ,_ecd int )(_ded error ){var (_agc ,_gfa ,_fefe ,_aga ,_ceb ,_eafc ,_aca ,_gag int ;
_fgd ,_beg ,_dcf ,_ddf uint32 ;_fab ,_bga byte ;_begb uint16 ;);_cfc :=make ([]byte ,4);_egc :=make ([]byte ,4);for _fefe =0;_fefe < _efa .Height -1;_fefe ,_aga =_fefe +2,_aga +1{_agc =_fefe *_efa .BytesPerLine ;_gfa =_aga *_cae .BytesPerLine ;for _ceb ,_eafc =0,0;
_ceb < _ecd ;_ceb ,_eafc =_ceb +4,_eafc +1{for _aca =0;_aca < 4;_aca ++{_gag =_agc +_ceb +_aca ;if _gag <=len (_efa .Data )-1&&_gag < _agc +_efa .BytesPerLine {_cfc [_aca ]=_efa .Data [_gag ];}else {_cfc [_aca ]=0x00;};_gag =_agc +_efa .BytesPerLine +_ceb +_aca ;
if _gag <=len (_efa .Data )-1&&_gag < _agc +(2*_efa .BytesPerLine ){_egc [_aca ]=_efa .Data [_gag ];}else {_egc [_aca ]=0x00;};};_fgd =_a .BigEndian .Uint32 (_cfc );_beg =_a .BigEndian .Uint32 (_egc );_dcf =_fgd &_beg ;_dcf |=_dcf <<1;_ddf =_fgd |_beg ;
_ddf &=_ddf <<1;_beg =_dcf |_ddf ;_beg &=0xaaaaaaaa;_fgd =_beg |(_beg <<7);_fab =byte (_fgd >>24);_bga =byte ((_fgd >>8)&0xff);_gag =_gfa +_eafc ;if _gag +1==len (_cae .Data )-1||_gag +1>=_gfa +_cae .BytesPerLine {if _ded =_cae .setByte (_gag ,_bcf [_fab ]);
_ded !=nil {return _cd .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_gag );};}else {_begb =(uint16 (_bcf [_fab ])<<8)|uint16 (_bcf [_bga ]);if _ded =_cae .setTwoBytes (_gag ,_begb );_ded !=nil {return _cd .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_gag );
};_eafc ++;};};};return nil ;};func _eeb (_gac _c .NRGBA64 )_c .Gray {var _dga _c .NRGBA64 ;if _gac ==_dga {return _c .Gray {Y :0xff};};_cfa ,_ddba ,_gca ,_ :=_gac .RGBA ();_fcbc :=(19595*_cfa +38470*_ddba +7471*_gca +1<<15)>>24;return _c .Gray {Y :uint8 (_fcbc )};
};func _abbc (_agfd Gray ,_gcbb nrgba64 ,_fee _bb .Rectangle ){for _acbf :=0;_acbf < _fee .Max .X ;_acbf ++{for _cbaf :=0;_cbaf < _fee .Max .Y ;_cbaf ++{_fabe :=_eeb (_gcbb .NRGBA64At (_acbf ,_cbaf ));_agfd .SetGray (_acbf ,_cbaf ,_fabe );};};};type NRGBA interface{NRGBAAt (_fdab ,_cece int )_c .NRGBA ;
SetNRGBA (_agdd ,_dab int ,_abed _c .NRGBA );};func _decd (_gbbfa *Monochrome ,_addg ,_gaddc ,_fgef ,_ggea int ,_geed RasterOperator ,_fcdca *Monochrome ,_baeg ,_efef int )error {var (_fdgd byte ;_degbg int ;_dede int ;_bggda ,_debg int ;_dddgg ,_ffaga int ;
);_cfbf :=_fgef >>3;_gefag :=_fgef &7;if _gefag > 0{_fdgd =_bdedc [_gefag ];};_degbg =_fcdca .BytesPerLine *_efef +(_baeg >>3);_dede =_gbbfa .BytesPerLine *_gaddc +(_addg >>3);switch _geed {case PixSrc :for _dddgg =0;_dddgg < _ggea ;_dddgg ++{_bggda =_degbg +_dddgg *_fcdca .BytesPerLine ;
_debg =_dede +_dddgg *_gbbfa .BytesPerLine ;for _ffaga =0;_ffaga < _cfbf ;_ffaga ++{_gbbfa .Data [_debg ]=_fcdca .Data [_bggda ];_debg ++;_bggda ++;};if _gefag > 0{_gbbfa .Data [_debg ]=_cgb (_gbbfa .Data [_debg ],_fcdca .Data [_bggda ],_fdgd );};};case PixNotSrc :for _dddgg =0;
_dddgg < _ggea ;_dddgg ++{_bggda =_degbg +_dddgg *_fcdca .BytesPerLine ;_debg =_dede +_dddgg *_gbbfa .BytesPerLine ;for _ffaga =0;_ffaga < _cfbf ;_ffaga ++{_gbbfa .Data [_debg ]=^(_fcdca .Data [_bggda ]);_debg ++;_bggda ++;};if _gefag > 0{_gbbfa .Data [_debg ]=_cgb (_gbbfa .Data [_debg ],^_fcdca .Data [_bggda ],_fdgd );
};};case PixSrcOrDst :for _dddgg =0;_dddgg < _ggea ;_dddgg ++{_bggda =_degbg +_dddgg *_fcdca .BytesPerLine ;_debg =_dede +_dddgg *_gbbfa .BytesPerLine ;for _ffaga =0;_ffaga < _cfbf ;_ffaga ++{_gbbfa .Data [_debg ]|=_fcdca .Data [_bggda ];_debg ++;_bggda ++;
};if _gefag > 0{_gbbfa .Data [_debg ]=_cgb (_gbbfa .Data [_debg ],_fcdca .Data [_bggda ]|_gbbfa .Data [_debg ],_fdgd );};};case PixSrcAndDst :for _dddgg =0;_dddgg < _ggea ;_dddgg ++{_bggda =_degbg +_dddgg *_fcdca .BytesPerLine ;_debg =_dede +_dddgg *_gbbfa .BytesPerLine ;
for _ffaga =0;_ffaga < _cfbf ;_ffaga ++{_gbbfa .Data [_debg ]&=_fcdca .Data [_bggda ];_debg ++;_bggda ++;};if _gefag > 0{_gbbfa .Data [_debg ]=_cgb (_gbbfa .Data [_debg ],_fcdca .Data [_bggda ]&_gbbfa .Data [_debg ],_fdgd );};};case PixSrcXorDst :for _dddgg =0;
_dddgg < _ggea ;_dddgg ++{_bggda =_degbg +_dddgg *_fcdca .BytesPerLine ;_debg =_dede +_dddgg *_gbbfa .BytesPerLine ;for _ffaga =0;_ffaga < _cfbf ;_ffaga ++{_gbbfa .Data [_debg ]^=_fcdca .Data [_bggda ];_debg ++;_bggda ++;};if _gefag > 0{_gbbfa .Data [_debg ]=_cgb (_gbbfa .Data [_debg ],_fcdca .Data [_bggda ]^_gbbfa .Data [_debg ],_fdgd );
};};case PixNotSrcOrDst :for _dddgg =0;_dddgg < _ggea ;_dddgg ++{_bggda =_degbg +_dddgg *_fcdca .BytesPerLine ;_debg =_dede +_dddgg *_gbbfa .BytesPerLine ;for _ffaga =0;_ffaga < _cfbf ;_ffaga ++{_gbbfa .Data [_debg ]|=^(_fcdca .Data [_bggda ]);_debg ++;
_bggda ++;};if _gefag > 0{_gbbfa .Data [_debg ]=_cgb (_gbbfa .Data [_debg ],^(_fcdca .Data [_bggda ])|_gbbfa .Data [_debg ],_fdgd );};};case PixNotSrcAndDst :for _dddgg =0;_dddgg < _ggea ;_dddgg ++{_bggda =_degbg +_dddgg *_fcdca .BytesPerLine ;_debg =_dede +_dddgg *_gbbfa .BytesPerLine ;
for _ffaga =0;_ffaga < _cfbf ;_ffaga ++{_gbbfa .Data [_debg ]&=^(_fcdca .Data [_bggda ]);_debg ++;_bggda ++;};if _gefag > 0{_gbbfa .Data [_debg ]=_cgb (_gbbfa .Data [_debg ],^(_fcdca .Data [_bggda ])&_gbbfa .Data [_debg ],_fdgd );};};case PixSrcOrNotDst :for _dddgg =0;
_dddgg < _ggea ;_dddgg ++{_bggda =_degbg +_dddgg *_fcdca .BytesPerLine ;_debg =_dede +_dddgg *_gbbfa .BytesPerLine ;for _ffaga =0;_ffaga < _cfbf ;_ffaga ++{_gbbfa .Data [_debg ]=_fcdca .Data [_bggda ]|^(_gbbfa .Data [_debg ]);_debg ++;_bggda ++;};if _gefag > 0{_gbbfa .Data [_debg ]=_cgb (_gbbfa .Data [_debg ],_fcdca .Data [_bggda ]|^(_gbbfa .Data [_debg ]),_fdgd );
};};case PixSrcAndNotDst :for _dddgg =0;_dddgg < _ggea ;_dddgg ++{_bggda =_degbg +_dddgg *_fcdca .BytesPerLine ;_debg =_dede +_dddgg *_gbbfa .BytesPerLine ;for _ffaga =0;_ffaga < _cfbf ;_ffaga ++{_gbbfa .Data [_debg ]=_fcdca .Data [_bggda ]&^(_gbbfa .Data [_debg ]);
_debg ++;_bggda ++;};if _gefag > 0{_gbbfa .Data [_debg ]=_cgb (_gbbfa .Data [_debg ],_fcdca .Data [_bggda ]&^(_gbbfa .Data [_debg ]),_fdgd );};};case PixNotPixSrcOrDst :for _dddgg =0;_dddgg < _ggea ;_dddgg ++{_bggda =_degbg +_dddgg *_fcdca .BytesPerLine ;
_debg =_dede +_dddgg *_gbbfa .BytesPerLine ;for _ffaga =0;_ffaga < _cfbf ;_ffaga ++{_gbbfa .Data [_debg ]=^(_fcdca .Data [_bggda ]|_gbbfa .Data [_debg ]);_debg ++;_bggda ++;};if _gefag > 0{_gbbfa .Data [_debg ]=_cgb (_gbbfa .Data [_debg ],^(_fcdca .Data [_bggda ]|_gbbfa .Data [_debg ]),_fdgd );
};};case PixNotPixSrcAndDst :for _dddgg =0;_dddgg < _ggea ;_dddgg ++{_bggda =_degbg +_dddgg *_fcdca .BytesPerLine ;_debg =_dede +_dddgg *_gbbfa .BytesPerLine ;for _ffaga =0;_ffaga < _cfbf ;_ffaga ++{_gbbfa .Data [_debg ]=^(_fcdca .Data [_bggda ]&_gbbfa .Data [_debg ]);
_debg ++;_bggda ++;};if _gefag > 0{_gbbfa .Data [_debg ]=_cgb (_gbbfa .Data [_debg ],^(_fcdca .Data [_bggda ]&_gbbfa .Data [_debg ]),_fdgd );};};case PixNotPixSrcXorDst :for _dddgg =0;_dddgg < _ggea ;_dddgg ++{_bggda =_degbg +_dddgg *_fcdca .BytesPerLine ;
_debg =_dede +_dddgg *_gbbfa .BytesPerLine ;for _ffaga =0;_ffaga < _cfbf ;_ffaga ++{_gbbfa .Data [_debg ]=^(_fcdca .Data [_bggda ]^_gbbfa .Data [_debg ]);_debg ++;_bggda ++;};if _gefag > 0{_gbbfa .Data [_debg ]=_cgb (_gbbfa .Data [_debg ],^(_fcdca .Data [_bggda ]^_gbbfa .Data [_debg ]),_fdgd );
};};default:_fa .Log .Debug ("\u0050\u0072ov\u0069\u0064\u0065d\u0020\u0069\u006e\u0076ali\u0064 r\u0061\u0073\u0074\u0065\u0072\u0020\u006fpe\u0072\u0061\u0074\u006f\u0072\u003a\u0020%\u0076",_geed );return _ba .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");
};return nil ;};func (_ffdf *ImageBase )copy ()ImageBase {_dadc :=*_ffdf ;_dadc .Data =make ([]byte ,len (_ffdf .Data ));copy (_dadc .Data ,_ffdf .Data );return _dadc ;};func (_eec *Gray2 )GrayAt (x ,y int )_c .Gray {_dbfc ,_ :=ColorAtGray2BPC (x ,y ,_eec .BytesPerLine ,_eec .Data ,_eec .Decode );
return _dbfc ;};var _ Gray =&Gray16 {};func (_dcgb *Monochrome )At (x ,y int )_c .Color {_aef ,_ :=_dcgb .ColorAt (x ,y );return _aef };func (_adaf *Monochrome )ExpandBinary (factor int )(*Monochrome ,error ){if !IsPowerOf2 (uint (factor )){return nil ,_cd .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0065\u0078\u0070\u0061\u006e\u0064\u0020b\u0069n\u0061\u0072\u0079\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",factor );
};return _e (_adaf ,factor );};func _ecdc (_agf NRGBA ,_gbdb CMYK ,_dba _bb .Rectangle ){for _gadd :=0;_gadd < _dba .Max .X ;_gadd ++{for _aed :=0;_aed < _dba .Max .Y ;_aed ++{_fgbb :=_agf .NRGBAAt (_gadd ,_aed );_gbdb .SetCMYK (_gadd ,_aed ,_cca (_fgbb ));
};};};func (_fbcb *NRGBA32 )Set (x ,y int ,c _c .Color ){_edeae :=y *_fbcb .Width +x ;_dbgaa :=3*_edeae ;if _dbgaa +2>=len (_fbcb .Data ){return ;};_efdf :=_c .NRGBAModel .Convert (c ).(_c .NRGBA );_fbcb .setRGBA (_edeae ,_efdf );};func _acd (_dcd int )[]uint {var _fdf []uint ;
_bda :=_dcd ;_deg :=_bda /8;if _deg !=0{for _eag :=0;_eag < _deg ;_eag ++{_fdf =append (_fdf ,8);};_fea :=_bda %8;_bda =0;if _fea !=0{_bda =_fea ;};};_aad :=_bda /4;if _aad !=0{for _fafb :=0;_fafb < _aad ;_fafb ++{_fdf =append (_fdf ,4);};_fcc :=_bda %4;
_bda =0;if _fcc !=0{_bda =_fcc ;};};_af :=_bda /2;if _af !=0{for _fac :=0;_fac < _af ;_fac ++{_fdf =append (_fdf ,2);};};return _fdf ;};func _gee (_affb _c .RGBA )_c .Gray {_afge :=(19595*uint32 (_affb .R )+38470*uint32 (_affb .G )+7471*uint32 (_affb .B )+1<<7)>>16;
return _c .Gray {Y :uint8 (_afge )};};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_gefa :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};
if data ==nil {_gefa .Data =make ([]byte ,height *_gefa .BytesPerLine );};return _gefa ;};var _ _bb .Image =&Monochrome {};func IsGrayImgBlackAndWhite (i *_bb .Gray )bool {return _fbedg (i )};func _fgbc (_fege CMYK ,_abab Gray ,_acfa _bb .Rectangle ){for _bacg :=0;
_bacg < _acfa .Max .X ;_bacg ++{for _gcaae :=0;_gcaae < _acfa .Max .Y ;_gcaae ++{_edcg :=_feac (_fege .CMYKAt (_bacg ,_gcaae ));_abab .SetGray (_bacg ,_gcaae ,_edcg );};};};func _aegb (_ega RGBA ,_dcee Gray ,_adad _bb .Rectangle ){for _eebd :=0;_eebd < _adad .Max .X ;
_eebd ++{for _bbef :=0;_bbef < _adad .Max .Y ;_bbef ++{_edfd :=_gee (_ega .RGBAAt (_eebd ,_bbef ));_dcee .SetGray (_eebd ,_bbef ,_edfd );};};};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );
case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );
default:return nil ,_cd .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func NextPowerOf2 (n uint )uint {if IsPowerOf2 (n ){return n ;};return 1<<(_eaec (n )+1);};func (_ageg *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_ageg .copy ()}};var _ _bb .Image =&Gray4 {};var _ Gray =&Gray8 {};var ErrInvalidImage =_ba .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
func (_fcdb *Gray4 )Bounds ()_bb .Rectangle {return _bb .Rectangle {Max :_bb .Point {X :_fcdb .Width ,Y :_fcdb .Height }};};func _edgb (_gfed _bb .Image ,_efga int )(_bb .Rectangle ,bool ,[]byte ){_cdfa :=_gfed .Bounds ();var (_gdce bool ;_egdc []byte ;
);switch _adedb :=_gfed .(type ){case SMasker :_gdce =_adedb .HasAlpha ();case NRGBA ,RGBA ,*_bb .RGBA64 ,nrgba64 ,*_bb .NYCbCrA :_egdc =make ([]byte ,_cdfa .Max .X *_cdfa .Max .Y *_efga );case *_bb .Paletted :var _fgbcf bool ;for _ ,_gbaab :=range _adedb .Palette {_gcdef ,_gcdd ,_cagf ,_ffacd :=_gbaab .RGBA ();
if _gcdef ==0&&_gcdd ==0&&_cagf ==0&&_ffacd !=0{_fgbcf =true ;break ;};};if _fgbcf {_egdc =make ([]byte ,_cdfa .Max .X *_cdfa .Max .Y *_efga );};};return _cdfa ,_gdce ,_egdc ;};func ImgToGray (i _bb .Image )*_bb .Gray {if _aaeg ,_adfdb :=i .(*_bb .Gray );
_adfdb {return _aaeg ;};_eceb :=i .Bounds ();_eaca :=_bb .NewGray (_eceb );for _gged :=0;_gged < _eceb .Max .X ;_gged ++{for _gfce :=0;_gfce < _eceb .Max .Y ;_gfce ++{_addf :=i .At (_gged ,_gfce );_eaca .Set (_gged ,_gfce ,_addf );};};return _eaca ;};func _fdg (_adaa _c .Color )_c .Color {_ggbb :=_c .GrayModel .Convert (_adaa ).(_c .Gray );
return _ffac (_ggbb );};func (_acac *Gray4 )setGray (_bdgbf int ,_ccgc int ,_dagb _c .Gray ){_gdcd :=_ccgc *_acac .BytesPerLine ;_fcad :=_gdcd +(_bdgbf >>1);if _fcad >=len (_acac .Data ){return ;};_ggbc :=_dagb .Y >>4;_acac .Data [_fcad ]=(_acac .Data [_fcad ]&(^(0xf0>>uint (4*(_bdgbf &1)))))|(_ggbc <<uint (4-4*(_bdgbf &1)));
};var _ Image =&Gray2 {};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_c .NRGBA ,error ){_abfg :=y *bytesPerLine +x *3/2;if _abfg +1>=len (data ){return _c .NRGBA {},_afda (x ,y );};const (_daafe =0xf;_dfg =uint8 (0xff);
);_gbcd :=_dfg ;if alpha !=nil {_fbgb :=y *BytesPerLine (width ,4,1);if _fbgb < len (alpha ){if x %2==0{_gbcd =(alpha [_fbgb ]>>uint (4))&_daafe ;}else {_gbcd =alpha [_fbgb ]&_daafe ;};_gbcd |=_gbcd <<4;};};var _cdgb ,_efge ,_cceg uint8 ;if x *3%2==0{_cdgb =(data [_abfg ]>>uint (4))&_daafe ;
_efge =data [_abfg ]&_daafe ;_cceg =(data [_abfg +1]>>uint (4))&_daafe ;}else {_cdgb =data [_abfg ]&_daafe ;_efge =(data [_abfg +1]>>uint (4))&_daafe ;_cceg =data [_abfg +1]&_daafe ;};if len (decode )==6{_cdgb =uint8 (uint32 (LinearInterpolate (float64 (_cdgb ),0,15,decode [0],decode [1]))&0xf);
_efge =uint8 (uint32 (LinearInterpolate (float64 (_efge ),0,15,decode [2],decode [3]))&0xf);_cceg =uint8 (uint32 (LinearInterpolate (float64 (_cceg ),0,15,decode [4],decode [5]))&0xf);};return _c .NRGBA {R :(_cdgb <<4)|(_cdgb &0xf),G :(_efge <<4)|(_efge &0xf),B :(_cceg <<4)|(_cceg &0xf),A :_gbcd },nil ;
};func (_bgea *Monochrome )setGray (_gcfg int ,_bbd _c .Gray ,_dfee int ){if _bbd .Y ==0{_bgea .clearBit (_dfee ,_gcfg );}else {_bgea .setGrayBit (_dfee ,_gcfg );};};func _dcgd (_gae ,_cfd *Monochrome ,_efb []byte ,_egf int )(_gad error ){var (_fbfe ,_fce ,_dffc ,_dcb ,_face ,_cbe ,_eee ,_gcd int ;
_fcb ,_afc uint32 ;_gfc ,_ege byte ;_aade uint16 ;);_cad :=make ([]byte ,4);_gbeg :=make ([]byte ,4);for _dffc =0;_dffc < _gae .Height -1;_dffc ,_dcb =_dffc +2,_dcb +1{_fbfe =_dffc *_gae .BytesPerLine ;_fce =_dcb *_cfd .BytesPerLine ;for _face ,_cbe =0,0;
_face < _egf ;_face ,_cbe =_face +4,_cbe +1{for _eee =0;_eee < 4;_eee ++{_gcd =_fbfe +_face +_eee ;if _gcd <=len (_gae .Data )-1&&_gcd < _fbfe +_gae .BytesPerLine {_cad [_eee ]=_gae .Data [_gcd ];}else {_cad [_eee ]=0x00;};_gcd =_fbfe +_gae .BytesPerLine +_face +_eee ;
if _gcd <=len (_gae .Data )-1&&_gcd < _fbfe +(2*_gae .BytesPerLine ){_gbeg [_eee ]=_gae .Data [_gcd ];}else {_gbeg [_eee ]=0x00;};};_fcb =_a .BigEndian .Uint32 (_cad );_afc =_a .BigEndian .Uint32 (_gbeg );_afc &=_fcb ;_afc &=_afc <<1;_afc &=0xaaaaaaaa;
_fcb =_afc |(_afc <<7);_gfc =byte (_fcb >>24);_ege =byte ((_fcb >>8)&0xff);_gcd =_fce +_cbe ;if _gcd +1==len (_cfd .Data )-1||_gcd +1>=_fce +_cfd .BytesPerLine {_cfd .Data [_gcd ]=_efb [_gfc ];if _gad =_cfd .setByte (_gcd ,_efb [_gfc ]);_gad !=nil {return _cd .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_gcd );
};}else {_aade =(uint16 (_efb [_gfc ])<<8)|uint16 (_efb [_ege ]);if _gad =_cfd .setTwoBytes (_gcd ,_aade );_gad !=nil {return _cd .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_gcd );
};_cbe ++;};};};return nil ;};func (_fbed *Gray16 )Histogram ()(_cfag [256]int ){for _fabf :=0;_fabf < _fbed .Width ;_fabf ++{for _edce :=0;_edce < _fbed .Height ;_edce ++{_cfag [_fbed .GrayAt (_fabf ,_edce ).Y ]++;};};return _cfag ;};func _fgec (_bage _c .Color )_c .Color {_fgdf :=_c .GrayModel .Convert (_bage ).(_c .Gray );
return _caeb (_fgdf );};func (_fdd *Gray4 )Base ()*ImageBase {return &_fdd .ImageBase };func (_beegd *ImageBase )getByte (_dadd int )(byte ,error ){if _dadd > len (_beegd .Data )-1||_dadd < 0{return 0,_cd .Errorf ("\u0069\u006e\u0064\u0065x:\u0020\u0025\u0064\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006eg\u0065",_dadd );
};return _beegd .Data [_dadd ],nil ;};func _cced (_agac _c .NRGBA )_c .RGBA {_dgac ,_gggc ,_cdga ,_dfaa :=_agac .RGBA ();return _c .RGBA {R :uint8 (_dgac >>8),G :uint8 (_gggc >>8),B :uint8 (_cdga >>8),A :uint8 (_dfaa >>8)};};func (_dfed *CMYK32 )SetCMYK (x ,y int ,c _c .CMYK ){_bdff :=4*(y *_dfed .Width +x );
if _bdff +3>=len (_dfed .Data ){return ;};_dfed .Data [_bdff ]=c .C ;_dfed .Data [_bdff +1]=c .M ;_dfed .Data [_bdff +2]=c .Y ;_dfed .Data [_bdff +3]=c .K ;};func _gcbba (_daac Gray ,_abdef NRGBA ,_beaa _bb .Rectangle ){for _degf :=0;_degf < _beaa .Max .X ;
_degf ++{for _acdbd :=0;_acdbd < _beaa .Max .Y ;_acdbd ++{_gdcb :=_daac .GrayAt (_degf ,_acdbd );_abdef .SetNRGBA (_degf ,_acdbd ,_dg (_gdcb ));};};};func (_dcgc *CMYK32 )ColorModel ()_c .Model {return _c .CMYKModel };func _fbd (_efd _c .CMYK )_c .RGBA {_aeg ,_dffge ,_cab :=_c .CMYKToRGB (_efd .C ,_efd .M ,_efd .Y ,_efd .K );
return _c .RGBA {R :_aeg ,G :_dffge ,B :_cab ,A :0xff};};func _aagb (_ffcd uint8 )bool {if _ffcd ==0||_ffcd ==255{return true ;};return false ;};func (_cfdg *Monochrome )setIndexedBit (_gggg int ){_cfdg .Data [(_gggg >>3)]|=0x80>>uint (_gggg &7)};func (_bbaf *RGBA32 )ColorModel ()_c .Model {return _c .NRGBAModel };
func (_bgc *Gray4 )Histogram ()(_acg [256]int ){for _cdbc :=0;_cdbc < _bgc .Width ;_cdbc ++{for _cbgb :=0;_cbgb < _bgc .Height ;_cbgb ++{_acg [_bgc .GrayAt (_cdbc ,_cbgb ).Y ]++;};};return _acg ;};func _ag (_bgf *Monochrome ,_dag ,_cda int )(*Monochrome ,error ){if _bgf ==nil {return nil ,_ba .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _dag <=0||_cda <=0{return nil ,_ba .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0063\u0061l\u0065\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020<\u003d\u0020\u0030");};if _dag ==_cda {if _dag ==1{return _bgf .copy (),nil ;
};if _dag ==2||_dag ==4||_dag ==8{_bf ,_egg :=_e (_bgf ,_dag );if _egg !=nil {return nil ,_egg ;};return _bf ,nil ;};};_bge :=_dag *_bgf .Width ;_cc :=_cda *_bgf .Height ;_bggb :=_eaa (_bge ,_cc );_cgc :=_bggb .BytesPerLine ;var (_ee ,_faa ,_adg ,_gga ,_fba int ;
_dda byte ;_ed error ;);for _faa =0;_faa < _bgf .Height ;_faa ++{_ee =_cda *_faa *_cgc ;for _adg =0;_adg < _bgf .Width ;_adg ++{if _gcg :=_bgf .getBitAt (_adg ,_faa );_gcg {_fba =_dag *_adg ;for _gga =0;_gga < _dag ;_gga ++{_bggb .setIndexedBit (_ee *8+_fba +_gga );
};};};for _gga =1;_gga < _cda ;_gga ++{_db :=_ee +_gga *_cgc ;for _fgg :=0;_fgg < _cgc ;_fgg ++{if _dda ,_ed =_bggb .getByte (_ee +_fgg );_ed !=nil {return nil ,_ed ;};if _ed =_bggb .setByte (_db +_fgg ,_dda );_ed !=nil {return nil ,_ed ;};};};};return _bggb ,nil ;
};var _ _bb .Image =&NRGBA64 {};func (_dac *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_dac .copy ()}};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray16 ,error ){_acge :=(y *bytesPerLine /2+x )*2;if _acge +1>=len (data ){return _c .Gray16 {},_cd .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_dcafc :=uint16 (data [_acge ])<<8|uint16 (data [_acge +1]);if len (decode )==2{_dcafc =uint16 (uint64 (LinearInterpolate (float64 (_dcafc ),0,65535,decode [0],decode [1])));};return _c .Gray16 {Y :_dcafc },nil ;};func MonochromeModel (threshold uint8 )_c .Model {return monochromeModel (threshold )};
func ConverterFunc (converterFunc func (_cbda _bb .Image )(Image ,error ))ColorConverter {return colorConverter {_cce :converterFunc };};func _cdb (_eagda _c .NYCbCrA )_c .NRGBA {_ggff :=int32 (_eagda .Y )*0x10101;_bce :=int32 (_eagda .Cb )-128;_fad :=int32 (_eagda .Cr )-128;
_dafe :=_ggff +91881*_fad ;if uint32 (_dafe )&0xff000000==0{_dafe >>=8;}else {_dafe =^(_dafe >>31)&0xffff;};_aebc :=_ggff -22554*_bce -46802*_fad ;if uint32 (_aebc )&0xff000000==0{_aebc >>=8;}else {_aebc =^(_aebc >>31)&0xffff;};_cdf :=_ggff +116130*_bce ;
if uint32 (_cdf )&0xff000000==0{_cdf >>=8;}else {_cdf =^(_cdf >>31)&0xffff;};return _c .NRGBA {R :uint8 (_dafe >>8),G :uint8 (_aebc >>8),B :uint8 (_cdf >>8),A :_eagda .A };};func (_bfgaf *Gray8 )Set (x ,y int ,c _c .Color ){_eaaa :=y *_bfgaf .BytesPerLine +x ;
if _eaaa > len (_bfgaf .Data )-1{return ;};_dddg :=_c .GrayModel .Convert (c );_bfgaf .Data [_eaaa ]=_dddg .(_c .Gray ).Y ;};type CMYK interface{CMYKAt (_fcee ,_eged int )_c .CMYK ;SetCMYK (_bdfa ,_gef int ,_egfb _c .CMYK );};var _ Gray =&Gray2 {};type NRGBA16 struct{ImageBase };
func GrayHistogram (g Gray )(_aggc [256]int ){switch _dffgg :=g .(type ){case Histogramer :return _dffgg .Histogram ();case _bb .Image :_afdf :=_dffgg .Bounds ();for _fffde :=0;_fffde < _afdf .Max .X ;_fffde ++{for _fgdc :=0;_fgdc < _afdf .Max .Y ;_fgdc ++{_aggc [g .GrayAt (_fffde ,_fgdc ).Y ]++;
};};return _aggc ;default:return [256]int {};};};func (_cffe *Gray16 )Validate ()error {if len (_cffe .Data )!=_cffe .Height *_cffe .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_fdcb *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_fdcb .copy ()}};
func _aag (_bbfd ,_gfgd NRGBA ,_cee _bb .Rectangle ){for _cedb :=0;_cedb < _cee .Max .X ;_cedb ++{for _fagf :=0;_fagf < _cee .Max .Y ;_fagf ++{_gfgd .SetNRGBA (_cedb ,_fagf ,_bbfd .NRGBAAt (_cedb ,_fagf ));};};};var _ _bb .Image =&NRGBA32 {};func (_affg *Monochrome )Set (x ,y int ,c _c .Color ){_ead :=y *_affg .BytesPerLine +x >>3;
if _ead > len (_affg .Data )-1{return ;};_dbab :=_affg .ColorModel ().Convert (c ).(_c .Gray );_affg .setGray (x ,_dbab ,_ead );};func (_bed *Gray2 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray2BPC (x ,y ,_bed .BytesPerLine ,_bed .Data ,_bed .Decode );
};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_c .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );
case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_cd .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );
};};func (_agdbc *RGBA32 )Bounds ()_bb .Rectangle {return _bb .Rectangle {Max :_bb .Point {X :_agdbc .Width ,Y :_agdbc .Height }};};func _agcf (_cdgg _bb .Image ,_geb Image ,_gccb _bb .Rectangle ){if _becee ,_beb :=_cdgg .(SMasker );_beb &&_becee .HasAlpha (){_geb .(SMasker ).MakeAlpha ();
};_bcc (_cdgg ,_geb ,_gccb );};func (_dead *Gray2 )Bounds ()_bb .Rectangle {return _bb .Rectangle {Max :_bb .Point {X :_dead .Width ,Y :_dead .Height }};};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray ,error ){_ecbb :=y *bytesPerLine +x >>2;
if _ecbb >=len (data ){return _c .Gray {},_cd .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_ceca :=data [_ecbb ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_ceca =uint8 (uint32 (LinearInterpolate (float64 (_ceca ),0,3.0,decode [0],decode [1]))&3);};return _c .Gray {Y :_ceca *85},nil ;};func (_bfga *monochromeThresholdConverter )Convert (img _bb .Image )(Image ,error ){if _gdef ,_ffb :=img .(*Monochrome );
_ffb {return _gdef .Copy (),nil ;};_cbb :=img .Bounds ();_edfg ,_gbbc :=NewImage (_cbb .Max .X ,_cbb .Max .Y ,1,1,nil ,nil ,nil );if _gbbc !=nil {return nil ,_gbbc ;};_edfg .(*Monochrome ).ModelThreshold =_bfga .Threshold ;for _bccf :=0;_bccf < _cbb .Max .X ;
_bccf ++{for _ccfe :=0;_ccfe < _cbb .Max .Y ;_ccfe ++{_dfbe :=img .At (_bccf ,_ccfe );_edfg .Set (_bccf ,_ccfe ,_dfbe );};};return _edfg ,nil ;};func _aacg (_bdfc _c .NRGBA )_c .Gray {_abec ,_degbb ,_bbfg ,_ :=_bdfc .RGBA ();_dfeb :=(19595*_abec +38470*_degbb +7471*_bbfg +1<<15)>>24;
return _c .Gray {Y :uint8 (_dfeb )};};var _ _bb .Image =&Gray16 {};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_cebf :=BytesPerLine (width ,bitsPerComponent ,colorComponents );if _cebf ==width *colorComponents *bitsPerComponent /8{return data ,nil ;
};_ebf :=width *colorComponents *bitsPerComponent ;_begg :=_cebf *8;_bedg :=8-(_begg -_ebf );_ece :=_bg .NewReader (data );_ebc :=_cebf -1;_abda :=make ([]byte ,_ebc );_aacd :=make ([]byte ,height *_cebf );_gaae :=_bg .NewWriterMSB (_aacd );var _gcaf uint64 ;
var _feed error ;for _abc :=0;_abc < height ;_abc ++{_ ,_feed =_ece .Read (_abda );if _feed !=nil {return nil ,_feed ;};_ ,_feed =_gaae .Write (_abda );if _feed !=nil {return nil ,_feed ;};_gcaf ,_feed =_ece .ReadBits (byte (_bedg ));if _feed !=nil {return nil ,_feed ;
};_ ,_feed =_gaae .WriteBits (_gcaf ,_bedg );if _feed !=nil {return nil ,_feed ;};_gaae .FinishByte ();};return _aacd ,nil ;};func (_eddd *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_eddd .ImageBase .copy (),ModelThreshold :_eddd .ModelThreshold };
};func (_caca *ImageBase )setEightFullBytes (_faed int ,_aeff uint64 )error {if _faed +7> len (_caca .Data )-1{return _ba .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_caca .Data [_faed ]=byte ((_aeff &0xff00000000000000)>>56);
_caca .Data [_faed +1]=byte ((_aeff &0xff000000000000)>>48);_caca .Data [_faed +2]=byte ((_aeff &0xff0000000000)>>40);_caca .Data [_faed +3]=byte ((_aeff &0xff00000000)>>32);_caca .Data [_faed +4]=byte ((_aeff &0xff000000)>>24);_caca .Data [_faed +5]=byte ((_aeff &0xff0000)>>16);
_caca .Data [_faed +6]=byte ((_aeff &0xff00)>>8);_caca .Data [_faed +7]=byte (_aeff &0xff);return nil ;};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_c .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );
case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_cd .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func (_dafgb *Gray8 )SetGray (x ,y int ,g _c .Gray ){_beae :=y *_dafgb .BytesPerLine +x ;if _beae > len (_dafgb .Data )-1{return ;};_dafgb .Data [_beae ]=g .Y ;};func _fegd (_bcef _bb .Image )(Image ,error ){if _gbdg ,_ggad :=_bcef .(*NRGBA16 );_ggad {return _gbdg .Copy (),nil ;
};_dgc :=_bcef .Bounds ();_adadc ,_eeae :=NewImage (_dgc .Max .X ,_dgc .Max .Y ,4,3,nil ,nil ,nil );if _eeae !=nil {return nil ,_eeae ;};_bddb (_bcef ,_adadc ,_dgc );return _adadc ,nil ;};func _fbedg (_dgea *_bb .Gray )bool {for _abdb :=0;_abdb < len (_dgea .Pix );
_abdb ++{if !_aagb (_dgea .Pix [_abdb ]){return false ;};};return true ;};type RasterOperator int ;func _dfd (_fdb ,_be *Monochrome )(_cgg error ){_ge :=_be .BytesPerLine ;_gc :=_fdb .BytesPerLine ;_gg :=_be .BytesPerLine *4-_fdb .BytesPerLine ;var (_geg ,_dff byte ;
_ddg uint32 ;_fff ,_faee ,_gbb ,_ab ,_aa ,_ca ,_cfg int ;);for _gbb =0;_gbb < _be .Height ;_gbb ++{_fff =_gbb *_ge ;_faee =4*_gbb *_gc ;for _ab =0;_ab < _ge ;_ab ++{_geg =_be .Data [_fff +_ab ];_ddg =_faf [_geg ];_ca =_faee +_ab *4;if _gg !=0&&(_ab +1)*4> _fdb .BytesPerLine {for _aa =_gg ;
_aa > 0;_aa --{_dff =byte ((_ddg >>uint (_aa *8))&0xff);_cfg =_ca +(_gg -_aa );if _cgg =_fdb .setByte (_cfg ,_dff );_cgg !=nil {return _cgg ;};};}else if _cgg =_fdb .setFourBytes (_ca ,_ddg );_cgg !=nil {return _cgg ;};if _cgg =_fdb .setFourBytes (_faee +_ab *4,_faf [_be .Data [_fff +_ab ]]);
_cgg !=nil {return _cgg ;};};for _aa =1;_aa < 4;_aa ++{for _ab =0;_ab < _gc ;_ab ++{if _cgg =_fdb .setByte (_faee +_aa *_gc +_ab ,_fdb .Data [_faee +_ab ]);_cgg !=nil {return _cgg ;};};};};return nil ;};type CMYK32 struct{ImageBase };func RasterOperation (dest *Monochrome ,dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _afgb (dest ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};func _gddce (_aebg _bb .Image ,_cdced uint8 )*_bb .Gray {_gegb :=_aebg .Bounds ();_fafg :=_bb .NewGray (_gegb );var (_aeda _c .Color ;_ccea _c .Gray ;);for _ebde :=0;_ebde < _gegb .Max .X ;_ebde ++{for _gbg :=0;_gbg < _gegb .Max .Y ;_gbg ++{_aeda =_aebg .At (_ebde ,_gbg );
_fafg .Set (_ebde ,_gbg ,_aeda );_ccea =_fafg .GrayAt (_ebde ,_gbg );_fafg .SetGray (_ebde ,_gbg ,_c .Gray {Y :_ceba (_ccea .Y ,_cdced )});};};return _fafg ;};func (_cbfag *RGBA32 )Validate ()error {if len (_cbfag .Data )!=3*_cbfag .Width *_cbfag .Height {return _ba .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_cag *Gray2 )At (x ,y int )_c .Color {_eac ,_ :=_cag .ColorAt (x ,y );return _eac };func (_ccbcb *NRGBA32 )At (x ,y int )_c .Color {_cdec ,_ :=_ccbcb .ColorAt (x ,y );return _cdec };func (_ceff *NRGBA16 )ColorModel ()_c .Model {return NRGBA16Model };
var _ Image =&Gray16 {};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_c .NRGBA64 ,error ){_efdc :=(y *width +x )*2;_efba :=_efdc *3;if _efba +5>=len (data ){return _c .NRGBA64 {},_cd .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};const _fdda =0xffff;_agdb :=uint16 (_fdda );if alpha !=nil &&len (alpha )> _efdc +1{_agdb =uint16 (alpha [_efdc ])<<8|uint16 (alpha [_efdc +1]);};_egaf :=uint16 (data [_efba ])<<8|uint16 (data [_efba +1]);_bdede :=uint16 (data [_efba +2])<<8|uint16 (data [_efba +3]);
_fffbc :=uint16 (data [_efba +4])<<8|uint16 (data [_efba +5]);if len (decode )==6{_egaf =uint16 (uint64 (LinearInterpolate (float64 (_egaf ),0,65535,decode [0],decode [1]))&_fdda );_bdede =uint16 (uint64 (LinearInterpolate (float64 (_bdede ),0,65535,decode [2],decode [3]))&_fdda );
_fffbc =uint16 (uint64 (LinearInterpolate (float64 (_fffbc ),0,65535,decode [4],decode [5]))&_fdda );};return _c .NRGBA64 {R :_egaf ,G :_bdede ,B :_fffbc ,A :_agdb },nil ;};func (_aefa *Gray2 )Histogram ()(_cgcg [256]int ){for _fbdca :=0;_fbdca < _aefa .Width ;
_fbdca ++{for _bfb :=0;_bfb < _aefa .Height ;_bfb ++{_cgcg [_aefa .GrayAt (_fbdca ,_bfb ).Y ]++;};};return _cgcg ;};func (_fcd *CMYK32 )Base ()*ImageBase {return &_fcd .ImageBase };func (_baae *Monochrome )ScaleLow (width ,height int )(*Monochrome ,error ){if width < 0||height < 0{return nil ,_ba .New ("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0069\u0064t\u0068\u0020\u0061\u006e\u0064\u0020\u0068e\u0069\u0067\u0068\u0074");
};_eafec :=_eaa (width ,height );_bggg :=make ([]int ,height );_abgc :=make ([]int ,width );_debb :=float64 (_baae .Width )/float64 (width );_ffe :=float64 (_baae .Height )/float64 (height );for _ccbc :=0;_ccbc < height ;_ccbc ++{_bggg [_ccbc ]=int (_f .Min (_ffe *float64 (_ccbc )+0.5,float64 (_baae .Height -1)));
};for _acdf :=0;_acdf < width ;_acdf ++{_abgc [_acdf ]=int (_f .Min (_debb *float64 (_acdf )+0.5,float64 (_baae .Width -1)));};_afgea :=-1;_cbdf :=byte (0);for _dffde :=0;_dffde < height ;_dffde ++{_cbeg :=_bggg [_dffde ]*_baae .BytesPerLine ;_fcfe :=_dffde *_eafec .BytesPerLine ;
for _beaf :=0;_beaf < width ;_beaf ++{_cefe :=_abgc [_beaf ];if _cefe !=_afgea {_cbdf =_baae .getBit (_cbeg ,_cefe );if _cbdf !=0{_eafec .setBit (_fcfe ,_beaf );};_afgea =_cefe ;}else {if _cbdf !=0{_eafec .setBit (_fcfe ,_beaf );};};};};return _eafec ,nil ;
};func _afgb (_eccce *Monochrome ,_ggge ,_adfb ,_efdb ,_ggdef int ,_baaa RasterOperator ,_eaed *Monochrome ,_fcfa ,_abff int )error {if _eccce ==nil {return _ba .New ("\u006e\u0069\u006c\u0020\u0027\u0064\u0065\u0073\u0074\u0027\u0020\u0042i\u0074\u006d\u0061\u0070");
};if _baaa ==PixDst {return nil ;};switch _baaa {case PixClr ,PixSet ,PixNotDst :_beda (_eccce ,_ggge ,_adfb ,_efdb ,_ggdef ,_baaa );return nil ;};if _eaed ==nil {_fa .Log .Debug ("\u0052a\u0073\u0074e\u0072\u004f\u0070\u0065r\u0061\u0074\u0069o\u006e\u0020\u0073\u006f\u0075\u0072\u0063\u0065\u0020bi\u0074\u006d\u0061p\u0020\u0069s\u0020\u006e\u006f\u0074\u0020\u0064e\u0066\u0069n\u0065\u0064");
return _ba .New ("\u006e\u0069l\u0020\u0027\u0073r\u0063\u0027\u0020\u0062\u0069\u0074\u006d\u0061\u0070");};if _bfec :=_gada (_eccce ,_ggge ,_adfb ,_efdb ,_ggdef ,_baaa ,_eaed ,_fcfa ,_abff );_bfec !=nil {return _bfec ;};return nil ;};func (_cgge *ImageBase )setEightBytes (_dffb int ,_gbdc uint64 )error {_feb :=_cgge .BytesPerLine -(_dffb %_cgge .BytesPerLine );
if _cgge .BytesPerLine !=_cgge .Width >>3{_feb --;};if _feb >=8{return _cgge .setEightFullBytes (_dffb ,_gbdc );};return _cgge .setEightPartlyBytes (_dffb ,_feb ,_gbdc );};func _ggdee (_ggda *_bb .Gray16 ,_cgbc uint8 )*_bb .Gray {_ccab :=_ggda .Bounds ();
_cbedb :=_bb .NewGray (_ccab );for _faggg :=0;_faggg < _ccab .Dx ();_faggg ++{for _cfdd :=0;_cfdd < _ccab .Dy ();_cfdd ++{_eacg :=_ggda .Gray16At (_faggg ,_cfdd );_cbedb .SetGray (_faggg ,_cfdd ,_c .Gray {Y :_ceba (uint8 (_eacg .Y /256),_cgbc )});};};return _cbedb ;
};func (_efe *Gray8 )GrayAt (x ,y int )_c .Gray {_age ,_ :=ColorAtGray8BPC (x ,y ,_efe .BytesPerLine ,_efe .Data ,_efe .Decode );return _age ;};func (_cbgg *Gray8 )Base ()*ImageBase {return &_cbgg .ImageBase };const (_bbcba shift =iota ;_baff ;);func (_egca *NRGBA16 )NRGBAAt (x ,y int )_c .NRGBA {_gfbf ,_ :=ColorAtNRGBA16 (x ,y ,_egca .Width ,_egca .BytesPerLine ,_egca .Data ,_egca .Alpha ,_egca .Decode );
return _gfbf ;};var (_bdb =_dbb ();_faf =_fc ();_cb =_gde (););func (_ccgcc *Gray16 )ColorModel ()_c .Model {return _c .Gray16Model };func _dg (_dge _c .Gray )_c .NRGBA {return _c .NRGBA {R :_dge .Y ,G :_dge .Y ,B :_dge .Y ,A :0xff}};func FromGoImage (i _bb .Image )(Image ,error ){switch _ecfg :=i .(type ){case Image :return _ecfg .Copy (),nil ;
case Gray :return GrayConverter .Convert (i );case *_bb .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );case *_bb .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};
};func (_dbbc *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_dbbc .copy ()}};func (_abade *RGBA32 )setRGBA (_cdaff int ,_cfbe _c .RGBA ){_cfab :=3*_cdaff ;_abade .Data [_cfab ]=_cfbe .R ;_abade .Data [_cfab +1]=_cfbe .G ;_abade .Data [_cfab +2]=_cfbe .B ;
if _cdaff < len (_abade .Alpha ){_abade .Alpha [_cdaff ]=_cfbe .A ;};};func _e (_gb *Monochrome ,_d int )(*Monochrome ,error ){if _gb ==nil {return nil ,_ba .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _d ==1{return _gb .copy (),nil ;};if !IsPowerOf2 (uint (_d )){return nil ,_cd .Errorf ("\u0070\u0072\u006fvi\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006ci\u0064 \u0065x\u0070a\u006e\u0064\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_d );
};_da :=_acd (_d );return _ada (_gb ,_d ,_da );};func (_afgf *Monochrome )ColorModel ()_c .Model {return MonochromeModel (_afgf .ModelThreshold )};func _bcg ()(_acec []byte ){_acec =make ([]byte ,256);for _acf :=0;_acf < 256;_acf ++{_dedf :=byte (_acf );
_acec [_dedf ]=(_dedf &0x01)|((_dedf &0x04)>>1)|((_dedf &0x10)>>2)|((_dedf &0x40)>>3)|((_dedf &0x02)<<3)|((_dedf &0x08)<<2)|((_dedf &0x20)<<1)|(_dedf &0x80);};return _acec ;};type monochromeThresholdConverter struct{Threshold uint8 ;};func (_ddfa *NRGBA64 )SetNRGBA64 (x ,y int ,c _c .NRGBA64 ){_abbb :=(y *_ddfa .Width +x )*2;
_bccb :=_abbb *3;if _bccb +5>=len (_ddfa .Data ){return ;};_ddfa .setNRGBA64 (_bccb ,c ,_abbb );};var _ Image =&NRGBA16 {};func (_ecggc *Gray8 )ColorModel ()_c .Model {return _c .GrayModel };func (_cbca *Monochrome )InverseData ()error {return _cbca .RasterOperation (0,0,_cbca .Width ,_cbca .Height ,PixNotDst ,nil ,0,0);
};func (_cdd *Monochrome )setBit (_acea ,_eedb int ){_cdd .Data [_acea +(_eedb >>3)]|=0x80>>uint (_eedb &7);};func (_cddf *Gray16 )Base ()*ImageBase {return &_cddf .ImageBase };func _ccdd (_gge _c .NRGBA64 )_c .NRGBA {return _c .NRGBA {R :uint8 (_gge .R >>8),G :uint8 (_gge .G >>8),B :uint8 (_gge .B >>8),A :uint8 (_gge .A >>8)};
};func (_dbed *ImageBase )newAlpha (){_efbg :=BytesPerLine (_dbed .Width ,_dbed .BitsPerComponent ,1);_dbed .Alpha =make ([]byte ,_dbed .Height *_efbg );};func (_dege *Gray16 )Bounds ()_bb .Rectangle {return _bb .Rectangle {Max :_bb .Point {X :_dege .Width ,Y :_dege .Height }};
};func _aabb (_fffd _bb .Image )(Image ,error ){if _cacb ,_ced :=_fffd .(*Gray2 );_ced {return _cacb .Copy (),nil ;};_adeg :=_fffd .Bounds ();_ffag ,_aadd :=NewImage (_adeg .Max .X ,_adeg .Max .Y ,2,1,nil ,nil ,nil );if _aadd !=nil {return nil ,_aadd ;
};_bbbf (_fffd ,_ffag ,_adeg );return _ffag ,nil ;};func _deea (_aadec RGBA ,_gdc CMYK ,_fbfb _bb .Rectangle ){for _gda :=0;_gda < _fbfb .Max .X ;_gda ++{for _aff :=0;_aff < _fbfb .Max .Y ;_aff ++{_deb :=_aadec .RGBAAt (_gda ,_aff );_gdc .SetCMYK (_gda ,_aff ,_ecg (_deb ));
};};};func _aadef (_ccadf *Monochrome ,_daaf ,_dbag int ,_bcga ,_ceddf int ,_fffe RasterOperator ){var (_dddga bool ;_ccc bool ;_gedg int ;_ebbfa int ;_cebdb int ;_ddbc int ;_ccca bool ;_fdbbb byte ;);_daga :=8-(_daaf &7);_dfbeb :=_acgb [_daga ];_bgec :=_ccadf .BytesPerLine *_dbag +(_daaf >>3);
if _bcga < _daga {_dddga =true ;_dfbeb &=_bdedc [8-_daga +_bcga ];};if !_dddga {_gedg =(_bcga -_daga )>>3;if _gedg !=0{_ccc =true ;_ebbfa =_bgec +1;};};_cebdb =(_daaf +_bcga )&7;if !(_dddga ||_cebdb ==0){_ccca =true ;_fdbbb =_bdedc [_cebdb ];_ddbc =_bgec +1+_gedg ;
};var _dddab ,_bbeb int ;switch _fffe {case PixClr :for _dddab =0;_dddab < _ceddf ;_dddab ++{_ccadf .Data [_bgec ]=_cgb (_ccadf .Data [_bgec ],0x0,_dfbeb );_bgec +=_ccadf .BytesPerLine ;};if _ccc {for _dddab =0;_dddab < _ceddf ;_dddab ++{for _bbeb =0;_bbeb < _gedg ;
_bbeb ++{_ccadf .Data [_ebbfa +_bbeb ]=0x0;};_ebbfa +=_ccadf .BytesPerLine ;};};if _ccca {for _dddab =0;_dddab < _ceddf ;_dddab ++{_ccadf .Data [_ddbc ]=_cgb (_ccadf .Data [_ddbc ],0x0,_fdbbb );_ddbc +=_ccadf .BytesPerLine ;};};case PixSet :for _dddab =0;
_dddab < _ceddf ;_dddab ++{_ccadf .Data [_bgec ]=_cgb (_ccadf .Data [_bgec ],0xff,_dfbeb );_bgec +=_ccadf .BytesPerLine ;};if _ccc {for _dddab =0;_dddab < _ceddf ;_dddab ++{for _bbeb =0;_bbeb < _gedg ;_bbeb ++{_ccadf .Data [_ebbfa +_bbeb ]=0xff;};_ebbfa +=_ccadf .BytesPerLine ;
};};if _ccca {for _dddab =0;_dddab < _ceddf ;_dddab ++{_ccadf .Data [_ddbc ]=_cgb (_ccadf .Data [_ddbc ],0xff,_fdbbb );_ddbc +=_ccadf .BytesPerLine ;};};case PixNotDst :for _dddab =0;_dddab < _ceddf ;_dddab ++{_ccadf .Data [_bgec ]=_cgb (_ccadf .Data [_bgec ],^_ccadf .Data [_bgec ],_dfbeb );
_bgec +=_ccadf .BytesPerLine ;};if _ccc {for _dddab =0;_dddab < _ceddf ;_dddab ++{for _bbeb =0;_bbeb < _gedg ;_bbeb ++{_ccadf .Data [_ebbfa +_bbeb ]=^(_ccadf .Data [_ebbfa +_bbeb ]);};_ebbfa +=_ccadf .BytesPerLine ;};};if _ccca {for _dddab =0;_dddab < _ceddf ;
_dddab ++{_ccadf .Data [_ddbc ]=_cgb (_ccadf .Data [_ddbc ],^_ccadf .Data [_ddbc ],_fdbbb );_ddbc +=_ccadf .BytesPerLine ;};};};};func InDelta (expected ,current ,delta float64 )bool {_fbdb :=expected -current ;if _fbdb <=-delta ||_fbdb >=delta {return false ;
};return true ;};func _aee (_dffg Gray ,_bfc CMYK ,_feg _bb .Rectangle ){for _bfd :=0;_bfd < _feg .Max .X ;_bfd ++{for _edc :=0;_edc < _feg .Max .Y ;_edc ++{_gdd :=_dffg .GrayAt (_bfd ,_edc );_bfc .SetCMYK (_bfd ,_edc ,_ddc (_gdd ));};};};func _feac (_fcf _c .CMYK )_c .Gray {_ecfb ,_bgaf ,_gcbg :=_c .CMYKToRGB (_fcf .C ,_fcf .M ,_fcf .Y ,_fcf .K );
_cef :=(19595*uint32 (_ecfb )+38470*uint32 (_bgaf )+7471*uint32 (_gcbg )+1<<7)>>16;return _c .Gray {Y :uint8 (_cef )};};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };};func ColorAtRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_c .RGBA ,error ){_geeb :=y *width +x ;
_gdfc :=3*_geeb ;if _gdfc +2>=len (data ){return _c .RGBA {},_cd .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_bgb :=uint8 (0xff);if alpha !=nil &&len (alpha )> _geeb {_bgb =alpha [_geeb ];};_bbfga ,_edgf ,_ffaed :=data [_gdfc ],data [_gdfc +1],data [_gdfc +2];if len (decode )==6{_bbfga =uint8 (uint32 (LinearInterpolate (float64 (_bbfga ),0,255,decode [0],decode [1]))&0xff);
_edgf =uint8 (uint32 (LinearInterpolate (float64 (_edgf ),0,255,decode [2],decode [3]))&0xff);_ffaed =uint8 (uint32 (LinearInterpolate (float64 (_ffaed ),0,255,decode [4],decode [5]))&0xff);};return _c .RGBA {R :_bbfga ,G :_edgf ,B :_ffaed ,A :_bgb },nil ;
};func (_ffc *Gray8 )Validate ()error {if len (_ffc .Data )!=_ffc .Height *_ffc .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_cbfa *Gray16 )SetGray (x ,y int ,g _c .Gray ){_eabc :=(y *_cbfa .BytesPerLine /2+x )*2;if _eabc +1>=len (_cbfa .Data ){return ;
};_cbfa .Data [_eabc ]=g .Y ;_cbfa .Data [_eabc +1]=g .Y ;};func _dbb ()(_ecb [256]uint16 ){for _gab :=0;_gab < 256;_gab ++{if _gab &0x01!=0{_ecb [_gab ]|=0x3;};if _gab &0x02!=0{_ecb [_gab ]|=0xc;};if _gab &0x04!=0{_ecb [_gab ]|=0x30;};if _gab &0x08!=0{_ecb [_gab ]|=0xc0;
};if _gab &0x10!=0{_ecb [_gab ]|=0x300;};if _gab &0x20!=0{_ecb [_gab ]|=0xc00;};if _gab &0x40!=0{_ecb [_gab ]|=0x3000;};if _gab &0x80!=0{_ecb [_gab ]|=0xc000;};};return _ecb ;};func _afda (_dcgfe int ,_aadg int )error {return _cd .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_dcgfe ,_aadg );
};func (_ddfg *NRGBA64 )setNRGBA64 (_afgdc int ,_ddaf _c .NRGBA64 ,_dgegg int ){_ddfg .Data [_afgdc ]=uint8 (_ddaf .R >>8);_ddfg .Data [_afgdc +1]=uint8 (_ddaf .R &0xff);_ddfg .Data [_afgdc +2]=uint8 (_ddaf .G >>8);_ddfg .Data [_afgdc +3]=uint8 (_ddaf .G &0xff);
_ddfg .Data [_afgdc +4]=uint8 (_ddaf .B >>8);_ddfg .Data [_afgdc +5]=uint8 (_ddaf .B &0xff);if _dgegg +1< len (_ddfg .Alpha ){_ddfg .Alpha [_dgegg ]=uint8 (_ddaf .A >>8);_ddfg .Alpha [_dgegg +1]=uint8 (_ddaf .A &0xff);};};func _dgfe (_beeb _bb .Image )(Image ,error ){if _eccc ,_bfcac :=_beeb .(*Gray8 );
_bfcac {return _eccc .Copy (),nil ;};_bafb :=_beeb .Bounds ();_bddf ,_daa :=NewImage (_bafb .Max .X ,_bafb .Max .Y ,8,1,nil ,nil ,nil );if _daa !=nil {return nil ,_daa ;};_bbbf (_beeb ,_bddf ,_bafb );return _bddf ,nil ;};func _gde ()(_fgb [256]uint64 ){for _bac :=0;
_bac < 256;_bac ++{if _bac &0x01!=0{_fgb [_bac ]|=0xff;};if _bac &0x02!=0{_fgb [_bac ]|=0xff00;};if _bac &0x04!=0{_fgb [_bac ]|=0xff0000;};if _bac &0x08!=0{_fgb [_bac ]|=0xff000000;};if _bac &0x10!=0{_fgb [_bac ]|=0xff00000000;};if _bac &0x20!=0{_fgb [_bac ]|=0xff0000000000;
};if _bac &0x40!=0{_fgb [_bac ]|=0xff000000000000;};if _bac &0x80!=0{_fgb [_bac ]|=0xff00000000000000;};};return _fgb ;};func _dbbcd (_fagg *Monochrome ,_bab ,_gcdc ,_bbda ,_cdfc int ,_fced RasterOperator ,_gega *Monochrome ,_gcab ,_fga int )error {var (_bcea bool ;
_bdbc bool ;_debba int ;_fdec int ;_gafc int ;_egeb bool ;_ddgca byte ;_bgdfb int ;_faedd int ;_fffc int ;_cbdg ,_cdgd int ;);_eba :=8-(_bab &7);_eddb :=_acgb [_eba ];_ecee :=_fagg .BytesPerLine *_gcdc +(_bab >>3);_aedc :=_gega .BytesPerLine *_fga +(_gcab >>3);
if _bbda < _eba {_bcea =true ;_eddb &=_bdedc [8-_eba +_bbda ];};if !_bcea {_debba =(_bbda -_eba )>>3;if _debba > 0{_bdbc =true ;_fdec =_ecee +1;_gafc =_aedc +1;};};_bgdfb =(_bab +_bbda )&7;if !(_bcea ||_bgdfb ==0){_egeb =true ;_ddgca =_bdedc [_bgdfb ];
_faedd =_ecee +1+_debba ;_fffc =_aedc +1+_debba ;};switch _fced {case PixSrc :for _cbdg =0;_cbdg < _cdfc ;_cbdg ++{_fagg .Data [_ecee ]=_cgb (_fagg .Data [_ecee ],_gega .Data [_aedc ],_eddb );_ecee +=_fagg .BytesPerLine ;_aedc +=_gega .BytesPerLine ;};
if _bdbc {for _cbdg =0;_cbdg < _cdfc ;_cbdg ++{for _cdgd =0;_cdgd < _debba ;_cdgd ++{_fagg .Data [_fdec +_cdgd ]=_gega .Data [_gafc +_cdgd ];};_fdec +=_fagg .BytesPerLine ;_gafc +=_gega .BytesPerLine ;};};if _egeb {for _cbdg =0;_cbdg < _cdfc ;_cbdg ++{_fagg .Data [_faedd ]=_cgb (_fagg .Data [_faedd ],_gega .Data [_fffc ],_ddgca );
_faedd +=_fagg .BytesPerLine ;_fffc +=_gega .BytesPerLine ;};};case PixNotSrc :for _cbdg =0;_cbdg < _cdfc ;_cbdg ++{_fagg .Data [_ecee ]=_cgb (_fagg .Data [_ecee ],^_gega .Data [_aedc ],_eddb );_ecee +=_fagg .BytesPerLine ;_aedc +=_gega .BytesPerLine ;
};if _bdbc {for _cbdg =0;_cbdg < _cdfc ;_cbdg ++{for _cdgd =0;_cdgd < _debba ;_cdgd ++{_fagg .Data [_fdec +_cdgd ]=^_gega .Data [_gafc +_cdgd ];};_fdec +=_fagg .BytesPerLine ;_gafc +=_gega .BytesPerLine ;};};if _egeb {for _cbdg =0;_cbdg < _cdfc ;_cbdg ++{_fagg .Data [_faedd ]=_cgb (_fagg .Data [_faedd ],^_gega .Data [_fffc ],_ddgca );
_faedd +=_fagg .BytesPerLine ;_fffc +=_gega .BytesPerLine ;};};case PixSrcOrDst :for _cbdg =0;_cbdg < _cdfc ;_cbdg ++{_fagg .Data [_ecee ]=_cgb (_fagg .Data [_ecee ],_gega .Data [_aedc ]|_fagg .Data [_ecee ],_eddb );_ecee +=_fagg .BytesPerLine ;_aedc +=_gega .BytesPerLine ;
};if _bdbc {for _cbdg =0;_cbdg < _cdfc ;_cbdg ++{for _cdgd =0;_cdgd < _debba ;_cdgd ++{_fagg .Data [_fdec +_cdgd ]|=_gega .Data [_gafc +_cdgd ];};_fdec +=_fagg .BytesPerLine ;_gafc +=_gega .BytesPerLine ;};};if _egeb {for _cbdg =0;_cbdg < _cdfc ;_cbdg ++{_fagg .Data [_faedd ]=_cgb (_fagg .Data [_faedd ],_gega .Data [_fffc ]|_fagg .Data [_faedd ],_ddgca );
_faedd +=_fagg .BytesPerLine ;_fffc +=_gega .BytesPerLine ;};};case PixSrcAndDst :for _cbdg =0;_cbdg < _cdfc ;_cbdg ++{_fagg .Data [_ecee ]=_cgb (_fagg .Data [_ecee ],_gega .Data [_aedc ]&_fagg .Data [_ecee ],_eddb );_ecee +=_fagg .BytesPerLine ;_aedc +=_gega .BytesPerLine ;
};if _bdbc {for _cbdg =0;_cbdg < _cdfc ;_cbdg ++{for _cdgd =0;_cdgd < _debba ;_cdgd ++{_fagg .Data [_fdec +_cdgd ]&=_gega .Data [_gafc +_cdgd ];};_fdec +=_fagg .BytesPerLine ;_gafc +=_gega .BytesPerLine ;};};if _egeb {for _cbdg =0;_cbdg < _cdfc ;_cbdg ++{_fagg .Data [_faedd ]=_cgb (_fagg .Data [_faedd ],_gega .Data [_fffc ]&_fagg .Data [_faedd ],_ddgca );
_faedd +=_fagg .BytesPerLine ;_fffc +=_gega .BytesPerLine ;};};case PixSrcXorDst :for _cbdg =0;_cbdg < _cdfc ;_cbdg ++{_fagg .Data [_ecee ]=_cgb (_fagg .Data [_ecee ],_gega .Data [_aedc ]^_fagg .Data [_ecee ],_eddb );_ecee +=_fagg .BytesPerLine ;_aedc +=_gega .BytesPerLine ;
};if _bdbc {for _cbdg =0;_cbdg < _cdfc ;_cbdg ++{for _cdgd =0;_cdgd < _debba ;_cdgd ++{_fagg .Data [_fdec +_cdgd ]^=_gega .Data [_gafc +_cdgd ];};_fdec +=_fagg .BytesPerLine ;_gafc +=_gega .BytesPerLine ;};};if _egeb {for _cbdg =0;_cbdg < _cdfc ;_cbdg ++{_fagg .Data [_faedd ]=_cgb (_fagg .Data [_faedd ],_gega .Data [_fffc ]^_fagg .Data [_faedd ],_ddgca );
_faedd +=_fagg .BytesPerLine ;_fffc +=_gega .BytesPerLine ;};};case PixNotSrcOrDst :for _cbdg =0;_cbdg < _cdfc ;_cbdg ++{_fagg .Data [_ecee ]=_cgb (_fagg .Data [_ecee ],^(_gega .Data [_aedc ])|_fagg .Data [_ecee ],_eddb );_ecee +=_fagg .BytesPerLine ;_aedc +=_gega .BytesPerLine ;
};if _bdbc {for _cbdg =0;_cbdg < _cdfc ;_cbdg ++{for _cdgd =0;_cdgd < _debba ;_cdgd ++{_fagg .Data [_fdec +_cdgd ]|=^(_gega .Data [_gafc +_cdgd ]);};_fdec +=_fagg .BytesPerLine ;_gafc +=_gega .BytesPerLine ;};};if _egeb {for _cbdg =0;_cbdg < _cdfc ;_cbdg ++{_fagg .Data [_faedd ]=_cgb (_fagg .Data [_faedd ],^(_gega .Data [_fffc ])|_fagg .Data [_faedd ],_ddgca );
_faedd +=_fagg .BytesPerLine ;_fffc +=_gega .BytesPerLine ;};};case PixNotSrcAndDst :for _cbdg =0;_cbdg < _cdfc ;_cbdg ++{_fagg .Data [_ecee ]=_cgb (_fagg .Data [_ecee ],^(_gega .Data [_aedc ])&_fagg .Data [_ecee ],_eddb );_ecee +=_fagg .BytesPerLine ;
_aedc +=_gega .BytesPerLine ;};if _bdbc {for _cbdg =0;_cbdg < _cdfc ;_cbdg ++{for _cdgd =0;_cdgd < _debba ;_cdgd ++{_fagg .Data [_fdec +_cdgd ]&=^_gega .Data [_gafc +_cdgd ];};_fdec +=_fagg .BytesPerLine ;_gafc +=_gega .BytesPerLine ;};};if _egeb {for _cbdg =0;
_cbdg < _cdfc ;_cbdg ++{_fagg .Data [_faedd ]=_cgb (_fagg .Data [_faedd ],^(_gega .Data [_fffc ])&_fagg .Data [_faedd ],_ddgca );_faedd +=_fagg .BytesPerLine ;_fffc +=_gega .BytesPerLine ;};};case PixSrcOrNotDst :for _cbdg =0;_cbdg < _cdfc ;_cbdg ++{_fagg .Data [_ecee ]=_cgb (_fagg .Data [_ecee ],_gega .Data [_aedc ]|^(_fagg .Data [_ecee ]),_eddb );
_ecee +=_fagg .BytesPerLine ;_aedc +=_gega .BytesPerLine ;};if _bdbc {for _cbdg =0;_cbdg < _cdfc ;_cbdg ++{for _cdgd =0;_cdgd < _debba ;_cdgd ++{_fagg .Data [_fdec +_cdgd ]=_gega .Data [_gafc +_cdgd ]|^(_fagg .Data [_fdec +_cdgd ]);};_fdec +=_fagg .BytesPerLine ;
_gafc +=_gega .BytesPerLine ;};};if _egeb {for _cbdg =0;_cbdg < _cdfc ;_cbdg ++{_fagg .Data [_faedd ]=_cgb (_fagg .Data [_faedd ],_gega .Data [_fffc ]|^(_fagg .Data [_faedd ]),_ddgca );_faedd +=_fagg .BytesPerLine ;_fffc +=_gega .BytesPerLine ;};};case PixSrcAndNotDst :for _cbdg =0;
_cbdg < _cdfc ;_cbdg ++{_fagg .Data [_ecee ]=_cgb (_fagg .Data [_ecee ],_gega .Data [_aedc ]&^(_fagg .Data [_ecee ]),_eddb );_ecee +=_fagg .BytesPerLine ;_aedc +=_gega .BytesPerLine ;};if _bdbc {for _cbdg =0;_cbdg < _cdfc ;_cbdg ++{for _cdgd =0;_cdgd < _debba ;
_cdgd ++{_fagg .Data [_fdec +_cdgd ]=_gega .Data [_gafc +_cdgd ]&^(_fagg .Data [_fdec +_cdgd ]);};_fdec +=_fagg .BytesPerLine ;_gafc +=_gega .BytesPerLine ;};};if _egeb {for _cbdg =0;_cbdg < _cdfc ;_cbdg ++{_fagg .Data [_faedd ]=_cgb (_fagg .Data [_faedd ],_gega .Data [_fffc ]&^(_fagg .Data [_faedd ]),_ddgca );
_faedd +=_fagg .BytesPerLine ;_fffc +=_gega .BytesPerLine ;};};case PixNotPixSrcOrDst :for _cbdg =0;_cbdg < _cdfc ;_cbdg ++{_fagg .Data [_ecee ]=_cgb (_fagg .Data [_ecee ],^(_gega .Data [_aedc ]|_fagg .Data [_ecee ]),_eddb );_ecee +=_fagg .BytesPerLine ;
_aedc +=_gega .BytesPerLine ;};if _bdbc {for _cbdg =0;_cbdg < _cdfc ;_cbdg ++{for _cdgd =0;_cdgd < _debba ;_cdgd ++{_fagg .Data [_fdec +_cdgd ]=^(_gega .Data [_gafc +_cdgd ]|_fagg .Data [_fdec +_cdgd ]);};_fdec +=_fagg .BytesPerLine ;_gafc +=_gega .BytesPerLine ;
};};if _egeb {for _cbdg =0;_cbdg < _cdfc ;_cbdg ++{_fagg .Data [_faedd ]=_cgb (_fagg .Data [_faedd ],^(_gega .Data [_fffc ]|_fagg .Data [_faedd ]),_ddgca );_faedd +=_fagg .BytesPerLine ;_fffc +=_gega .BytesPerLine ;};};case PixNotPixSrcAndDst :for _cbdg =0;
_cbdg < _cdfc ;_cbdg ++{_fagg .Data [_ecee ]=_cgb (_fagg .Data [_ecee ],^(_gega .Data [_aedc ]&_fagg .Data [_ecee ]),_eddb );_ecee +=_fagg .BytesPerLine ;_aedc +=_gega .BytesPerLine ;};if _bdbc {for _cbdg =0;_cbdg < _cdfc ;_cbdg ++{for _cdgd =0;_cdgd < _debba ;
_cdgd ++{_fagg .Data [_fdec +_cdgd ]=^(_gega .Data [_gafc +_cdgd ]&_fagg .Data [_fdec +_cdgd ]);};_fdec +=_fagg .BytesPerLine ;_gafc +=_gega .BytesPerLine ;};};if _egeb {for _cbdg =0;_cbdg < _cdfc ;_cbdg ++{_fagg .Data [_faedd ]=_cgb (_fagg .Data [_faedd ],^(_gega .Data [_fffc ]&_fagg .Data [_faedd ]),_ddgca );
_faedd +=_fagg .BytesPerLine ;_fffc +=_gega .BytesPerLine ;};};case PixNotPixSrcXorDst :for _cbdg =0;_cbdg < _cdfc ;_cbdg ++{_fagg .Data [_ecee ]=_cgb (_fagg .Data [_ecee ],^(_gega .Data [_aedc ]^_fagg .Data [_ecee ]),_eddb );_ecee +=_fagg .BytesPerLine ;
_aedc +=_gega .BytesPerLine ;};if _bdbc {for _cbdg =0;_cbdg < _cdfc ;_cbdg ++{for _cdgd =0;_cdgd < _debba ;_cdgd ++{_fagg .Data [_fdec +_cdgd ]=^(_gega .Data [_gafc +_cdgd ]^_fagg .Data [_fdec +_cdgd ]);};_fdec +=_fagg .BytesPerLine ;_gafc +=_gega .BytesPerLine ;
};};if _egeb {for _cbdg =0;_cbdg < _cdfc ;_cbdg ++{_fagg .Data [_faedd ]=_cgb (_fagg .Data [_faedd ],^(_gega .Data [_fffc ]^_fagg .Data [_faedd ]),_ddgca );_faedd +=_fagg .BytesPerLine ;_fffc +=_gega .BytesPerLine ;};};default:_fa .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070e\u0072\u0061\u0074o\u0072:\u0020\u0025\u0064",_fced );
return _ba .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};func (_dcc *NRGBA16 )At (x ,y int )_c .Color {_gffa ,_ :=_dcc .ColorAt (x ,y );return _gffa };
var (Gray2Model =_c .ModelFunc (_fdg );Gray4Model =_c .ModelFunc (_fgec );NRGBA16Model =_c .ModelFunc (_cfcc ););func _ggdf (_gbce []byte ,_fega Image )error {_ggeb :=true ;for _dgeg :=0;_dgeg < len (_gbce );_dgeg ++{if _gbce [_dgeg ]!=0xff{_ggeb =false ;
break ;};};if _ggeb {switch _acgc :=_fega .(type ){case *NRGBA32 :_acgc .Alpha =nil ;case *NRGBA64 :_acgc .Alpha =nil ;default:return _cd .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_fega );
};};return nil ;};func _ceba (_bfcca ,_bega uint8 )uint8 {if _bfcca < _bega {return 255;};return 0;};func (_affga *NRGBA32 )NRGBAAt (x ,y int )_c .NRGBA {_gfbg ,_ :=ColorAtNRGBA32 (x ,y ,_affga .Width ,_affga .Data ,_affga .Alpha ,_affga .Decode );return _gfbg ;
};type monochromeModel uint8 ;func (_ffae *NRGBA32 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtNRGBA32 (x ,y ,_ffae .Width ,_ffae .Data ,_ffae .Alpha ,_ffae .Decode );};func (_gfac *Monochrome )SetGray (x ,y int ,g _c .Gray ){_dafa :=y *_gfac .BytesPerLine +x >>3;
if _dafa > len (_gfac .Data )-1{return ;};g =_adf (g ,monochromeModel (_gfac .ModelThreshold ));_gfac .setGray (x ,g ,_dafa );};func _ddc (_gafb _c .Gray )_c .CMYK {return _c .CMYK {K :0xff-_gafb .Y }};func _eaa (_fda ,_acdg int )*Monochrome {return &Monochrome {ImageBase :NewImageBase (_fda ,_acdg ,1,1,nil ,nil ,nil ),ModelThreshold :0x0f};
};func (_ggfb *Gray8 )At (x ,y int )_c .Color {_bded ,_ :=_ggfb .ColorAt (x ,y );return _bded };func (_ebgg *Gray2 )Set (x ,y int ,c _c .Color ){if x >=_ebgg .Width ||y >=_ebgg .Height {return ;};_dgee :=Gray2Model .Convert (c ).(_c .Gray );_ggcd :=y *_ebgg .BytesPerLine ;
_bdg :=_ggcd +(x >>2);_gddd :=_dgee .Y >>6;_ebgg .Data [_bdg ]=(_ebgg .Data [_bdg ]&(^(0xc0>>uint (2*((x )&3)))))|(_gddd <<uint (6-2*(x &3)));};type Gray interface{GrayAt (_bdbd ,_ceac int )_c .Gray ;SetGray (_eed ,_cadb int ,_cba _c .Gray );};func _dcg (_cdg ,_ce *Monochrome )(_de error ){_ec :=_ce .BytesPerLine ;
_bgg :=_cdg .BytesPerLine ;var (_dfa byte ;_cg uint16 ;_bba ,_cf ,_fd ,_bae ,_fae int ;);for _fd =0;_fd < _ce .Height ;_fd ++{_bba =_fd *_ec ;_cf =2*_fd *_bgg ;for _bae =0;_bae < _ec ;_bae ++{_dfa =_ce .Data [_bba +_bae ];_cg =_bdb [_dfa ];_fae =_cf +_bae *2;
if _cdg .BytesPerLine !=_ce .BytesPerLine *2&&(_bae +1)*2> _cdg .BytesPerLine {_de =_cdg .setByte (_fae ,byte (_cg >>8));}else {_de =_cdg .setTwoBytes (_fae ,_cg );};if _de !=nil {return _de ;};};for _bae =0;_bae < _bgg ;_bae ++{_fae =_cf +_bgg +_bae ;
_dfa =_cdg .Data [_cf +_bae ];if _de =_cdg .setByte (_fae ,_dfa );_de !=nil {return _de ;};};};return nil ;};var _ Image =&Gray8 {};func (_fgdag *NRGBA16 )Set (x ,y int ,c _c .Color ){_gfda :=y *_fgdag .BytesPerLine +x *3/2;if _gfda +1>=len (_fgdag .Data ){return ;
};_bdaf :=NRGBA16Model .Convert (c ).(_c .NRGBA );_fgdag .setNRGBA (x ,y ,_gfda ,_bdaf );};func (_agg *ImageBase )Pix ()[]byte {return _agg .Data };func (_bdce *NRGBA32 )ColorModel ()_c .Model {return _c .NRGBAModel };func (_faaf *Monochrome )GrayAt (x ,y int )_c .Gray {_gaa ,_ :=ColorAtGray1BPC (x ,y ,_faaf .BytesPerLine ,_faaf .Data ,_faaf .Decode );
return _gaa ;};func _aaca (_ccgcf CMYK ,_gdba NRGBA ,_adfe _bb .Rectangle ){for _bdgbg :=0;_bdgbg < _adfe .Max .X ;_bdgbg ++{for _gcgc :=0;_gcgc < _adfe .Max .Y ;_gcgc ++{_abef :=_ccgcf .CMYKAt (_bdgbg ,_gcgc );_gdba .SetNRGBA (_bdgbg ,_gcgc ,_dbga (_abef ));
};};};func (_bcgd *ImageBase )GetAlpha ()[]byte {return _bcgd .Alpha };func _bddb (_abgb _bb .Image ,_dgcb Image ,_dcgg _bb .Rectangle ){if _faff ,_fead :=_abgb .(SMasker );_fead &&_faff .HasAlpha (){_dgcb .(SMasker ).MakeAlpha ();};switch _cfeb :=_abgb .(type ){case Gray :_gcbba (_cfeb ,_dgcb .(NRGBA ),_dcgg );
case NRGBA :_aag (_cfeb ,_dgcb .(NRGBA ),_dcgg );case *_bb .NYCbCrA :_agfge (_cfeb ,_dgcb .(NRGBA ),_dcgg );case CMYK :_aaca (_cfeb ,_dgcb .(NRGBA ),_dcgg );case RGBA :_fgfd (_cfeb ,_dgcb .(NRGBA ),_dcgg );case nrgba64 :_acdbf (_cfeb ,_dgcb .(NRGBA ),_dcgg );
default:_bcc (_abgb ,_dgcb ,_dcgg );};};var _ _bb .Image =&RGBA32 {};func (_eeba *Gray4 )ColorModel ()_c .Model {return Gray4Model };func _efae (_bdbcc *Monochrome ,_beegg ,_cdce int ,_gdcac ,_eadf int ,_bece RasterOperator ){var (_fed int ;_fgeg byte ;
_bafgc ,_ccbcc int ;_acgee int ;);_cfca :=_gdcac >>3;_fdbd :=_gdcac &7;if _fdbd > 0{_fgeg =_bdedc [_fdbd ];};_fed =_bdbcc .BytesPerLine *_cdce +(_beegg >>3);switch _bece {case PixClr :for _bafgc =0;_bafgc < _eadf ;_bafgc ++{_acgee =_fed +_bafgc *_bdbcc .BytesPerLine ;
for _ccbcc =0;_ccbcc < _cfca ;_ccbcc ++{_bdbcc .Data [_acgee ]=0x0;_acgee ++;};if _fdbd > 0{_bdbcc .Data [_acgee ]=_cgb (_bdbcc .Data [_acgee ],0x0,_fgeg );};};case PixSet :for _bafgc =0;_bafgc < _eadf ;_bafgc ++{_acgee =_fed +_bafgc *_bdbcc .BytesPerLine ;
for _ccbcc =0;_ccbcc < _cfca ;_ccbcc ++{_bdbcc .Data [_acgee ]=0xff;_acgee ++;};if _fdbd > 0{_bdbcc .Data [_acgee ]=_cgb (_bdbcc .Data [_acgee ],0xff,_fgeg );};};case PixNotDst :for _bafgc =0;_bafgc < _eadf ;_bafgc ++{_acgee =_fed +_bafgc *_bdbcc .BytesPerLine ;
for _ccbcc =0;_ccbcc < _cfca ;_ccbcc ++{_bdbcc .Data [_acgee ]=^_bdbcc .Data [_acgee ];_acgee ++;};if _fdbd > 0{_bdbcc .Data [_acgee ]=_cgb (_bdbcc .Data [_acgee ],^_bdbcc .Data [_acgee ],_fgeg );};};};};func _bcc (_fcae _bb .Image ,_cbd Image ,_aeb _bb .Rectangle ){for _bad :=0;
_bad < _aeb .Max .X ;_bad ++{for _abg :=0;_abg < _aeb .Max .Y ;_abg ++{_cacf :=_fcae .At (_bad ,_abg );_cbd .Set (_bad ,_abg ,_cacf );};};};func (_cgea *NRGBA16 )SetNRGBA (x ,y int ,c _c .NRGBA ){_agef :=y *_cgea .BytesPerLine +x *3/2;if _agef +1>=len (_cgea .Data ){return ;
};c =_egede (c );_cgea .setNRGBA (x ,y ,_agef ,c );};func (_bbff *RGBA32 )Base ()*ImageBase {return &_bbff .ImageBase };func (_ggcb *RGBA32 )SetRGBA (x ,y int ,c _c .RGBA ){_fdffa :=y *_ggcb .Width +x ;_dcgdf :=3*_fdffa ;if _dcgdf +2>=len (_ggcb .Data ){return ;
};_ggcb .setRGBA (_fdffa ,c );};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray ,error ){_gaec :=y *bytesPerLine +x >>1;if _gaec >=len (data ){return _c .Gray {},_cd .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_ggca :=data [_gaec ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_ggca =uint8 (uint32 (LinearInterpolate (float64 (_ggca ),0,15,decode [0],decode [1]))&0xf);};return _c .Gray {Y :_ggca *17&0xff},nil ;};func (_fcdd *NRGBA64 )Bounds ()_bb .Rectangle {return _bb .Rectangle {Max :_bb .Point {X :_fcdd .Width ,Y :_fcdd .Height }};
};type RGBA32 struct{ImageBase };func (_cfga *Gray2 )Validate ()error {if len (_cfga .Data )!=_cfga .Height *_cfga .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_dedg *RGBA32 )Set (x ,y int ,c _c .Color ){_abfgb :=y *_dedg .Width +x ;_eaedd :=3*_abfgb ;
if _eaedd +2>=len (_dedg .Data ){return ;};_bffc :=_c .RGBAModel .Convert (c ).(_c .RGBA );_dedg .setRGBA (_abfgb ,_bffc );};type RGBA interface{RGBAAt (_dafgeg ,_efcb int )_c .RGBA ;SetRGBA (_adab ,_ecfgb int ,_gdgf _c .RGBA );};func _fgfd (_dfba RGBA ,_egde NRGBA ,_efee _bb .Rectangle ){for _gdge :=0;
_gdge < _efee .Max .X ;_gdge ++{for _efdfe :=0;_efdfe < _efee .Max .Y ;_efdfe ++{_ecfge :=_dfba .RGBAAt (_gdge ,_efdfe );_egde .SetNRGBA (_gdge ,_efdfe ,_ccf (_ecfge ));};};};func _cfcc (_cfdf _c .Color )_c .Color {_agdg :=_c .NRGBAModel .Convert (_cfdf ).(_c .NRGBA );
return _egede (_agdg );};func _fdca (_cagb _bb .Image )(Image ,error ){if _ccbf ,_aacf :=_cagb .(*Gray4 );_aacf {return _ccbf .Copy (),nil ;};_fceeg :=_cagb .Bounds ();_ddbe ,_egcf :=NewImage (_fceeg .Max .X ,_fceeg .Max .Y ,4,1,nil ,nil ,nil );if _egcf !=nil {return nil ,_egcf ;
};_bbbf (_cagb ,_ddbe ,_fceeg );return _ddbe ,nil ;};func _bfe (_ffff ,_gaf *Monochrome ,_ggd []byte ,_aba int )(_aaa error ){var (_gcb ,_ddd ,_fef ,_gbe ,_edf ,_afg ,_ccd ,_gfec int ;_cfe ,_fgf uint32 ;_bdaa ,_ggg byte ;_cbc uint16 ;);_bff :=make ([]byte ,4);
_fcg :=make ([]byte ,4);for _fef =0;_fef < _ffff .Height -1;_fef ,_gbe =_fef +2,_gbe +1{_gcb =_fef *_ffff .BytesPerLine ;_ddd =_gbe *_gaf .BytesPerLine ;for _edf ,_afg =0,0;_edf < _aba ;_edf ,_afg =_edf +4,_afg +1{for _ccd =0;_ccd < 4;_ccd ++{_gfec =_gcb +_edf +_ccd ;
if _gfec <=len (_ffff .Data )-1&&_gfec < _gcb +_ffff .BytesPerLine {_bff [_ccd ]=_ffff .Data [_gfec ];}else {_bff [_ccd ]=0x00;};_gfec =_gcb +_ffff .BytesPerLine +_edf +_ccd ;if _gfec <=len (_ffff .Data )-1&&_gfec < _gcb +(2*_ffff .BytesPerLine ){_fcg [_ccd ]=_ffff .Data [_gfec ];
}else {_fcg [_ccd ]=0x00;};};_cfe =_a .BigEndian .Uint32 (_bff );_fgf =_a .BigEndian .Uint32 (_fcg );_fgf |=_cfe ;_fgf |=_fgf <<1;_fgf &=0xaaaaaaaa;_cfe =_fgf |(_fgf <<7);_bdaa =byte (_cfe >>24);_ggg =byte ((_cfe >>8)&0xff);_gfec =_ddd +_afg ;if _gfec +1==len (_gaf .Data )-1||_gfec +1>=_ddd +_gaf .BytesPerLine {_gaf .Data [_gfec ]=_ggd [_bdaa ];
}else {_cbc =(uint16 (_ggd [_bdaa ])<<8)|uint16 (_ggd [_ggg ]);if _aaa =_gaf .setTwoBytes (_gfec ,_cbc );_aaa !=nil {return _cd .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_gfec );
};_afg ++;};};};return nil ;};func (_faec *Gray4 )Validate ()error {if len (_faec .Data )!=_faec .Height *_faec .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_bggc *Gray2 )SetGray (x ,y int ,gray _c .Gray ){_aced :=_ffac (gray );_beeg :=y *_bggc .BytesPerLine ;
_cfec :=_beeg +(x >>2);if _cfec >=len (_bggc .Data ){return ;};_eagb :=_aced .Y >>6;_bggc .Data [_cfec ]=(_bggc .Data [_cfec ]&(^(0xc0>>uint (2*((x )&3)))))|(_eagb <<uint (6-2*(x &3)));};func (_baccg *RGBA32 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtRGBA32 (x ,y ,_baccg .Width ,_baccg .Data ,_baccg .Alpha ,_baccg .Decode );
};func _acdbf (_efcg nrgba64 ,_adef NRGBA ,_facb _bb .Rectangle ){for _fffa :=0;_fffa < _facb .Max .X ;_fffa ++{for _abcb :=0;_abcb < _facb .Max .Y ;_abcb ++{_degff :=_efcg .NRGBA64At (_fffa ,_abcb );_adef .SetNRGBA (_fffa ,_abcb ,_ccdd (_degff ));};};
};func (_bbde *Gray8 )Bounds ()_bb .Rectangle {return _bb .Rectangle {Max :_bb .Point {X :_bbde .Width ,Y :_bbde .Height }};};func _gefba (_ebfd *_bb .Gray ,_gbdf uint8 )*_bb .Gray {_ffde :=_ebfd .Bounds ();_afbg :=_bb .NewGray (_ffde );for _cbbe :=0;_cbbe < _ffde .Dx ();
_cbbe ++{for _adff :=0;_adff < _ffde .Dy ();_adff ++{_ecgf :=_ebfd .GrayAt (_cbbe ,_adff );_afbg .SetGray (_cbbe ,_adff ,_c .Gray {Y :_ceba (_ecgf .Y ,_gbdf )});};};return _afbg ;};func (_fcdg *RGBA32 )Copy ()Image {return &RGBA32 {ImageBase :_fcdg .copy ()}};
func (_gabg *NRGBA64 )NRGBA64At (x ,y int )_c .NRGBA64 {_gcbc ,_ :=ColorAtNRGBA64 (x ,y ,_gabg .Width ,_gabg .Data ,_gabg .Alpha ,_gabg .Decode );return _gcbc ;};func (_cbf *CMYK32 )CMYKAt (x ,y int )_c .CMYK {_eca ,_ :=ColorAtCMYK (x ,y ,_cbf .Width ,_cbf .Data ,_cbf .Decode );
return _eca ;};func (_fec *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_fec .copy ()}};type Gray4 struct{ImageBase };func (_cbbgg *RGBA32 )At (x ,y int )_c .Color {_cdfaf ,_ :=_cbbgg .ColorAt (x ,y );return _cdfaf };var _ Image =&RGBA32 {};func (_dgba *ImageBase )setFourBytes (_eccd int ,_gfcc uint32 )error {if _eccd +3> len (_dgba .Data )-1{return _cd .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065",_eccd );
};_dgba .Data [_eccd ]=byte ((_gfcc &0xff000000)>>24);_dgba .Data [_eccd +1]=byte ((_gfcc &0xff0000)>>16);_dgba .Data [_eccd +2]=byte ((_gfcc &0xff00)>>8);_dgba .Data [_eccd +3]=byte (_gfcc &0xff);return nil ;};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_agd :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );
var _badf Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_badf =&Monochrome {ImageBase :_agd ,ModelThreshold :0x0f};case 2:_badf =&Gray2 {ImageBase :_agd };case 4:_badf =&Gray4 {ImageBase :_agd };case 8:_badf =&Gray8 {ImageBase :_agd };
case 16:_badf =&Gray16 {ImageBase :_agd };};case 3:switch bitsPerComponent {case 4:_badf =&NRGBA16 {ImageBase :_agd };case 8:_badf =&NRGBA32 {ImageBase :_agd };case 16:_badf =&NRGBA64 {ImageBase :_agd };};case 4:_badf =&CMYK32 {ImageBase :_agd };};if _badf ==nil {return nil ,ErrInvalidImage ;
};return _badf ,nil ;};func (_cbg *Gray4 )At (x ,y int )_c .Color {_fgfb ,_ :=_cbg .ColorAt (x ,y );return _fgfb };func _fffb (_dfbf ,_gbac Gray ,_efcf _bb .Rectangle ){for _eace :=0;_eace < _efcf .Max .X ;_eace ++{for _aeaa :=0;_aeaa < _efcf .Max .Y ;
_aeaa ++{_gbac .SetGray (_eace ,_aeaa ,_dfbf .GrayAt (_eace ,_aeaa ));};};};type Gray8 struct{ImageBase };func _agb (_cac ,_dfdg *Monochrome ,_eff []byte ,_dfb int )(_acc error ){var (_bfed ,_ddac ,_bgga ,_bbf ,_baa ,_bea ,_gdb ,_ebb int ;_cfcb ,_gbd ,_ecc ,_caef uint32 ;
_ggc ,_bcb byte ;_gdee uint16 ;);_ebg :=make ([]byte ,4);_bfeg :=make ([]byte ,4);for _bgga =0;_bgga < _cac .Height -1;_bgga ,_bbf =_bgga +2,_bbf +1{_bfed =_bgga *_cac .BytesPerLine ;_ddac =_bbf *_dfdg .BytesPerLine ;for _baa ,_bea =0,0;_baa < _dfb ;_baa ,_bea =_baa +4,_bea +1{for _gdb =0;
_gdb < 4;_gdb ++{_ebb =_bfed +_baa +_gdb ;if _ebb <=len (_cac .Data )-1&&_ebb < _bfed +_cac .BytesPerLine {_ebg [_gdb ]=_cac .Data [_ebb ];}else {_ebg [_gdb ]=0x00;};_ebb =_bfed +_cac .BytesPerLine +_baa +_gdb ;if _ebb <=len (_cac .Data )-1&&_ebb < _bfed +(2*_cac .BytesPerLine ){_bfeg [_gdb ]=_cac .Data [_ebb ];
}else {_bfeg [_gdb ]=0x00;};};_cfcb =_a .BigEndian .Uint32 (_ebg );_gbd =_a .BigEndian .Uint32 (_bfeg );_ecc =_cfcb &_gbd ;_ecc |=_ecc <<1;_caef =_cfcb |_gbd ;_caef &=_caef <<1;_gbd =_ecc &_caef ;_gbd &=0xaaaaaaaa;_cfcb =_gbd |(_gbd <<7);_ggc =byte (_cfcb >>24);
_bcb =byte ((_cfcb >>8)&0xff);_ebb =_ddac +_bea ;if _ebb +1==len (_dfdg .Data )-1||_ebb +1>=_ddac +_dfdg .BytesPerLine {if _acc =_dfdg .setByte (_ebb ,_eff [_ggc ]);_acc !=nil {return _cd .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_ebb );};
}else {_gdee =(uint16 (_eff [_ggc ])<<8)|uint16 (_eff [_bcb ]);if _acc =_dfdg .setTwoBytes (_ebb ,_gdee );_acc !=nil {return _cd .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_ebb );
};_bea ++;};};};return nil ;};func (_fagb *Monochrome )ReduceBinary (factor float64 )(*Monochrome ,error ){_affd :=_eaec (uint (factor ));if !IsPowerOf2 (uint (factor )){_affd ++;};_aea :=make ([]int ,_affd );for _gcaa :=range _aea {_aea [_gcaa ]=4;};_ccacc ,_caae :=_fbc (_fagb ,_aea ...);
if _caae !=nil {return nil ,_caae ;};return _ccacc ,nil ;};func (_gbae *NRGBA32 )Validate ()error {if len (_gbae .Data )!=3*_gbae .Width *_gbae .Height {return _ba .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};var _ _bb .Image =&NRGBA16 {};var _facf [256]uint8 ;func ImgToBinary (i _bb .Image ,threshold uint8 )*_bb .Gray {switch _gbafc :=i .(type ){case *_bb .Gray :if _fbedg (_gbafc ){return _gbafc ;};return _gefba (_gbafc ,threshold );case *_bb .Gray16 :return _ggdee (_gbafc ,threshold );
default:return _gddce (_gbafc ,threshold );};};func _fbaa (_ggdd _c .NRGBA64 )_c .RGBA {_dafg ,_fafbg ,_fgdg ,_bee :=_ggdd .RGBA ();return _c .RGBA {R :uint8 (_dafg >>8),G :uint8 (_fafbg >>8),B :uint8 (_fgdg >>8),A :uint8 (_bee >>8)};};var _ Gray =&Monochrome {};
var _ NRGBA =&NRGBA32 {};type NRGBA32 struct{ImageBase };func (_gddg *Monochrome )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray1BPC (x ,y ,_gddg .BytesPerLine ,_gddg .Data ,_gddg .Decode );};func (_dcdgb *NRGBA32 )SetNRGBA (x ,y int ,c _c .NRGBA ){_aaaff :=y *_dcdgb .Width +x ;
_ccgg :=3*_aaaff ;if _ccgg +2>=len (_dcdgb .Data ){return ;};_dcdgb .setRGBA (_aaaff ,c );};func (_aefaf *Monochrome )RasterOperation (dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _afgb (_aefaf ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};func (_gbbe *NRGBA64 )Set (x ,y int ,c _c .Color ){_cdcb :=(y *_gbbe .Width +x )*2;_afgd :=_cdcb *3;if _afgd +5>=len (_gbbe .Data ){return ;};_ecad :=_c .NRGBA64Model .Convert (c ).(_c .NRGBA64 );_gbbe .setNRGBA64 (_afgd ,_ecad ,_cdcb );};func ScaleAlphaToMonochrome (data []byte ,width ,height int )([]byte ,error ){_fb :=BytesPerLine (width ,8,1);
if len (data )< _fb *height {return nil ,nil ;};_ad :=&Gray8 {NewImageBase (width ,height ,8,1,data ,nil ,nil )};_add ,_fbf :=MonochromeConverter .Convert (_ad );if _fbf !=nil {return nil ,_fbf ;};return _add .Base ().Data ,nil ;};func (_dccd *NRGBA32 )Bounds ()_bb .Rectangle {return _bb .Rectangle {Max :_bb .Point {X :_dccd .Width ,Y :_dccd .Height }};
};func (_eafg *CMYK32 )Set (x ,y int ,c _c .Color ){_gba :=4*(y *_eafg .Width +x );if _gba +3>=len (_eafg .Data ){return ;};_bacc :=_c .CMYKModel .Convert (c ).(_c .CMYK );_eafg .Data [_gba ]=_bacc .C ;_eafg .Data [_gba +1]=_bacc .M ;_eafg .Data [_gba +2]=_bacc .Y ;
_eafg .Data [_gba +3]=_bacc .K ;};var _ NRGBA =&NRGBA16 {};func (_cage *Gray4 )GrayAt (x ,y int )_c .Gray {_bfca ,_ :=ColorAtGray4BPC (x ,y ,_cage .BytesPerLine ,_cage .Data ,_cage .Decode );return _bfca ;};func _fg (_caa ,_ac *Monochrome )(_bc error ){_dca :=_ac .BytesPerLine ;
_ga :=_caa .BytesPerLine ;var _addc ,_bd ,_eb ,_ae ,_bbb int ;for _eb =0;_eb < _ac .Height ;_eb ++{_addc =_eb *_dca ;_bd =8*_eb *_ga ;for _ae =0;_ae < _dca ;_ae ++{if _bc =_caa .setEightBytes (_bd +_ae *8,_cb [_ac .Data [_addc +_ae ]]);_bc !=nil {return _bc ;
};};for _bbb =1;_bbb < 8;_bbb ++{for _ae =0;_ae < _ga ;_ae ++{if _bc =_caa .setByte (_bd +_bbb *_ga +_ae ,_caa .Data [_bd +_ae ]);_bc !=nil {return _bc ;};};};};return nil ;};func _ada (_gd *Monochrome ,_bbg int ,_df []uint )(*Monochrome ,error ){_dc :=_bbg *_gd .Width ;
_dd :=_bbg *_gd .Height ;_ddb :=_eaa (_dc ,_dd );for _eg ,_ff :=range _df {var _fe error ;switch _ff {case 2:_fe =_dcg (_ddb ,_gd );case 4:_fe =_dfd (_ddb ,_gd );case 8:_fe =_fg (_ddb ,_gd );};if _fe !=nil {return nil ,_fe ;};if _eg !=len (_df )-1{_gd =_ddb .copy ();
};};return _ddb ,nil ;};type ColorConverter interface{Convert (_degb _bb .Image )(Image ,error );};func (_gbde *ImageBase )MakeAlpha (){_gbde .newAlpha ()};func _eaade (_egcg Gray ,_bgff RGBA ,_eaab _bb .Rectangle ){for _bgafc :=0;_bgafc < _eaab .Max .X ;
_bgafc ++{for _dfc :=0;_dfc < _eaab .Max .Y ;_dfc ++{_dgcec :=_egcg .GrayAt (_bgafc ,_dfc );_bgff .SetRGBA (_bgafc ,_dfc ,_gdcf (_dgcec ));};};};func _ccf (_ecce _c .RGBA )_c .NRGBA {switch _ecce .A {case 0xff:return _c .NRGBA {R :_ecce .R ,G :_ecce .G ,B :_ecce .B ,A :0xff};
case 0x00:return _c .NRGBA {};default:_bag ,_bdd ,_ccac ,_abf :=_ecce .RGBA ();_bag =(_bag *0xffff)/_abf ;_bdd =(_bdd *0xffff)/_abf ;_ccac =(_ccac *0xffff)/_abf ;return _c .NRGBA {R :uint8 (_bag >>8),G :uint8 (_bdd >>8),B :uint8 (_ccac >>8),A :uint8 (_abf >>8)};
};};var _ Gray =&Gray4 {};type nrgba64 interface{NRGBA64At (_agabc ,_bfcc int )_c .NRGBA64 ;SetNRGBA64 (_dbaa ,_ggggg int ,_baed _c .NRGBA64 );};func (_afa *CMYK32 )Validate ()error {if len (_afa .Data )!=4*_afa .Width *_afa .Height {return _ba .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};type Histogramer interface{Histogram ()[256]int ;};var _ Image =&CMYK32 {};func (_gdbf *Monochrome )Validate ()error {if len (_gdbf .Data )!=_gdbf .Height *_gdbf .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_dafge *Gray16 )At (x ,y int )_c .Color {_accg ,_ :=_dafge .ColorAt (x ,y );
return _accg };func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;};func (_dged *NRGBA64 )Base ()*ImageBase {return &_dged .ImageBase };type Gray16 struct{ImageBase };var (_bdedc =[]byte {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF};
_acgb =[]byte {0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF};);func _ffac (_afbd _c .Gray )_c .Gray {_cfdga :=_afbd .Y >>6;_cfdga |=_cfdga <<2;_afbd .Y =_cfdga |_cfdga <<4;return _afbd ;};func _gdcf (_gfg _c .Gray )_c .RGBA {return _c .RGBA {R :_gfg .Y ,G :_gfg .Y ,B :_gfg .Y ,A :0xff}};
func _beda (_edea *Monochrome ,_dgbabd ,_afce ,_cbgbe ,_bdabb int ,_bgcf RasterOperator ){if _dgbabd < 0{_cbgbe +=_dgbabd ;_dgbabd =0;};_bca :=_dgbabd +_cbgbe -_edea .Width ;if _bca > 0{_cbgbe -=_bca ;};if _afce < 0{_bdabb +=_afce ;_afce =0;};_degef :=_afce +_bdabb -_edea .Height ;
if _degef > 0{_bdabb -=_degef ;};if _cbgbe <=0||_bdabb <=0{return ;};if (_dgbabd &7)==0{_efae (_edea ,_dgbabd ,_afce ,_cbgbe ,_bdabb ,_bgcf );}else {_aadef (_edea ,_dgbabd ,_afce ,_cbgbe ,_bdabb ,_bgcf );};};func AutoThresholdTriangle (histogram [256]int )uint8 {var _abdf ,_fcgb ,_ddbec ,_cedf int ;
for _fdae :=0;_fdae < len (histogram );_fdae ++{if histogram [_fdae ]> 0{_abdf =_fdae ;break ;};};if _abdf > 0{_abdf --;};for _fbaf :=255;_fbaf > 0;_fbaf --{if histogram [_fbaf ]> 0{_cedf =_fbaf ;break ;};};if _cedf < 255{_cedf ++;};for _agea :=0;_agea < 256;
_agea ++{if histogram [_agea ]> _fcgb {_ddbec =_agea ;_fcgb =histogram [_agea ];};};var _gdbc bool ;if (_ddbec -_abdf )< (_cedf -_ddbec ){_gdbc =true ;var _ecfgg int ;_gddb :=255;for _ecfgg < _gddb {_fcec :=histogram [_ecfgg ];histogram [_ecfgg ]=histogram [_gddb ];
histogram [_gddb ]=_fcec ;_ecfgg ++;_gddb --;};_abdf =255-_cedf ;_ddbec =255-_ddbec ;};if _abdf ==_ddbec {return uint8 (_abdf );};_cbae :=float64 (histogram [_ddbec ]);_abbbb :=float64 (_abdf -_ddbec );_abaf :=_f .Sqrt (_cbae *_cbae +_abbbb *_abbbb );_cbae /=_abaf ;
_abbbb /=_abaf ;_abaf =_cbae *float64 (_abdf )+_abbbb *float64 (histogram [_abdf ]);_gbdd :=_abdf ;var _cabd float64 ;for _dbedg :=_abdf +1;_dbedg <=_ddbec ;_dbedg ++{_egfbf :=_cbae *float64 (_dbedg )+_abbbb *float64 (histogram [_dbedg ])-_abaf ;if _egfbf > _cabd {_gbdd =_dbedg ;
_cabd =_egfbf ;};};_gbdd --;if _gdbc {var _gfde int ;_eabd :=255;for _gfde < _eabd {_fcac :=histogram [_gfde ];histogram [_gfde ]=histogram [_eabd ];histogram [_eabd ]=_fcac ;_gfde ++;_eabd --;};return uint8 (255-_gbdd );};return uint8 (_gbdd );};func _ecbg (_gf *Monochrome ,_dad int ,_dea []byte )(_fca *Monochrome ,_gfe error ){const _ace ="\u0072\u0065d\u0075\u0063\u0065R\u0061\u006e\u006b\u0042\u0069\u006e\u0061\u0072\u0079";
if _gf ==nil {return nil ,_ba .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");};if _dad < 1||_dad > 4{return nil ,_ba .New ("\u006c\u0065\u0076\u0065\u006c\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020\u0073e\u0074\u0020\u007b\u0031\u002c\u0032\u002c\u0033\u002c\u0034\u007d");
};if _gf .Height <=1{return nil ,_ba .New ("\u0073\u006f\u0075rc\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020m\u0075s\u0074 \u0062e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0027\u0032\u0027");};_fca =_eaa (_gf .Width /2,_gf .Height /2);
if _dea ==nil {_dea =_bcg ();};_ggf :=_cceb (_gf .BytesPerLine ,2*_fca .BytesPerLine );switch _dad {case 1:_gfe =_bfe (_gf ,_fca ,_dea ,_ggf );case 2:_gfe =_eaf (_gf ,_fca ,_dea ,_ggf );case 3:_gfe =_agb (_gf ,_fca ,_dea ,_ggf );case 4:_gfe =_dcgd (_gf ,_fca ,_dea ,_ggf );
};if _gfe !=nil {return nil ,_gfe ;};return _fca ,nil ;};func _afae (_bbdg ,_abfa RGBA ,_agegf _bb .Rectangle ){for _effc :=0;_effc < _agegf .Max .X ;_effc ++{for _ecde :=0;_ecde < _agegf .Max .Y ;_ecde ++{_abfa .SetRGBA (_effc ,_ecde ,_bbdg .RGBAAt (_effc ,_ecde ));
};};};type NRGBA64 struct{ImageBase };func _cgde (_effe *_bb .NYCbCrA ,_acgec RGBA ,_dadcb _bb .Rectangle ){for _dcad :=0;_dcad < _dadcb .Max .X ;_dcad ++{for _ebgff :=0;_ebgff < _dadcb .Max .Y ;_ebgff ++{_befe :=_effe .NYCbCrAAt (_dcad ,_ebgff );_acgec .SetRGBA (_dcad ,_ebgff ,_aace (_befe ));
};};};func _dbgg (){for _cbfe :=0;_cbfe < 256;_cbfe ++{_facf [_cbfe ]=uint8 (_cbfe &0x1)+(uint8 (_cbfe >>1)&0x1)+(uint8 (_cbfe >>2)&0x1)+(uint8 (_cbfe >>3)&0x1)+(uint8 (_cbfe >>4)&0x1)+(uint8 (_cbfe >>5)&0x1)+(uint8 (_cbfe >>6)&0x1)+(uint8 (_cbfe >>7)&0x1);
};};type shift int ;var _ _bb .Image =&Gray8 {};func (_bcff *ImageBase )HasAlpha ()bool {if _bcff .Alpha ==nil {return false ;};for _cgf :=range _bcff .Alpha {if _bcff .Alpha [_cgf ]!=0xff{return true ;};};return false ;};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray ,error ){_cbff :=y *bytesPerLine +x ;
if _cbff >=len (data ){return _c .Gray {},_cd .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_bafg :=data [_cbff ];if len (decode )==2{_bafg =uint8 (uint32 (LinearInterpolate (float64 (_bafg ),0,255,decode [0],decode [1]))&0xff);};return _c .Gray {Y :_bafg },nil ;};var _ RGBA =&RGBA32 {};func _cgb (_eddf ,_eadfg ,_edcc byte )byte {return (_eddf &^(_edcc ))|(_eadfg &_edcc )};
var (MonochromeConverter =ConverterFunc (_agba );Gray2Converter =ConverterFunc (_aabb );Gray4Converter =ConverterFunc (_fdca );GrayConverter =ConverterFunc (_dgfe );Gray16Converter =ConverterFunc (_faafe );NRGBA16Converter =ConverterFunc (_fegd );NRGBAConverter =ConverterFunc (_ceag );
NRGBA64Converter =ConverterFunc (_deae );RGBAConverter =ConverterFunc (_gccg );CMYKConverter =ConverterFunc (_adgg ););func (_fbba *Gray8 )Histogram ()(_dce [256]int ){for _dgaa :=0;_dgaa < len (_fbba .Data );_dgaa ++{_dce [_fbba .Data [_dgaa ]]++;};return _dce ;
};func _ecg (_agbe _c .RGBA )_c .CMYK {_gabd ,_bbbc ,_cea ,_afgef :=_c .RGBToCMYK (_agbe .R ,_agbe .G ,_agbe .B );return _c .CMYK {C :_gabd ,M :_bbbc ,Y :_cea ,K :_afgef };};type Gray2 struct{ImageBase };func _bbbf (_adggd _bb .Image ,_bced Image ,_acef _bb .Rectangle ){switch _adfg :=_adggd .(type ){case Gray :_fffb (_adfg ,_bced .(Gray ),_acef );
case NRGBA :_bbc (_adfg ,_bced .(Gray ),_acef );case CMYK :_fgbc (_adfg ,_bced .(Gray ),_acef );case RGBA :_aegb (_adfg ,_bced .(Gray ),_acef );default:_bcc (_adggd ,_bced ,_acef );};};func _fbc (_dbg *Monochrome ,_ade ...int )(_abb *Monochrome ,_aac error ){if _dbg ==nil {return nil ,_ba .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if len (_ade )==0{return nil ,_ba .New ("\u0074h\u0065\u0072e\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u006f\u0066 \u0072\u0065\u0064\u0075\u0063\u0074\u0069\u006f\u006e");
};_eagd :=_bcg ();_abb =_dbg ;for _ ,_ccg :=range _ade {if _ccg <=0{break ;};_abb ,_aac =_ecbg (_abb ,_ccg ,_eagd );if _aac !=nil {return nil ,_aac ;};};return _abb ,nil ;};func _eaec (_gffc uint )uint {var _aae uint ;for _gffc !=0{_gffc >>=1;_aae ++;};
return _aae -1;};func (_befd *RGBA32 )RGBAAt (x ,y int )_c .RGBA {_cadgd ,_ :=ColorAtRGBA32 (x ,y ,_befd .Width ,_befd .Data ,_befd .Alpha ,_befd .Decode );return _cadgd ;};func (_ddda *Monochrome )clearBit (_dage ,_adb int ){_ddda .Data [_dage ]&=^(0x80>>uint (_adb &7))};
func _gccg (_begd _bb .Image )(Image ,error ){if _gdfg ,_fffcd :=_begd .(*RGBA32 );_fffcd {return _gdfg .Copy (),nil ;};_ggaf ,_cbce ,_acda :=_edgb (_begd ,1);_degbaa :=&RGBA32 {ImageBase :NewImageBase (_ggaf .Max .X ,_ggaf .Max .Y ,8,3,nil ,_acda ,nil )};
_gdff (_begd ,_degbaa ,_ggaf );if len (_acda )!=0&&!_cbce {if _dgacc :=_ggdf (_acda ,_degbaa );_dgacc !=nil {return nil ,_dgacc ;};};return _degbaa ,nil ;};func _deaf (_dedd ,_daf CMYK ,_cde _bb .Rectangle ){for _dade :=0;_dade < _cde .Max .X ;_dade ++{for _ged :=0;
_ged < _cde .Max .Y ;_ged ++{_daf .SetCMYK (_dade ,_ged ,_dedd .CMYKAt (_dade ,_ged ));};};};func (_adfc *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_adfc .copy ()}};var _ Image =&NRGBA64 {};func _ceag (_cefd _bb .Image )(Image ,error ){if _bbca ,_gaac :=_cefd .(*NRGBA32 );
_gaac {return _bbca .Copy (),nil ;};_cdde ,_fgga ,_aafg :=_edgb (_cefd ,1);_gbef ,_faabe :=NewImage (_cdde .Max .X ,_cdde .Max .Y ,8,3,nil ,_aafg ,nil );if _faabe !=nil {return nil ,_faabe ;};_bddb (_cefd ,_gbef ,_cdde );if len (_aafg )!=0&&!_fgga {if _dbd :=_ggdf (_aafg ,_gbef );
_dbd !=nil {return nil ,_dbd ;};};return _gbef ,nil ;};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_c .NRGBA ,error ){_cdaf :=y *width +x ;_aega :=3*_cdaf ;if _aega +2>=len (data ){return _c .NRGBA {},_cd .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_bfce :=uint8 (0xff);if alpha !=nil &&len (alpha )> _cdaf {_bfce =alpha [_cdaf ];};_dgaca ,_fbcbc ,_cgec :=data [_aega ],data [_aega +1],data [_aega +2];if len (decode )==6{_dgaca =uint8 (uint32 (LinearInterpolate (float64 (_dgaca ),0,255,decode [0],decode [1]))&0xff);
_fbcbc =uint8 (uint32 (LinearInterpolate (float64 (_fbcbc ),0,255,decode [2],decode [3]))&0xff);_cgec =uint8 (uint32 (LinearInterpolate (float64 (_cgec ),0,255,decode [4],decode [5]))&0xff);};return _c .NRGBA {R :_dgaca ,G :_fbcbc ,B :_cgec ,A :_bfce },nil ;
};func _agfge (_fdff *_bb .NYCbCrA ,_ggffg NRGBA ,_cacbb _bb .Rectangle ){for _bffd :=0;_bffd < _cacbb .Max .X ;_bffd ++{for _gdf :=0;_gdf < _cacbb .Max .Y ;_gdf ++{_fdbc :=_fdff .NYCbCrAAt (_bffd ,_gdf );_ggffg .SetNRGBA (_bffd ,_gdf ,_cdb (_fdbc ));};
};};func (_fgda *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_fgda .copy ()}};func (_cgd *NRGBA16 )Bounds ()_bb .Rectangle {return _bb .Rectangle {Max :_bb .Point {X :_cgd .Width ,Y :_cgd .Height }};};func (_aaaf *Gray4 )SetGray (x ,y int ,g _c .Gray ){if x >=_aaaf .Width ||y >=_aaaf .Height {return ;
};g =_caeb (g );_aaaf .setGray (x ,y ,g );};func _bbc (_bdad NRGBA ,_ebd Gray ,_dgdf _bb .Rectangle ){for _bgda :=0;_bgda < _dgdf .Max .X ;_bgda ++{for _cgaa :=0;_cgaa < _dgdf .Max .Y ;_cgaa ++{_aaag :=_aacg (_bdad .NRGBAAt (_bgda ,_cgaa ));_ebd .SetGray (_bgda ,_cgaa ,_aaag );
};};};func _bgd (_ccgf _c .NRGBA )_c .Gray {var _ddbf _c .NRGBA ;if _ccgf ==_ddbf {return _c .Gray {Y :0xff};};_fcab ,_aadb ,_bfg ,_ :=_ccgf .RGBA ();_eafe :=(19595*_fcab +38470*_aadb +7471*_bfg +1<<15)>>24;return _c .Gray {Y :uint8 (_eafe )};};func (_dfedd *Gray8 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray8BPC (x ,y ,_dfedd .BytesPerLine ,_dfedd .Data ,_dfedd .Decode );
};func _beeba (_gbeb nrgba64 ,_dgab RGBA ,_fbfge _bb .Rectangle ){for _gbaaf :=0;_gbaaf < _fbfge .Max .X ;_gbaaf ++{for _gbaef :=0;_gbaef < _fbfge .Max .Y ;_gbaef ++{_cceee :=_gbeb .NRGBA64At (_gbaaf ,_gbaef );_dgab .SetRGBA (_gbaaf ,_gbaef ,_fbaa (_cceee ));
};};};func (_aadf *Monochrome )Histogram ()(_fcbf [256]int ){for _ ,_cdc :=range _aadf .Data {_fcbf [0xff]+=int (_facf [_aadf .Data [_cdc ]]);};return _fcbf ;};