//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_fc "fmt";_ad "github.com/unidoc/unipdf/v3/common";_df "github.com/unidoc/unipdf/v3/internal/bitwise";_c "github.com/unidoc/unipdf/v3/internal/jbig2/internal";_a "io";_f "strings";);func (_ff *Decoder )DecodeBit (stats *DecoderStats )(int ,error ){var (_dff int ;
_bbf =_b [stats .cx ()][0];_fg =int32 (stats .cx ()););defer func (){_ff ._cf ++}();_ff ._bb -=_bbf ;if (_ff ._cgb >>16)< uint64 (_bbf ){_dff =_ff .lpsExchange (stats ,_fg ,_bbf );if _fge :=_ff .renormalize ();_fge !=nil {return 0,_fge ;};}else {_ff ._cgb -=uint64 (_bbf )<<16;
if (_ff ._bb &0x8000)==0{_dff =_ff .mpsExchange (stats ,_fg );if _ed :=_ff .renormalize ();_ed !=nil {return 0,_ed ;};}else {_dff =int (stats .getMps ());};};return _dff ,nil ;};func (_gcc *DecoderStats )Overwrite (dNew *DecoderStats ){for _bf :=0;_bf < len (_gcc ._gaf );
_bf ++{_gcc ._gaf [_bf ]=dNew ._gaf [_bf ];_gcc ._fbe [_bf ]=dNew ._fbe [_bf ];};};func (_fa *DecoderStats )cx ()byte {return _fa ._gaf [_fa ._ec ]};func (_cb *Decoder )DecodeInt (stats *DecoderStats )(int32 ,error ){var (_cdd ,_gc int32 ;_fd ,_gg ,_ab int ;
_ffd error ;);if stats ==nil {stats =NewStats (512,1);};_cb ._dfg =1;_gg ,_ffd =_cb .decodeIntBit (stats );if _ffd !=nil {return 0,_ffd ;};_fd ,_ffd =_cb .decodeIntBit (stats );if _ffd !=nil {return 0,_ffd ;};if _fd ==1{_fd ,_ffd =_cb .decodeIntBit (stats );
if _ffd !=nil {return 0,_ffd ;};if _fd ==1{_fd ,_ffd =_cb .decodeIntBit (stats );if _ffd !=nil {return 0,_ffd ;};if _fd ==1{_fd ,_ffd =_cb .decodeIntBit (stats );if _ffd !=nil {return 0,_ffd ;};if _fd ==1{_fd ,_ffd =_cb .decodeIntBit (stats );if _ffd !=nil {return 0,_ffd ;
};if _fd ==1{_ab =32;_gc =4436;}else {_ab =12;_gc =340;};}else {_ab =8;_gc =84;};}else {_ab =6;_gc =20;};}else {_ab =4;_gc =4;};}else {_ab =2;_gc =0;};for _cc :=0;_cc < _ab ;_cc ++{_fd ,_ffd =_cb .decodeIntBit (stats );if _ffd !=nil {return 0,_ffd ;};_cdd =(_cdd <<1)|int32 (_fd );
};_cdd +=_gc ;if _gg ==0{return _cdd ,nil ;}else if _gg ==1&&_cdd > 0{return -_cdd ,nil ;};return 0,_c .ErrOOB ;};func (_adc *DecoderStats )Reset (){for _cce :=0;_cce < len (_adc ._gaf );_cce ++{_adc ._gaf [_cce ]=0;_adc ._fbe [_cce ]=0;};};func (_cge *Decoder )readByte ()error {if _cge ._g .AbsolutePosition ()> _cge ._da {if _ ,_adg :=_cge ._g .Seek (-1,_a .SeekCurrent );
_adg !=nil {return _adg ;};};_cda ,_fcd :=_cge ._g .ReadByte ();if _fcd !=nil {return _fcd ;};_cge ._cg =_cda ;if _cge ._cg ==0xFF{_ba ,_ce :=_cge ._g .ReadByte ();if _ce !=nil {return _ce ;};if _ba > 0x8F{_cge ._cgb +=0xFF00;_cge ._de =8;if _ ,_cgf :=_cge ._g .Seek (-2,_a .SeekCurrent );
_cgf !=nil {return _cgf ;};}else {_cge ._cgb +=uint64 (_ba )<<9;_cge ._de =7;};}else {_cda ,_fcd =_cge ._g .ReadByte ();if _fcd !=nil {return _fcd ;};_cge ._cg =_cda ;_cge ._cgb +=uint64 (_cge ._cg )<<8;_cge ._de =8;};_cge ._cgb &=0xFFFFFFFFFF;return nil ;
};func (_ffda *Decoder )init ()error {_ffda ._da =_ffda ._g .AbsolutePosition ();_fbg ,_dab :=_ffda ._g .ReadByte ();if _dab !=nil {_ad .Log .Debug ("B\u0075\u0066\u0066\u0065\u0072\u0030 \u0072\u0065\u0061\u0064\u0042\u0079\u0074\u0065\u0020f\u0061\u0069\u006ce\u0064.\u0020\u0025\u0076",_dab );
return _dab ;};_ffda ._cg =_fbg ;_ffda ._cgb =uint64 (_fbg )<<16;if _dab =_ffda .readByte ();_dab !=nil {return _dab ;};_ffda ._cgb <<=7;_ffda ._de -=7;_ffda ._bb =0x8000;_ffda ._cf ++;return nil ;};func (_ecg *DecoderStats )SetIndex (index int32 ){_ecg ._ec =index };
func (_eg *Decoder )decodeIntBit (_aa *DecoderStats )(int ,error ){_aa .SetIndex (int32 (_eg ._dfg ));_ddd ,_bac :=_eg .DecodeBit (_aa );if _bac !=nil {_ad .Log .Debug ("\u0041\u0072\u0069\u0074\u0068\u006d\u0065t\u0069\u0063\u0044e\u0063\u006f\u0064e\u0072\u0020'\u0064\u0065\u0063\u006f\u0064\u0065I\u006etB\u0069\u0074\u0027\u002d\u003e\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0042\u0069\u0074\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u002e\u0020\u0025\u0076",_bac );
return _ddd ,_bac ;};if _eg ._dfg < 256{_eg ._dfg =((_eg ._dfg <<uint64 (1))|int64 (_ddd ))&0x1ff;}else {_eg ._dfg =(((_eg ._dfg <<uint64 (1)|int64 (_ddd ))&511)|256)&0x1ff;};return _ddd ,nil ;};type DecoderStats struct{_ec int32 ;_bbb int32 ;_gaf []byte ;
_fbe []byte ;};func (_baf *DecoderStats )Copy ()*DecoderStats {_ecd :=&DecoderStats {_bbb :_baf ._bbb ,_gaf :make ([]byte ,_baf ._bbb )};copy (_ecd ._gaf ,_baf ._gaf );return _ecd ;};func (_acg *DecoderStats )String ()string {_cgbd :=&_f .Builder {};_cgbd .WriteString (_fc .Sprintf ("S\u0074\u0061\u0074\u0073\u003a\u0020\u0020\u0025\u0064\u000a",len (_acg ._gaf )));
for _aae ,_cbe :=range _acg ._gaf {if _cbe !=0{_cgbd .WriteString (_fc .Sprintf ("N\u006f\u0074\u0020\u007aer\u006f \u0061\u0074\u003a\u0020\u0025d\u0020\u002d\u0020\u0025\u0064\u000a",_aae ,_cbe ));};};return _cgbd .String ();};var (_b =[][4]uint32 {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
);func NewStats (contextSize int32 ,index int32 )*DecoderStats {return &DecoderStats {_ec :index ,_bbb :contextSize ,_gaf :make ([]byte ,contextSize ),_fbe :make ([]byte ,contextSize )};};type Decoder struct{ContextSize []uint32 ;ReferedToContextSize []uint32 ;
_g *_df .Reader ;_cg uint8 ;_cgb uint64 ;_bb uint32 ;_dfg int64 ;_de int32 ;_cf int32 ;_da int64 ;};func (_aca *DecoderStats )setEntry (_bd int ){_cgd :=byte (_bd &0x7f);_aca ._gaf [_aca ._ec ]=_cgd };func (_ea *DecoderStats )getMps ()byte {return _ea ._fbe [_ea ._ec ]};
func New (r *_df .Reader )(*Decoder ,error ){_e :=&Decoder {_g :r ,ContextSize :[]uint32 {16,13,10,10},ReferedToContextSize :[]uint32 {13,10}};if _cd :=_e .init ();_cd !=nil {return nil ,_cd ;};return _e ,nil ;};func (_dd *Decoder )renormalize ()error {for {if _dd ._de ==0{if _ef :=_dd .readByte ();
_ef !=nil {return _ef ;};};_dd ._bb <<=1;_dd ._cgb <<=1;_dd ._de --;if (_dd ._bb &0x8000)!=0{break ;};};_dd ._cgb &=0xffffffff;return nil ;};func (_cdb *DecoderStats )toggleMps (){_cdb ._fbe [_cdb ._ec ]^=1};func (_gf *Decoder )DecodeIAID (codeLen uint64 ,stats *DecoderStats )(int64 ,error ){_gf ._dfg =1;
var _bba uint64 ;for _bba =0;_bba < codeLen ;_bba ++{stats .SetIndex (int32 (_gf ._dfg ));_add ,_fb :=_gf .DecodeBit (stats );if _fb !=nil {return 0,_fb ;};_gf ._dfg =(_gf ._dfg <<1)|int64 (_add );};_ac :=_gf ._dfg -(1<<codeLen );return _ac ,nil ;};func (_ge *Decoder )lpsExchange (_bc *DecoderStats ,_ee int32 ,_ga uint32 )int {_af :=_bc .getMps ();
if _ge ._bb < _ga {_bc .setEntry (int (_b [_ee ][1]));_ge ._bb =_ga ;return int (_af );};if _b [_ee ][3]==1{_bc .toggleMps ();};_bc .setEntry (int (_b [_ee ][2]));_ge ._bb =_ga ;return int (1-_af );};func (_deb *Decoder )mpsExchange (_ced *DecoderStats ,_fce int32 )int {_dae :=_ced ._fbe [_ced ._ec ];
if _deb ._bb < _b [_fce ][0]{if _b [_fce ][3]==1{_ced .toggleMps ();};_ced .setEntry (int (_b [_fce ][2]));return int (1-_dae );};_ced .setEntry (int (_b [_fce ][1]));return int (_dae );};