//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _e "sync";func (_ffb *RuneByteMap )Range (f func (_fc rune ,_ag byte )(_cc bool )){_ffb ._aa .RLock ();defer _ffb ._aa .RUnlock ();for _cd ,_dec :=range _ffb ._c {if f (_cd ,_dec ){break ;};};};func (_ac *RuneByteMap )Write (r rune ,b byte ){_ac ._aa .Lock ();
defer _ac ._aa .Unlock ();_ac ._c [r ]=b };type RuneByteMap struct{_c map[rune ]byte ;_aa _e .RWMutex ;};func MakeRuneByteMap (length int )*RuneByteMap {_a :=make (map[rune ]byte ,length );return &RuneByteMap {_c :_a };};func (_fad *RuneSet )Write (r rune ){_fad ._eb .Lock ();
defer _fad ._eb .Unlock ();_fad ._ffc [r ]=struct{}{};};func (_fgg *RuneUint16Map )Range (f func (_db rune ,_bc uint16 )(_ccc bool )){_fgg ._fbb .RLock ();defer _fgg ._fbb .RUnlock ();for _cafe ,_ege :=range _fgg ._ad {if f (_cafe ,_ege ){break ;};};};
func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_d :m }};func (_acg *RuneUint16Map )Length ()int {_acg ._fbb .RLock ();defer _acg ._fbb .RUnlock ();return len (_acg ._ad );};func (_ba *RuneSet )Range (f func (_eg rune )(_fdf bool )){_ba ._eb .RLock ();
defer _ba ._eb .RUnlock ();for _da :=range _ba ._ffc {if f (_da ){break ;};};};func (_cfe *RuneStringMap )Write (r rune ,s string ){_cfe ._fb .Lock ();defer _cfe ._fb .Unlock ();_cfe ._eda [r ]=s ;};func (_aae *StringRuneMap )Write (g string ,r rune ){_aae ._ddd .Lock ();
defer _aae ._ddd .Unlock ();_aae ._eea [g ]=r ;};func (_gg *ByteRuneMap )Write (b byte ,r rune ){_gg ._de .Lock ();defer _gg ._de .Unlock ();_gg ._d [b ]=r };func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_eda :m }};type RuneUint16Map struct{_ad map[rune ]uint16 ;
_fbb _e .RWMutex ;};func (_egc *RuneUint16Map )Read (r rune )(uint16 ,bool ){_egc ._fbb .RLock ();defer _egc ._fbb .RUnlock ();_ggf ,_deg :=_egc ._ad [r ];return _ggf ,_deg ;};func (_cec *RuneUint16Map )Delete (r rune ){_cec ._fbb .Lock ();defer _cec ._fbb .Unlock ();
delete (_cec ._ad ,r );};func (_daf *StringRuneMap )Range (f func (_fe string ,_aeed rune )(_cafea bool )){_daf ._ddd .RLock ();defer _daf ._ddd .RUnlock ();for _dbd ,_aeedc :=range _daf ._eea {if f (_dbd ,_aeedc ){break ;};};};func (_ed *ByteRuneMap )Read (b byte )(rune ,bool ){_ed ._de .RLock ();
defer _ed ._de .RUnlock ();_g ,_fg :=_ed ._d [b ];return _g ,_fg ;};func NewStringsMap (tuples []StringsTuple )*StringsMap {_bag :=map[string ]string {};for _ ,_cgg :=range tuples {_bag [_cgg .Key ]=_cgg .Value ;};return &StringsMap {_bg :_bag };};func (_gb *RuneStringMap )Read (r rune )(string ,bool ){_gb ._fb .RLock ();
defer _gb ._fb .RUnlock ();_fca ,_fag :=_gb ._eda [r ];return _fca ,_fag ;};func (_ff *RuneByteMap )Read (r rune )(byte ,bool ){_ff ._aa .RLock ();defer _ff ._aa .RUnlock ();_ae ,_cf :=_ff ._c [r ];return _ae ,_cf ;};func (_ef *StringsMap )Read (g string )(string ,bool ){_ef ._gfd .RLock ();
defer _ef ._gfd .RUnlock ();_cde ,_aff :=_ef ._bg [g ];return _cde ,_aff ;};type StringRuneMap struct{_eea map[string ]rune ;_ddd _e .RWMutex ;};func (_gfe *StringRuneMap )Read (g string )(rune ,bool ){_gfe ._ddd .RLock ();defer _gfe ._ddd .RUnlock ();
_aab ,_edf :=_gfe ._eea [g ];return _aab ,_edf ;};func (_dd *ByteRuneMap )Range (f func (_ddg byte ,_gf rune )(_b bool )){_dd ._de .RLock ();defer _dd ._de .RUnlock ();for _fd ,_fa :=range _dd ._d {if f (_fd ,_fa ){break ;};};};func (_agf *RuneSet )Length ()int {_agf ._eb .RLock ();
defer _agf ._eb .RUnlock ();return len (_agf ._ffc )};func (_def *StringRuneMap )Length ()int {_def ._ddd .RLock ();defer _def ._ddd .RUnlock ();return len (_def ._eea );};func (_gd *RuneUint16Map )Write (r rune ,g uint16 ){_gd ._fbb .Lock ();defer _gd ._fbb .Unlock ();
_gd ._ad [r ]=g ;};func (_edg *RuneStringMap )Length ()int {_edg ._fb .RLock ();defer _edg ._fb .RUnlock ();return len (_edg ._eda );};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_ad :make (map[rune ]uint16 ,length )};};type ByteRuneMap struct{_d map[byte ]rune ;
_de _e .RWMutex ;};type RuneSet struct{_ffc map[rune ]struct{};_eb _e .RWMutex ;};func (_fgb *RuneUint16Map )RangeDelete (f func (_aeg rune ,_fgc uint16 )(_bcd bool ,_dc bool )){_fgb ._fbb .Lock ();defer _fgb ._fbb .Unlock ();for _fdfb ,_beg :=range _fgb ._ad {_dab ,_ce :=f (_fdfb ,_beg );
if _dab {delete (_fgb ._ad ,_fdfb );};if _ce {break ;};};};type StringsTuple struct{Key ,Value string ;};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_d :make (map[byte ]rune ,length )}};func (_gc *ByteRuneMap )Length ()int {_gc ._de .RLock ();
defer _gc ._de .RUnlock ();return len (_gc ._d )};func (_gcg *StringsMap )Range (f func (_ceg ,_ggfe string )(_daa bool )){_gcg ._gfd .RLock ();defer _gcg ._gfd .RUnlock ();for _dbe ,_gbd :=range _gcg ._bg {if f (_dbe ,_gbd ){break ;};};};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_eea :m }};
func (_be *RuneSet )Exists (r rune )bool {_be ._eb .RLock ();defer _be ._eb .RUnlock ();_ ,_cg :=_be ._ffc [r ];return _cg ;};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_ffc :make (map[rune ]struct{},length )}};func (_fgca *StringsMap )Write (g1 ,g2 string ){_fgca ._gfd .Lock ();
defer _fgca ._gfd .Unlock ();_fgca ._bg [g1 ]=g2 ;};func (_ca *RuneStringMap )Range (f func (_aee rune ,_aca string )(_caf bool )){_ca ._fb .RLock ();defer _ca ._fb .RUnlock ();for _gba ,_df :=range _ca ._eda {if f (_gba ,_df ){break ;};};};type RuneStringMap struct{_eda map[rune ]string ;
_fb _e .RWMutex ;};type StringsMap struct{_bg map[string ]string ;_gfd _e .RWMutex ;};func (_aeb *StringsMap )Copy ()*StringsMap {_aeb ._gfd .RLock ();defer _aeb ._gfd .RUnlock ();_cac :=map[string ]string {};for _ccg ,_cce :=range _aeb ._bg {_cac [_ccg ]=_cce ;
};return &StringsMap {_bg :_cac };};func (_af *RuneByteMap )Length ()int {_af ._aa .RLock ();defer _af ._aa .RUnlock ();return len (_af ._c )};