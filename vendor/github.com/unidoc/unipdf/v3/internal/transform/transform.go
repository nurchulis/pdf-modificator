//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_e "fmt";_f "github.com/unidoc/unipdf/v3/common";_a "math";);func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_bd Matrix )ScalingFactorX ()float64 {return _a .Hypot (_bd [0],_bd [1])};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};
func (_d *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_d [0],_d [1]=a ,b ;_d [3],_d [4]=c ,d ;_d [6],_d [7]=tx ,ty ;_d .clampRange ();};func (_fd Matrix )Scale (xScale ,yScale float64 )Matrix {return _fd .Mult (ScaleMatrix (xScale ,yScale ))};func (_ffd *Matrix )Shear (x ,y float64 ){_ffd .Concat (ShearMatrix (x ,y ))};
func (_ggb Matrix )ScalingFactorY ()float64 {return _a .Hypot (_ggb [3],_ggb [4])};func (_ca *Matrix )clampRange (){for _bfc ,_aag :=range _ca {if _aag > _gabe {_f .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_aag ,_gabe );
_ca [_bfc ]=_gabe ;}else if _aag < -_gabe {_f .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_aag ,-_gabe );_ca [_bfc ]=-_gabe ;};};};func (_ge Matrix )Rotate (theta float64 )Matrix {return _ge .Mult (RotationMatrix (theta ))};
func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};func RotationMatrix (angle float64 )Matrix {_b :=_a .Cos (angle );
_eg :=_a .Sin (angle );return NewMatrix (_b ,_eg ,-_eg ,_b ,0,0);};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_ga :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_ga .clampRange ();return _ga ;};const _ece =1.0e-6;func (_ff Matrix )String ()string {_gab ,_ab ,_be ,_c ,_ffc ,_fg :=_ff [0],_ff [1],_ff [3],_ff [4],_ff [6],_ff [7];
return _e .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_gab ,_ab ,_be ,_c ,_ffc ,_fg );
};func (_fa Matrix )Transform (x ,y float64 )(float64 ,float64 ){_ae :=x *_fa [0]+y *_fa [3]+_fa [6];_fag :=x *_fa [1]+y *_fa [4]+_fa [7];return _ae ,_fag ;};func (_gf Point )Distance (b Point )float64 {return _a .Hypot (_gf .X -b .X ,_gf .Y -b .Y )};func (_gc Point )Displace (delta Point )Point {return Point {_gc .X +delta .X ,_gc .Y +delta .Y }};
func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_adg Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_adg .X +t *b .X ,Y :(1-t )*_adg .Y +t *b .Y };};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};
func (_fcc Matrix )Unrealistic ()bool {_fab ,_cda ,_efb ,_aed :=_a .Abs (_fcc [0]),_a .Abs (_fcc [1]),_a .Abs (_fcc [3]),_a .Abs (_fcc [4]);_ea :=_fab > _cb &&_aed > _cb ;_fca :=_cda > _cb &&_efb > _cb ;return !(_ea ||_fca );};func (_cae *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_fbb :=NewMatrix (a ,b ,c ,d ,tx ,ty );
_cae .transformByMatrix (_fbb );};func (_de Matrix )Angle ()float64 {_bdg :=_a .Atan2 (-_de [1],_de [0]);if _bdg < 0.0{_bdg +=2*_a .Pi ;};return _bdg /_a .Pi *180.0;};func (_ec Matrix )Inverse ()(Matrix ,bool ){_gd ,_fc :=_ec [0],_ec [1];_ffb ,_gee :=_ec [3],_ec [4];
_cd ,_cc :=_ec [6],_ec [7];_ba :=_gd *_gee -_fc *_ffb ;if _a .Abs (_ba )< _ece {return Matrix {},false ;};_ce ,_fdf :=_gee /_ba ,-_fc /_ba ;_bf ,_ffbf :=-_ffb /_ba ,_gd /_ba ;_ceb :=-(_ce *_cd +_bf *_cc );_gea :=-(_fdf *_cd +_ffbf *_cc );return NewMatrix (_ce ,_fdf ,_bf ,_ffbf ,_ceb ,_gea ),true ;
};const _gabe =1e9;const _cb =1e-6;func (_edb *Point )transformByMatrix (_aea Matrix ){_edb .X ,_edb .Y =_aea .Transform (_edb .X ,_edb .Y )};func (_cg Matrix )Mult (b Matrix )Matrix {_cg .Concat (b );return _cg };func (_aa *Matrix )Concat (b Matrix ){*_aa =Matrix {b [0]*_aa [0]+b [1]*_aa [3],b [0]*_aa [1]+b [1]*_aa [4],0,b [3]*_aa [0]+b [4]*_aa [3],b [3]*_aa [1]+b [4]*_aa [4],0,b [6]*_aa [0]+b [7]*_aa [3]+_aa [6],b [6]*_aa [1]+b [7]*_aa [4]+_aa [7],1};
_aa .clampRange ();};const _aad =1e-10;type Matrix [9]float64 ;func (_ef Matrix )Translation ()(float64 ,float64 ){return _ef [6],_ef [7]};func (_eb Matrix )Round (precision float64 )Matrix {for _fb :=range _eb {_eb [_fb ]=_a .Round (_eb [_fb ]/precision )*precision ;
};return _eb ;};func (_ed Point )String ()string {return _e .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_ed .X ,_ed .Y );};func (_fe Point )Rotate (theta float64 )Point {_gb :=_a .Hypot (_fe .X ,_fe .Y );_beg :=_a .Atan2 (_fe .Y ,_fe .X );
_fga ,_df :=_a .Sincos (_beg +theta /180.0*_a .Pi );return Point {_gb *_df ,_gb *_fga };};func (_abb Matrix )Translate (tx ,ty float64 )Matrix {return _abb .Mult (TranslationMatrix (tx ,ty ))};type Point struct{X float64 ;Y float64 ;};func (_dc *Matrix )Clone ()Matrix {return NewMatrix (_dc [0],_dc [1],_dc [3],_dc [4],_dc [6],_dc [7])};
func (_ad Matrix )Identity ()bool {return _ad [0]==1&&_ad [1]==0&&_ad [2]==0&&_ad [3]==0&&_ad [4]==1&&_ad [5]==0&&_ad [6]==0&&_ad [7]==0&&_ad [8]==1;};func (_fgb *Point )Set (x ,y float64 ){_fgb .X ,_fgb .Y =x ,y };func (_gg Matrix )Singular ()bool {return _a .Abs (_gg [0]*_gg [4]-_gg [1]*_gg [3])< _aad };
